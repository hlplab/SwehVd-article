---
title             : "Evaluating normalization accounts against the dense vowel space of Central Swedish"
shorttitle        : "Evaluating normalization accounts"
date              : "`r format(Sys.time(), '%B %d, %Y')`"

author:
  - name: Anna Persson
    affiliation: '1'
    corresponding: yes
    address: 'Department of Swedish Language and Multilingualism, Stockholm University, SE-106 91 Stockholm, Sweden'
    email: 'anna.persson@su.se'
  - name: T. Florian Jaeger
    affiliation: '2,3'

affiliation:
  - id: '1'
    institution: Swedish Language and Multilingualism, Stockholm University
  - id: '2'
    institution: Brain and Cognitive Sciences, University of Rochester
  - id: '3'
    institution: Computer Science, University of Rochester

authornote: |
  We are grateful to ### ommitted for review
# We thank audiences at the Department of Swedish language and multilingualism at Stockholm University and the ExLing 2023 conference for feedback on earlier presentations of this work. We are particularly grateful to Santiago Barreda for insightful discussion of issues in the evaluation of normalization accounts, Tomas Riad for discussion of Swedish vowel systems, Maryann Tan for feedback on earlier version of this manuscript and for collaboration in preparation of the SwehVd database, and to Nathan Young for feedback on segmentation procedures, as well as for access to, and support for, the [SweFA software](https://github.com/mcgarrah/LG-FAVE) for the automatic annotation of Swedish vowels.

abstract: |
  Talkers vary in the phonetic realization of their vowels. One influential hypothesis holds that listeners overcome this inter-talker variability through pre-linguistic auditory mechanisms that normalize the acoustic or phonetic cues that form the input to speech recognition. Dozens of competing normalization accounts exist---including both accounts specific to vowel perception and general purpose accounts that can be applied to any type of cue. We add to the cross-linguistic literature on this matter by comparing normalization accounts against a new phonetically annotated vowel database of Swedish, a language with a particularly dense vowel inventory of 21 vowels differing in quality and quantity. All data and code for this study are shared via OSF, including the R markdown document that this article is generated from, and an R library that implements the models we present.

keywords          : "vowel normalization; speech perception; computational model"
wordcount         : "X"

bibliography      : ["latex-stuff/library.bib", "latex-stuff/r-references.bib"]
link-citations    : yes
csl               : latex-stuff/apa-6th-edition.csl

floatsintext      : yes
figurelist        : no
tablelist         : no
footnotelist      : no
linenumbers       : yes
numbersections    : false
mask              : no
draft             : no

header-includes:
 - \usepackage{animate}
 - \usepackage{amsmath}
 - \usepackage{tikz}
 - \usetikzlibrary{bayesnet}
 - \usepackage{booktabs}
 - \usepackage{siunitx}
 - \usepackage{soul}
 - \usepackage{tabto}
 - \usepackage{xcolor}
 - \usepackage{colortbl}
 - \usepackage{placeins}
 - \setstcolor{red}
 - \usepackage{sectsty}
 - \sectionfont{\color{black}}
 - \subsectionfont{\color{black}}
 - \subsubsectionfont{\color{black}}
 - \usepackage{setspace}\doublespacing
 - \usepackage{subfig}
 - \usepackage{lscape}
 - \usepackage{pdflscape}
 - \usepackage{tablefootnote}

documentclass     : "apa6"
classoption       : "man"
fontsize          : 11pt
output:
  papaja::apa6_pdf:
    latex_engine: xelatex
    includes:
      in_header: latex-stuff/header.tex
    keep_tex: yes
    #citation_package: default
    extra_dependencies: "subfig" 
always_allow_html: true
---

\setcounter{secnumdepth}{5}

```{r libraries, include=FALSE, message=FALSE}
library(curl)             # Check availability of internet for install of remote libraries

# Install remotes package if necessary
if(!requireNamespace("remotes", quietly = TRUE)) if (has_internet()) install.packages("remotes")
# Install the stable development version from GitHub
if (has_internet()) remotes::install_github("crsh/papaja")
library(papaja)           # APA formatted ms

library(tidyverse)        # data wrangling and plotting
library(magrittr)         # pipes, my friend, we need pipes
library(assertthat)       # for error checking
library(rlang)            # quosures and unquoting
library(ggforce)          # correlation matrices
library(plotly)           # for interactive HTML plots
library(mvtnorm)          # multivariate Gaussian distributions

if (has_internet()) remotes::install_github("hlplab/MVBeliefUpdatr")
library(MVBeliefUpdatr)   # for generating Ideal Observers

library(linguisticsdown)  # for inserting IPA symbols
library(kableExtra)       # for styling html format
library(modelr)
library(phonR)            # for vowel normalization functions
library(phonTools)        # for WattFabricius normalization function
```

```{r setup, include=FALSE}
library(knitr)

# Set knit defaults for code chunks
opts_chunk$set(
  dev='jpeg', # default format of figures
  fig.ext="jpeg",
  comment="",
  echo=FALSE, warning=FALSE, message=FALSE,
  cache=TRUE)

# some useful formatting functions for output of knitting
def.chunk.hook  <- knitr::knit_hooks$get("chunk")
knitr::knit_hooks$set(chunk = function(x, options) {
  x <- def.chunk.hook(x, options)
  ifelse(options$size != "normalsize", paste0("\n \\", options$size,"\n\n", x, "\n\n \\normalsize"), x)
})

color_block = function(color) {
  function(x, options) sprintf('\\color{%s}\\begin{verbatim}%s\\end{verbatim}\\color{black}', color, x)
}
knitr::knit_hooks$set(error = color_block('red'))
knitr::knit_hooks$set(warning = color_block('orange'))
```

```{r functions-and-pipes, include=FALSE}
source("constants.R")

myGplot.defaults("paper")

options(knitr.table.format = "latex")

base.width = 2.5
base.height = 2.5
base_size = 10
```

# To Do

  * Update TO DO regularly
  * Fill in XX.X% in general discussion.
  * Edits to text
    * anticipate main points in both introduction and discussion - inherent in many of the suggested accounts, a bunch of assumptions that follow much of the literature but may affect the results.
    * limitations: we are evaluating against naturally produced tokens, this might underestimate the effect of some normalization procedures bcs everything tends to be correlated in natural speech.
    * claims of f0 not affecting vowel quality, if f0 is allowed to vary freely, it has detrimental effects to vowel recognition (Assmann & Nearey - pairing small/large voices with high/low pitch).
    * clarify the 0 degrees of freedom statement.
  * Fix the OFS
  * Add REFS
    * missing REF to Miller being successful in separating vowels that differ in lip rounding.
    * which REF is nearey2018?
    * REF to the Nearey accounts being considered covert standardization accounts?

  * To work on while in review:
    * Formant transitions - how much information is there in there and does it change the ranking of normalization accounts if those are considered? Check this by including F1-F4 values at the start and end points in the trajectory in the IOs. Potentially include F4 as well, as Barreda said it contained important information.
    * Can we address the concern that the fact that we only have female talkers might underestimate the performance of some, in particular uniform scaling, accounts. One idea would be to generate fake male talkers by multiplying formants by .8 (15-20% height diff), and lowering f0 by one octave, and then conduct same analyses over combined data of real female and fake male talkers. In interpreting any differences in results this might cause, keep in mind that this approach generates the fake male talkers under the assumption of uniform scaling (still, it's going to be informative how much the performance of the unnormalized decreases).
    * fig 10: color labels, or only label a few vowels (or none).

```{r}
```
\newpage
\setcounter{page}{1}

# Introduction {#sec:intro}
Talkers differ in their pronunciation of individual speech sounds due to both physiological differences and socio-cultural factors, including style, regional dialect, and second language accents. For listeners, this means that the mapping from acoustic cues to linguistic categories---phonemes, syllables, words, and ultimately word meanings---varies depending on the talker. How listeners manage to typically understand talkers despite this "lack of invariance" [@liberman1967] has remained one of the central questions for research on speech perception. Hypotheses about the mechanisms underlying this ability can be grouped into three, mutually compatible and complementary, accounts: (1) low-level, pre-linguistic auditory transformation of the acoustic signal, (2) learning of changes in the linguistic representations, and (3) post-linguistic changes in decision-making biases [see e.g., @johnson2006; @pardo2006; @xie2022]. The present study focuses on the first type of account, that the acoustic signal is transformed and normalized early on during auditory processing [for recent reviews, @johnson-sjerps2021; @stilp2020]. 

The existence of some form of pre-linguistic normalization is motivated by *a priori* considerations about the physics of sounds [cf. the discussion of uniform scaling in @barreda2020a], evolutionary arguments [e.g., even non-human animals exhibit similar abilities, as reviewed in @barreda2020a], as well as brain imaging evidence: talker-normalized information about the speech signal can be decoded from areas as early as the brain stem [e.g., @sjerps2019; @sussman1986], and thus prior to even the earliest cortical areas typically associated with linguistic category representations or decision-making. While it is rather uncontroversial that normalization is part of adaptive speech perception, questions remain about the specific nature of the operations involved in normalization. We contribute to this line of research by comparing different types of normalization accounts against data from the production of short and long vowels of Stockholm Swedish.

Normalization accounts were originally proposed as a theory of how the brain removes *physiologically*-conditioned variation from the speech signal, reducing variability in, for example, category means between talkers, and thus reducing the overlap of phonological categories in the acoustic-phonetic space [e.g., @Bladon1984; @gerstman1968; @lobanov1971; @miller1989c; @nearey1978; @nordstrom1975; @peterson1961; @Syrdal1986; @sussman1986]. Most of this early work focused specifically on differences in formants, which cross-linguistically are the primary cues to distinctions in vowel quality, and known to be affected by the vocal tract size of the talker [e.g., @fox1995; @Peterson1952; @Verbrugge1977; @yang2014]. Figure \@ref(fig:illustrate-normalization) illustrates the effect of one of the most commonly applied normalization accounts [@lobanov1971] for the vowel spaces of three L1 speakers of US English [from the database reported in @xie2020asa]. By normalizing cues prior to categorization, physiological differences between talkers can be reduced, resulting in reduced between-talker variability (compare Figure \@ref(fig:illustrate-normalization)B to \@ref(fig:illustrate-normalization)A). If listeners' category representations pool experiences across talkers into a single talker-independent model, this reduced inter-talker variability results in reduced category overlap (compare Figure \@ref(fig:illustrate-normalization)D to \@ref(fig:illustrate-normalization)C).^[Talker-independent category representations are assumed in many influential models of spoken word recognition [e.g., @luce-pisoni1998; @mcclelland-elman1986; @norris-mcqueen2008]. While talker-independent representations might be a simplifying assumption for some of these theories, this assumption has persisted for decades [e.g. @magnuson2020; @tenbosch2022]. Exceptions include exemplar accounts [e.g., @johnson1997; @pierrehumbert2001] and the Bayesian ideal adaptor account [@kleinschmidt-jaeger2015]. Importantly, it is an unresolved question whether---or for which cues and phonetic contrasts---listeners maintain talker-specific *category* representations [for findings and discussion, see @kraljic-samuel2007; @kleinschmidt-jaeger2015; @kleinschmidt2019; @xie2021cognition]. In the present paper, we follow previous work and compare the effectiveness of normalization under the assumption of talker-independent category representations.]

(ref:illustrate-normalization) Illustrating how normalization reduces category overlap for the 8 monophthongs of L1 US English. Three talkers from the @xie2020asa database are shown before (**Panel A**) and after Lobanov normalization (**Panel B**). Lobanov normalization reduces inter-talker variability in the category means and, to some extent, in the category variances. The bottom two panels aggregate the data from all 17 talkers in the database (5 female, 12 male), showing the means and 95% probability mass bivariate Gaussian densities for each vowel before (**Panels C**) and after Lobanov normalization (**Panel D**).

```{r}
# Load native vowel data from Li & Xie database
d.Eng.LiXie <-
  read_csv('../../data/phonetic vowel statistics/English/Li_Xie_2020_L1_vowels_statistics_general.csv') %>%
    #remove variables related to Miller's height backness space to avoid confusion
    select(-F0_gm) %>%
    mutate(Language = "L1 English",
           Vowel = factor(
             plyr::mapvalues(
               Vowel,
               levels.vowel.Arpabet,
               levels.vowel.IPA),
             levels = levels.vowel.IPA)) %>%
  rename(category = Vowel, F0 = F0.mean, F1 = F1_gm, F2 = F2_gm, F3 = F3_gm) %>%
  relocate(F0, .before = F1) %>%
  group_by(Talker, category) %>%
  #Since the normalization and transformation functions does not take NAs, we replace NAs with the average F0 value for that Talker and category
  mutate(
    F0 = replace_na(F0, geometric.mean(F0)))
```

```{r}
set.seed(333421866)

d.Eng.LiXie.long <-
  d.Eng.LiXie %>%
  # Split data into five equally sized bins  
  split_data() %>%
  # Make cross-validation folds
  crossing(crossvalidation_group = 1:5) %>%
  mutate(fold_type = ifelse(crossvalidation_group != (fold + 3) %% 5 + 1, "training", "test")) %>%
  arrange(crossvalidation_group)

apply_all_transformations_and_normalization <-
  function(data) {
    data %>%
      get_transformation() %>%
      get_normalization_functions(
        data = .,
        normalize_based_on_fold_types = "training")() %>%
      rename(F0_Hz = F0, F1_Hz = F1, F2_Hz = F2, F3_Hz = F3) %>%
      add_C_CuRE(
        data = .,
        cues = c("F0_Hz", "F1_Hz", "F2_Hz", "F3_Hz", "F0_Mel", "F1_Mel", "F2_Mel", "F3_Mel", "F0_ERB", "F1_ERB", "F2_ERB", "F3_ERB", "F0_Bark", "F1_Bark", "F2_Bark", "F3_Bark", "F0_semitones", "F1_semitones", "F2_semitones", "F3_semitones", "Duration"),
        normalize_based_on_fold_types = "training")() %>%
      # Add '_r' for 'raw' to columns with scale-transformed data in order for pivoting to work in next chunk
      rename_with(.fn = ~ paste(.x, "r", sep = "_"), .cols = ends_with(c("Hz", "Mel", "Bark", "ERB", "semitones")))
  }

# Normalize all data based on the respective training of each cross-validation group
d.Eng.LiXie.long %<>%
  group_by(crossvalidation_group) %>%
  # Get transformations, apply normalizations (both classic formants one and C-CuRE)
  group_map(
    .f = ~ apply_all_transformations_and_normalization(data = .x),
    .keep = T
  ) %>%
  reduce(bind_rows) %>%
  ungroup() %>%
  pivot_longer(
    cols = starts_with("F", ignore.case = FALSE),
    names_to = c("Cue", "Normalization.Scale", "Normalization.Type"),
    names_sep = "_",
    values_to = "Cue.Value") %>%
  pivot_wider(
    names_from = "Cue",
    values_from = "Cue.Value") %>%
    # Mutate both
  mutate(Normalization.Type = paste(Normalization.Type, Normalization.Scale, sep = "_")) %>%
  select(-Normalization.Scale) %>%
  relocate(Talker, Normalization.Type, crossvalidation_group, fold_type, fold, category, Token)

p.Eng.LiXie.raw <-
  d.Eng.LiXie.long %>%
  filter(fold_type == "test", Normalization.Type == "r_Hz", Talker %in% c("E1", "E4", "E9")) %>%
  ggplot(
    aes(
      x = F2,
      y = F1)) +
  geom_point(
    aes(
      colour = category),
    alpha = .3) +
  # Add category means
  geom_point(
    data =
      ~ .x %>%
      group_by(category, Talker) %>%
      summarise(across(c(F1, F2), ~ mean(.x))),
    mapping = aes(
      colour = category),
    alpha = .8) +
  scale_color_brewer("Vowel", palette = "Paired") +
  scale_x_reverse("F2 (Hertz)", position = "top", breaks = scales::pretty_breaks(n = 3), limits = c(3100, 740)) +
  scale_y_reverse("F1 (Hertz)", breaks = scales::pretty_breaks(n = 3), limits = c(1100, 200)) +
  guides(color = "none") +
  facet_wrap(~ factor(Talker, levels = c("E1", "E4", "E9"), labels = c("Talker E1", "Talker E4", "Talker E9")), ncol = 1) +
  theme(axis.text = element_text(size = 7),
        axis.title.y = element_text(vjust = 0))

p.Eng.LiXie.Lobanov <-
  p.Eng.LiXie.raw %+%
  (d.Eng.LiXie.long %>%
  filter(fold_type == "test", Normalization.Type == "Lobanov_Hz", Talker %in% c("E1", "E4", "E9"))) +
  scale_x_reverse("F2 (Lobanov)", position = "top", breaks = scales::pretty_breaks(n = 3), limits = c(2.55, -1.8)) +
  scale_y_reverse("F1 (Lobanov)", breaks = scales::pretty_breaks(n = 3), limits = c(2, -2))

p.Eng.LiXie.all.raw <-
  d.Eng.LiXie.long %>%
  filter(fold_type == "test", Normalization.Type == "r_Hz") %>%
  ggplot(
    aes(
      x = F2,
      y = F1,
      color = category)) +
  stat_ellipse() +
  geom_point(
    data =
      ~ .x %>%
      group_by(category) %>%
      summarise(across(c(F1, F2), ~ mean(.x))),
    mapping = aes(
      colour = category),
    alpha = .8) +
  scale_color_brewer("Vowel", palette = "Paired") +
  scale_y_reverse("", breaks = scales::pretty_breaks(n = 3), limits = c(1100, 200)) +
  scale_x_reverse() +
  facet_wrap(~ factor(Normalization.Type, levels = c("r_Hz", "Lobanov_Hz"), labels = c("all talkers", "all talkers")), scales = "free") +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title.x = element_blank())

p.Eng.LiXie.all.Lob <-
  p.Eng.LiXie.all.raw %+%
  (d.Eng.LiXie.long %>%
     filter(fold_type == "test", Normalization.Type == "Lobanov_Hz")) +
  scale_y_reverse("", breaks = scales::pretty_breaks(n = 3), limits = c(2, -2)) +
  guides(color = "none")

#Get legend from final plot
legend <-
  cowplot::get_legend(
    # create some space to the left of the legend
    p.Eng.LiXie.all.raw +
      guides(color = guide_legend(nrow = 1, byrow = TRUE)) +
      theme(legend.direction = "horizontal",
            legend.justification="center",
            legend.box.just = "top"))
```

```{r illustrate-normalization, fig.width=base.width*2.5, fig.height=base.height*3.5+.5, out.width='75%', fig.align='center', fig.cap="(ref:illustrate-normalization)"}
cowplot::plot_grid(
  legend,
  cowplot::plot_grid(
    cowplot::plot_grid(p.Eng.LiXie.raw, p.Eng.LiXie.all.raw + theme(legend.position = "none"), labels = c("A", "C"), ncol = 1, align = "hv", rel_heights = c(3/4, 1/4)), 
    NULL,
    cowplot::plot_grid(
      p.Eng.LiXie.Lobanov, p.Eng.LiXie.all.Lob, labels = c("B", "D"), ncol = 1, align = "hv", rel_heights = c(3/4, 1/4)),
    ncol = 3, align = "hv", rel_widths = c(1, -.05, .95)),
    align = "hv", axis = "bltr", nrow = 2, rel_heights = c(.05, .95))
```

Dozens of different accounts of vowel normalization have been proposed over the years [e.g., @Bladon1984; @fant1975; @gerstman1968; @joos1948; @lobanov1971; @miller1989c; @nearey1978; @nordstrom1975; @Syrdal1986; @traunmuller1981; @watt2002; @zahorian1991; for reviews, see @barreda2020a; @weatherholtz-jaeger2016]. @carpenter1993 summarize over 100 different vowel-specific normalization accounts, many of them closely related to each other. More recently, additional *general* normalization accounts have emerged that can be applied to *any* type of cue and phonological contrast [e.g., @cole2010; @mcmurray-jongman2011]. The most widely used of these proposals, C-CuRE, has since been successfully applied to the categorization of US English fricatives [@apfelbaum2014; @crinnion2020; @mcmurray-jongman2011], stop voicing [@kulikov2022; @toscano2015; @xie2022], vowels [@kleinschmidt2019; @mcmurray-jongman2016], and sentence-final rising question vs. statement intonation [@xie2021cognition]. In each of these studies, C-CuRE reduced inter-talker variability and improved categorization. C-CuRE stands for "**c**omputing **cu**es **r**elative to **e**xpectations", capturing the motivation behind many of the earlier normalization accounts that cue values should be interpreted relative to the distribution they are expected to have in the present context. In addition to being more general than earlier accounts, C-CuRE also addresses one of the main arguments against normalization as an account of human speech perception [e.g., @johnson2006, which continues to be frequently cited in reviews of exemplar theory]: by focusing on listeners' expectations rather than talkers' physiology, accounts like C-CuRE capture that inter-talker variability is not limited to physiology.

Table \@ref(tab:norm-accounts) lists the normalization accounts investigated in the present study. This includes both the most influential vowel-specific normalization accounts that have been found to perform well in previous works (e.g., Lobanov and Nearey2 normalization) and several variants of the general purpose normalization C-CuRE. As indicated through shading in the table, the accounts can be grouped into four types based on the computational assumptions they make. *Transformations* are meant to transform the formant data from acoustic (Hz) into a perceptual space that approximates the perceptual organization of auditory information in the human brain. All other accounts instead or additionally adjust each formant value based on either the values of other formants on the same segment (*vowel-intrinsic* approaches) or summary statistics of the formant across segments (*vowel-extrinsic* approaches).^[Miller's formant-ratio account [@miller1989c] is technically a hybrid approach: the first formant (F1) is normalized with regard to an extrinsic sensory reference (based on the average F0 across segments); subsequent formants are (intrinsicly) normalized using the normalized lower formants on the same vowel segment.] We further distinguish two types of vowel-extrinsic approaches that differ in their computational complexity and tractability: approaches that *center* each cue relative to its mean across all vowel segments, and approaches that instead/additionally *standardize* cues relative to the overall variability or range of the cue across all vowel segments [for reviews, see also e.g., @Johnson2005c; @kohn2012a; @weatherholtz-jaeger2016].^[Here we group accounts based on their computational complexity (the number of parameters listeners are assumed to estimate). For example, we group Nearey1 and Nearey2 with the centering accounts because they require estimation of only cue means. However, since these accounts perform centering over log-transformed Hz, they can also be considered as forming a form of standardization in non-log space [@REF].] The former type includes C-CuRE, and we consider different variants of this approach, one for each transformation approach in Table \@ref(tab:norm-accounts).^[Since we are interested in understanding mechanisms underlying *human* speech perception, we aim at evaluating accounts that are sufficiently general in nature to be applied across languages. This means that we for instance do not include Watt & Fabricius [@watt2002; @fabricius2009], another frequently used normalization account, as it requires making specific assumptions of vowel inventories of the language.]

\begin{landscape}\begin{table}
\caption{\label{tab:norm-accounts}Normalization accounts considered in the present study. Unless otherwise marked, formant variables ($F$s) in the right-handside of normalization formulas are in Hz.}
\centering
\fontsize{8}{10}\selectfont
\begin{tabular}[t]{>{\arraybackslash}p{0.1cm}>{\arraybackslash}p{0.2cm}>{\arraybackslash}p{0.5cm}|>{\raggedright\arraybackslash}p{3cm}|>{\raggedright\arraybackslash}p{3cm}|>{\raggedright\arraybackslash}p{4cm}|>{\raggedright\arraybackslash}p{6.2cm}}
\hline
& & & Normalization procedure & Perceptual scale & Source & Formula\\
\hline
\hline
& & & n/a & Hz & n/a & n/a \\

\hline

& & \cellcolor[HTML]{C9C0BB}{} & \cellcolor[HTML]{C9C0BB}{n/a} & \cellcolor[HTML]{C9C0BB}{Bark} & \cellcolor[HTML]{C9C0BB}{Traunmüller (1990)} & \cellcolor[HTML]{C9C0BB}{$F_n^{Bark} = \frac{26.81 \times F_n}{1960 + F_n} - 0.53$} \\
& & \cellcolor[HTML]{C9C0BB}{} & \cellcolor[HTML]{C9C0BB}{---} & \cellcolor[HTML]{C9C0BB}{ERB}  & \cellcolor[HTML]{C9C0BB}{Glasberg \& Moore (1990)} & \cellcolor[HTML]{C9C0BB}{$F_n^{ERB} = 21.4 \times \log_{10}(1 + F_n \times 0.00437)$} \\
\multirow[c]{-2}{*}{\rotatebox{90}{trans-}} & & \cellcolor[HTML]{C9C0BB}{} & \cellcolor[HTML]{C9C0BB}{---} & \cellcolor[HTML]{C9C0BB}{Mel}  & \cellcolor[HTML]{C9C0BB}{Stevens \& Volkmann (1940)} & \cellcolor[HTML]{C9C0BB}{$F_n^{Mel} = 2595 \times \log_{10}(1 + \frac{F_n}{700})$} \\
& \multirow[c]{-4}{*}{\rotatebox{90}{formation}} & \cellcolor[HTML]{C9C0BB}{} & \cellcolor[HTML]{C9C0BB}{---} & \cellcolor[HTML]{C9C0BB}{Semitones conversion} & \cellcolor[HTML]{C9C0BB}{Fant et al. (2002)} & \cellcolor[HTML]{C9C0BB}{$F_n^{ST} = 12 \times \frac{ln(\frac{F_n}{100})}{ln}$} \\

\hline

& & \cellcolor[HTML]{E6BE8A}{} & \cellcolor[HTML]{E6BE8A}{Syrdal \& Gopal's} & \cellcolor[HTML]{E6BE8A}{Bark} & \cellcolor[HTML]{E6BE8A}{Syrdal \& Gopal (1986)} & \cellcolor[HTML]{E6BE8A}{$F1^{SyrdalGopal} = F1^{Bark} - F0^{Bark}$} \\
& & \cellcolor[HTML]{E6BE8A}{} & \cellcolor[HTML]{E6BE8A}{Bark-distance model\tablefootnote{Previous work has considered two different implementations of Syrdal \& Gopal's Bark-distance model for F2, depending on the language (Adank, 2003; Fant, 1983; Syrdal \& Gopal, 1986). In the SI (Section \ref{sec:SG-eval}), we compare these two implementations, and find that the F2-F1 implementation performs better for the present data. We thus present that version of Syrdal \& Gopal's model in the main text of Studies 1 and 2.}} & \cellcolor[HTML]{E6BE8A}{} & \cellcolor[HTML]{E6BE8A}{} & \cellcolor[HTML]{E6BE8A}{$F2^{SyrdalGopal} = F2^{Bark} - F1^{Bark}$} \\
& & \cellcolor[HTML]{E6BE8A}{} & \cellcolor[HTML]{E6BE8A}{Miller} & \cellcolor[HTML]{E6BE8A}{log} & \cellcolor[HTML]{E6BE8A}{Miller (1989)} & \cellcolor[HTML]{E6BE8A}{$SR = k (\frac{GM f0}{k})^{1/3}$} \\
& & \cellcolor[HTML]{E6BE8A}{} & \cellcolor[HTML]{E6BE8A}{(formant-ratio)} & \cellcolor[HTML]{E6BE8A}{} & \cellcolor[HTML]{E6BE8A}{} & \cellcolor[HTML]{E6BE8A}{$F1^{Miller} = log(\frac{F1}{SR})$} \\
& & \cellcolor[HTML]{E6BE8A}{} & \cellcolor[HTML]{E6BE8A}{} & \cellcolor[HTML]{E6BE8A}{} & \cellcolor[HTML]{E6BE8A}{} & \cellcolor[HTML]{E6BE8A}{$F2^{Miller} = log(\frac{F2}{F1})$} \\
{\multirow[c]{-7}{*}{\rotatebox{90}{intrinsic}}} & & \cellcolor[HTML]{E6BE8A}{} & \cellcolor[HTML]{E6BE8A}{} & \cellcolor[HTML]{E6BE8A}{} & \cellcolor[HTML]{E6BE8A}{} & \cellcolor[HTML]{E6BE8A}{$F3^{Miller} = log(\frac{F3}{F2})$} \\

\hline

& & \cellcolor[HTML]{ABCDEF}{} & \cellcolor[HTML]{ABCDEF}{C-CuRE} & \cellcolor[HTML]{ABCDEF}{Hz} & \cellcolor[HTML]{ABCDEF}{McMurray \& Jongman (2011)} & \cellcolor[HTML]{ABCDEF}{$F^{C-CuRE}_n = F_n - mean(F_n)$} \\
& & \cellcolor[HTML]{ABCDEF}{} & \cellcolor[HTML]{ABCDEF}{---} & \cellcolor[HTML]{ABCDEF}{Bark} & \cellcolor[HTML]{ABCDEF}{} & \cellcolor[HTML]{ABCDEF}{} \\
& & \cellcolor[HTML]{ABCDEF}{} & \cellcolor[HTML]{ABCDEF}{---} & \cellcolor[HTML]{ABCDEF}{ERB} & \cellcolor[HTML]{ABCDEF}{} & \cellcolor[HTML]{ABCDEF}{} \\
& & \cellcolor[HTML]{ABCDEF}{} & \cellcolor[HTML]{ABCDEF}{---} & \cellcolor[HTML]{ABCDEF}{Mel} & \cellcolor[HTML]{ABCDEF}{} & \cellcolor[HTML]{ABCDEF}{} \\
& & \cellcolor[HTML]{ABCDEF}{} & \cellcolor[HTML]{ABCDEF}{---} & \cellcolor[HTML]{ABCDEF}{Semitones conversion} & \cellcolor[HTML]{ABCDEF}{} & \cellcolor[HTML]{ABCDEF}{} \\

& & \cellcolor[HTML]{ABCDEF}{} & \cellcolor[HTML]{ABCDEF}{Nearey1} & \cellcolor[HTML]{ABCDEF}{log} & \cellcolor[HTML]{ABCDEF}{Nearey (1978)} & \cellcolor[HTML]{ABCDEF}{$F^{Nearey1}_n = \ln(F_n) - mean(ln(F_n))$} \\
& & \cellcolor[HTML]{ABCDEF}{} & \cellcolor[HTML]{ABCDEF}{(log-mean)} & \cellcolor[HTML]{ABCDEF}{} & \cellcolor[HTML]{ABCDEF}{} & \cellcolor[HTML]{ABCDEF}{} \\

& & \cellcolor[HTML]{ABCDEF}{} & \cellcolor[HTML]{ABCDEF}{Nearey2} & \cellcolor[HTML]{ABCDEF}{log} & \cellcolor[HTML]{ABCDEF}{Nearey (1978)} & \cellcolor[HTML]{ABCDEF}{$F^{Nearey2}_n = \ln(F_n) - mean(ln(F))$} \\
& & \cellcolor[HTML]{ABCDEF}{} & \cellcolor[HTML]{ABCDEF}{(single parameter} & \cellcolor[HTML]{ABCDEF}{} & \cellcolor[HTML]{ABCDEF}{} & \cellcolor[HTML]{ABCDEF}{} \\
& & \cellcolor[HTML]{ABCDEF}{{\multirow[c]{-10}{*}{\rotatebox{90}{centering}}}} & \cellcolor[HTML]{ABCDEF}{log-mean)} & \cellcolor[HTML]{ABCDEF}{} & \cellcolor[HTML]{ABCDEF}{} & \cellcolor[HTML]{ABCDEF}{} \\

\cline{3-6}

& & \cellcolor[HTML]{DDADAF}{} & \cellcolor[HTML]{DDADAF}{Gerstman} & \cellcolor[HTML]{DDADAF}{Hz} & \cellcolor[HTML]{DDADAF}{Gerstman (1968)} & \cellcolor[HTML]{DDADAF}{$F_n^{Gerstman} = 999 \times \frac{F_n - F_n^{min}}{F_n^{max} - F_n^{min}}$} \\
& & \cellcolor[HTML]{DDADAF}{} & \cellcolor[HTML]{DDADAF}{(range normalization)} & \cellcolor[HTML]{DDADAF}{} & \cellcolor[HTML]{DDADAF}{} & \cellcolor[HTML]{DDADAF}{} \\
& & \cellcolor[HTML]{DDADAF}{} & \cellcolor[HTML]{DDADAF}{} & \cellcolor[HTML]{DDADAF}{} & \cellcolor[HTML]{DDADAF}{} & \cellcolor[HTML]{DDADAF}{} \\

{\multirow[c]{-16}{*}{\rotatebox{90}{extrinsic}}} & & \cellcolor[HTML]{DDADAF}{} & \cellcolor[HTML]{DDADAF}{Lobanov} & \cellcolor[HTML]{DDADAF}{Hz} & \cellcolor[HTML]{DDADAF}{Lobanov (1971)} & \cellcolor[HTML]{DDADAF}{$F^{Lobanov}_n = \frac{F_n - mean(F_n)}{sd(F_n)}$} \\
& & \cellcolor[HTML]{DDADAF}{} & \cellcolor[HTML]{DDADAF}{(z-score)} & \cellcolor[HTML]{DDADAF}{} & \cellcolor[HTML]{DDADAF}{} & \cellcolor[HTML]{DDADAF}{} \\
& & \cellcolor[HTML]{DDADAF}{{\multirow[c]{-6}{*}{\rotatebox{90}{standardizing}}}} & \cellcolor[HTML]{DDADAF}{} & \cellcolor[HTML]{DDADAF}{} & \cellcolor[HTML]{DDADAF}{} & \cellcolor[HTML]{DDADAF}{} \\


\hline
\end{tabular}
\end{table}

\end{landscape}

Previous comparisons of normalization accounts have primarily focused on English [e.g., @adank2004; @barreda2018a; @carpenter1993; @clopper2009; @disner1980; @escudero2007; @fabricius2009; @Flynn2011; @hindle1978; @kohn2012a; @labov2010; @richter2017; @syrda1985]. Additional studies have investigated, for example, Dutch [@adank2004; @disner1980], Russian [@lobanov1971], and Brazilian Portuguese [@escudero2007]. The complexity of the vowel inventories (7-11 monophthongs) and the number of these vowels included in the comparison (2-11) varied across these studies. We add to this literature by comparing normalization accounts against a new phonetically annotated database of Stockholm Swedish (SwehVd, introduced below). With a total of 21 monophthong allophones that vary in quantity (long vs. short vowels) and quality, the vowel inventory of Swedish is crowded compared to most languages previously studied in the normalization literature. This allows us to test whether the same normalization accounts that work well for simpler vowel inventories generalize well to more crowded vowel spaces. Additionally, the presence of quantity contrasts between long and short allophones means that Swedish provides a suitable case study to bridge the literature between vowel-specific normalization accounts (which focus on formants, and thus only quality contrasts) and general normalization accounts that can be applied to any type of cue (and thus also vowel duration, which is expected to be the primary cue to vowel quantity). Relatedly, previous studies have found both F3 and vowel duration to be important cues to vowel categorization in Swedish [e.g., @behne1997; @fujimura1967; @haddingkoch1964]. These two cues have never (duration) or rarely [F3, but see e.g. @adank2004; @barreda2018a; @carpenter1993; @nearey1989; @syrda1985] been included in comparisons of normalization accounts.

We compare the normalization accounts in Table \@ref(tab:norm-accounts) both in terms of their effectiveness in reducing within-category variability relative to between-category variability (Study 1) and in terms of the predicted consequences for recognition accuracy (Study 2). We originally only conducted Study 2, which more directly addresses our goal of assessing the predicted consequences of normalization for perception. We then included Study 1 because it reflects an approach that continues to be common in research on normalization. In hindsight, this addition of Study 1 turned out to reveal serious shortcomings of separability indices and similar measures of between- vs. within-category variability, highlighting the importance of using models of speech perception when evaluating the consequences of normalization for perception [as we do in Study 2, for related discussion, see @barreda2021].

Following the bulk of previous work [but see e.g., @barreda2021; @mcmurray-jongman2016; @nearey1989; @richter2017], the present studies do not compare the predicted consequences of normalization against categorization responses from human listeners, though we plan to do so in future work. We discuss this and other limitations---most shared with previous work---after presenting our studies. As part of that discussion, we also raise conceptual considerations about the *a priori* plausibility of different normalization accounts. 

Both Study 1 and 2 compare normalization accounts applied to (1) only F1 and F2, as in the majority of previous studies, (2) F1-F3, as in, e.g., @adank2004, and (3) F0-F3 as well as vowel duration. This allows us to assess whether differences in the effectiveness of normalization accounts depend on the number and types of cues that are considered. Since listeners integrate cues beyond F1 and F2 [e.g., @Assmann1982; @hillenbrand1999; @nearey1986], this is an important gap in evaluating the plausibility of different normalization accounts as models of adaptive speech perception. All three comparisons are evaluated both separately for short and long vowels, and for the entire space of the 21 vowels. This allows us to assess whether the same types of normalization perform well across the entire vowel inventory. 

To the best of our knowledge, only one previous study has compared normalization accounts against Swedish, as part of a cross-linguistic comparison across six Germanic languages [@disner1980]. @disner1980 compared 4 normalization accounts, using F1 and F2 means of the nine long Swedish vowels spoken by 24 male Swedish talkers [from a database presented in @fant1969]. Of interest to the present study, the results for Swedish differed from the other Germanic languages in two unexpected ways. Whereas Lobanov normalization---which involves centering and standardizing (cf. Table \@ref(tab:norm-accounts))---performed best for Swedish, Nearey2 normalization---which involves only centering---performed best for the other four languages. And, while normalization effectively reduced inter-talker variability in category variances for the other four languages by 61%-71%, it was substantially less effective for Swedish (41%). As discussed by @disner1980, this raises the question as to whether these findings reflect an inherent property of Swedish or merely differences in the phonetically annotated databases available for each language. In particular, the Swedish data consisted of *vowels* produced in isolation without any lexical or phonetic context, whereas the data for the five other languages consisted of isolated *word* productions (paralleling the majority of research on normalization). The present study addresses this difference: the new database we introduce consists of *h*-VOWEL-*d* word recordings, which makes our stimuli directly comparable to those used in previous work on normalization. Additionally, we complement Disner's study by focusing on female, rather than male talkers, by considering both long and short vowels (separately and together), and by including the general normalization account C-CuRE. This lets us revisit whether simple *centering* accounts perform best for Swedish---like for the other languages in @disner1980.

All data and code for this article can be downloaded from OSF at (URL)<!-- enter htlm-->. This article is written in R markdown, allowing readers to replicate our analyses using freely available software [@R; @RStudio], while changing any of the parameters of our models. Readers can revisit the assumptions we make---for example, by substituting alternative normalization models. The supplementary information (SI) lists the software/libraries required to compile this document. Next we introduce the new phonetically annotated corpus of Stockholm Swedish vowel productions employed in the present studies.

```{r load-SwehVd}
# Load native Swedish vowel data, manually corrected, but with distributional outliers remaining (generated by Persson-2021-outlierCorrected)
d.SwehVd <-
  read_csv('../../data/phonetic vowel statistics/Swedish/Persson_2021_L1_vowels_wDistrOutliers.csv')
```

# The SwehVd database {#sec:swehvd}
The SwehVd database is a new phonetically annotated corpus of Swedish *h*-VOWEL-*d* (short: hVd) word recordings. All recordings, annotations, and acoustic measurements are available on OSF.<!-- TO DO: insert html here. This might be a separate URL or the same as for the paper.--> SwehVd was collected with the goal to characterize the Stockholm Swedish vowel space within and across talkers. It covers the entire monophthong inventory of Central Swedish, including all nine long vowels (*hid*, *hyd*, *hud*, *hed*, *häd*, *höd*, *had*, *håd*, *hod*), eight short vowels (*hidd*, *hydd*, *hudd*, *hedd*, *hädd*, *hödd*, *hadd*, *hådd*, *hodd*), and four allophones (*härd*, *härr*, *hörd*, *hörr*).^[Stockholm Swedish is a variety subsumed under Central Swedish, the regional standard variety of Swedish spoken in an area around and beyond Stockholm (eastern Svealand), including Mälardalssvenska, Sveamål, Uppsvenska, Mellansvenska [see e.g., @bruce2009; @elert1994; @riad2014]. The SwehVd targets the contemporary Central Swedish spoken in the larger Stockholm area, see more under Section \@ref(sec:participants).] To our knowledge, there are few publicly available databases of Swedish vowel productions that are phonetically annotated [e.g., @bruce1999; @eklund1997; @fant1969; @kuronen2000]. The largest and perhaps best-known is SweDia 2000 [@bruce1999]. SweDia 2000 was developed to characterize differences in vowel pronunciations *across* regional varieties of Swedish. It consists of recordings of spontaneous speech, isolated words in varying phonological contexts, and phrases in isolation from approximately 1300 talkers of 107 regional backgrounds, with 10-12 recorded talkers per region and 5-15 recordings per vowel for each talker.

Unlike most existing databases, SwehVd focuses on a single regional variety, providing high resolution within and across talkers for this variety: SwehVd consists of N=10 recordings of each hVd word (for a total of 210 recordings for the 21 different hVd words) per talker. We note that this makes the demographic composition of SwehVd relatively homogenous, compared both to some other vowel corpora of Swedish [e.g., @bruce1999; @kuronen2000] and to some previous studies on normalization---a point we return to in the general discussion. Specifically, we target N = 24 male and female talkers each (current N = `r n_distinct(d.SwehVd$Talker)`, all female) for a total targeted N of tokens = 10,080 (current N = `r nrow(d.SwehVd %>% distinct(Talker, category, Token))` tokens). The accompanying database contains first to third formant (F1-F3) measurements for each talker at five time points across each vowel, together with vowel duration and mean F0 over the entire vowel.

SwehVd follows the gross of research on normalization and uses hVd words for recording in order to minimise coarticulatory effects from the surrounding phonetic context. The hVd context was originally chosen for studies on English because the glottal /h/ in onset position minimizes supraglottal articulations [confirmed in e.g., @chesworth2003; @robb2009]. Since then hVd words have played a central role in research on vowel production [e.g., @hillenbrand1995; @Peterson1952] and perception [e.g., @malinasky2020; @Peterson1952]. Since Swedish onset /h/ is a glottal approximant [@riad2014] similar to English, the use of this context in SwehVd facilitates comparison to similar databases from other languages. It deviates, however, from the majority of previous studies on Swedish vowels, which have either not held phonetic context constant across vowels [e.g., @bruce1999], or have investigated vowel production out of context [@eklund1997; @fant1969; @disner1980] or in different CVC contexts [e.g., *k*V*p* and *p*V*k* in @nordstrand2004; *v*V*t*, *v*V*tt*, *f*V*t*, *f*V*tt*, in @behne1997].

## The Swedish vowel inventory {#sec:sweVowelinventory}
The Central Swedish vowel inventory contains 21 monophthong vowels. Seventeen of these vowels form nine pairs distinguished by quantity (long and short): in Central Swedish, the two long vowels [`r linguisticsdown::cond_cmpl("ɛː")`] and [`r linguisticsdown::cond_cmpl("eː")`] both neutralize to the same short vowel [`r linguisticsdown::cond_cmpl("ɛ")`] (resulting in a total of 17, rather than 18, distinct vowels). The two variants of a pair are considered allophones, the selection of which is determined primarily by stress and syllable complexity. Quantity is neutralized in unstressed positions [@riad2014].^[This reflects the mainstream analytical position in present-day Swedish phonology. The opposite position, distinctive vowel quantity, has also been proposed [e.g., @linell1978; @linell1979; @schaeffler2005a]. This theoretical debate does not affect the interpretation of our results.] Vowels lengthen in open word-final syllables, before morpheme-final single consonants, and in non-final syllables.

Additionally, there are four contextually conditioned allophones to [`r linguisticsdown::cond_cmpl("ɛ")`] and [`r linguisticsdown::cond_cmpl("ø")`]. Before /r/ (or any retroflex segment), both the long and short versions of these vowels lower to long and short [`r linguisticsdown::cond_cmpl("æ")`] and [`r linguisticsdown::cond_cmpl("œ")`], respectively. As shown in Table \@ref(tab:swedish-vowels) [adapted from @riad2014], some long-short vowel pairs are described to differ not only in quantity but also in quality: generally, short vowels are described as more open and also more centralized, forming a more condensed vowel space. In ongoing work [@persson2023], we found this to be confirmed for SwehVd.

Several of the long vowels have been claimed to be diphthongized in Central Swedish [e.g., @elert1981; @fant1969; @fant1971; @kuronen2000] and/or with consonantal elements [@mcallister1974], though empirical evaluations of this claim have returned mixed results [@eklund1997; @fant1969; @leinonen2010]. In separate work [@persson2023], we have found evidence for diphthongization of some vowels in SwehVd, including some for which it has not previously been reported. Here we do not discuss this issue further since it has no direct consequences for the present study: normalization can be applied to both monophthongs and diphthongs, and listeners presumably use the full information contained in the dynamics of formant trajectories---rather than just aggregate point estimates (the simplifying information we make below, following other work on normalization). 

\begin{table}
\caption{\label{tab:swedish-vowels}The phonological characterization of long (left) and short (right) Central Swedish vowels (based on Riad, 2014)}
\centering
\begin{tabular}[t]{c|c|c|c|c}
\hline
&front&rounded&central&back\\
\hline
high&`r linguisticsdown::cond_cmpl("[iː]")`&`r linguisticsdown::cond_cmpl("[yː]")`&&`r linguisticsdown::cond_cmpl("[uː]")`\\
\hline
mid-high&`r linguisticsdown::cond_cmpl("[eː]")`&`r linguisticsdown::cond_cmpl("[ʉː]")`&&`r linguisticsdown::cond_cmpl("[oː]")`\\
\hline
mid&`r linguisticsdown::cond_cmpl("[ɛː]")`&`r linguisticsdown::cond_cmpl("[øː]")`&&\\
\hline
low&`r linguisticsdown::cond_cmpl("[æː]")`&`r linguisticsdown::cond_cmpl("[œː]")`&&`r linguisticsdown::cond_cmpl("[ɑː]")`\\
\end{tabular}
\hspace{2em}
\begin{tabular}[t]{c|c|c|c|c}
\hline
&front&rounded&central&back\\
\hline
high&`r linguisticsdown::cond_cmpl("[ɪ]")`&`r linguisticsdown::cond_cmpl("[ʏ]")`&`r linguisticsdown::cond_cmpl("[ɵ]")`&`r linguisticsdown::cond_cmpl("[ʊ]")`\\
\hline
&&&&\\
\hline
mid&`r linguisticsdown::cond_cmpl("[ɛ]")`&`r linguisticsdown::cond_cmpl("[ø]")`&`r linguisticsdown::cond_cmpl("[œ]")`&`r linguisticsdown::cond_cmpl("[ɔ]")`\\
\hline
low&`r linguisticsdown::cond_cmpl("[æ]")`&&`r linguisticsdown::cond_cmpl("[a]")`&\\
\end{tabular}
\end{table}

## Participants {#sec:participants}
Native talkers of Stockholm Swedish were recruited through word-of-mouth, flyers at Stockholm University Campus (see example flyer in SI \@ref(sec:recruitment)), and online channels (accindi.se). Participants were selected based on the following criteria: L1 talkers of Swedish, born and raised in the greater Stockholm area or its surroundings, 20-40 years old (mean age=`r mean(d.SwehVd$Age) %>% round(digits = 0)`; SD=`r sd(d.SwehVd$Age) %>% round(digits = 2)`). Four of the participants were bilingual from birth, the L1s of each talker are provided in the database. All participants were reimbursed with a voucher to the value of SEK 100 after completing the recordings.

## Recording procedure {#sec:vowelCorpRec}
Recording for the SwehVd database began in 2020 and is ongoing. The data were collected by the first author and Maryann Tan (Stockholm University). The hVd words were recorded together with another set of recordings targeting the production of Swedish word-initial stop voicing. Recording took place in a sound-attenuated room at the Multilingualism Laboratory, Department of Swedish Language and Multilingualism, Stockholm University.

Prior to recording, participants were informed about the study and given the possibility to ask questions before signing a consent form. They were then given instructions and seated at approximately 10 cm distance from an Audio Technica AT3035 microphone facing a computer screen. Words were presented one at a time, centered on screen, using PsychoPy software [@peirce2019]. Participants were instructed to read the words with their natural voice as they appeared on screen. Each talker read the same 21 target words, with 48 mono- and bi-syllabic filler words interspersed. Each target word was repeated 10 times and each filler word was repeated five times, generating a total of 450 productions per talker, 210 target productions and 240 filler productions. We generated two pseudo-randomized lists of the words, each list divided into four different blocks. Words were blocked across block lists and randomized within block lists, with the constraint that the same word would not appear more than twice in succession. Each participant was randomly assigned to one of the two lists. The pace of the presentation of the words was controlled by the experimenter, who was listening over Sennheiser HD215 headphones in the next room. A Yamaha MG102c mixing console with a built-in preamplifier was used together with a high-end ground isolator for preventing signal interference (Monacor FGA-40HQ). The speech was recorded at 44.1 kHz in Audacity [@teamaudacity2021]. Each long sound file was split into individual short sound files of one word each. The boundaries of each file were slightly trimmed and the files were labelled with the target word. All sound files from the same talker were concatenated into one long file before further processing.

The complete list of target hVd words is provided in Table \@ref(tab:word-list) in the SI. It consists of four real Swedish words, *hed*, *härd*, *hörd*, *hud* (English translations: *heath*, *hearth*, *heard*, and *skin*, respectively) and 17 phonotactically legal pseudowords. Following Swedish orthographical conventions for quantity, we used orthographic *hVdd* to elicit the short vowel allophone (e.g., *hudd* for [`r linguisticsdown::cond_cmpl("ɵ")`]) and orthographic *hVd* to elicit the long vowel allophone (e.g., *hud* for [`r linguisticsdown::cond_cmpl("ʉː")`]). This orthography reflects systematic phonological process of complementary quantity in Central Swedish [@riad2014]. In order to elicit the contextual allophones to [`r linguisticsdown::cond_cmpl("ɛ")`] and [`r linguisticsdown::cond_cmpl("ø")`], we added the supradental [`r linguisticsdown::cond_cmpl("ɖ")`] to elicit the long allophones (*härd*, *hörd*), and [`r linguisticsdown::cond_cmpl("r")`] to elicit the short allophones (*härr*, *hörr*). In a small-scale pilot preceding recordings, the expected transparency of the orthography for eliciting the long and short vowels was confirmed by three native talkers and one non-native talker of Swedish (these talkers did not participate in the study). However, *hodd* [`r linguisticsdown::cond_cmpl("ʊ")`] and *hod* [`r linguisticsdown::cond_cmpl("uː")`] sometimes elicited [`r linguisticsdown::cond_cmpl("ɔ")`].^[The difficulty for some native talkers to produce [`r linguisticsdown::cond_cmpl("ʊ")`] when reading *hodd* might be due to frequency effects. Forms with stressed [`r linguisticsdown::cond_cmpl("ʊ")`] are few in the Swedish language, and phonotactically similar words are most often pronounced as [`r linguisticsdown::cond_cmpl("ɔ")`] [see e.g., @riad2014].] We therefore decided to add instructions to the participants for these two words. When *hod* or *hodd* appeared on screen, a written guide indicating the target vowel appeared below the word in smaller font size: "hod som i hot", "hodd som i hosta", with *hot* and *hosta* being real Swedish words containing [`r linguisticsdown::cond_cmpl("uː")`] and [`r linguisticsdown::cond_cmpl("ʊ")`], respectively.^[English translations: "hod as in threat"(phonologically [`r linguisticsdown::cond_cmpl("uː")`]), "hodd as in cough"(phonologically [`r linguisticsdown::cond_cmpl("ʊ")`]).] Whenever the experimenter noticed that the pronunciations clearly targeted another vowel, recordings were stopped and participants were reminded to carefully read the guide.

The recordings were divided into five blocks: one practice block and four recording blocks, with breaks in between. The purpose of the practice block was threefold: to familiarize the participants with the recording procedure, to adjust the recording level, and if necessary, to further instruct the participant (e.g., if the participant used inappropriate or inconsistent intonation or stress pattern). Each recording block consisted of either 110 (N=2 blocks) or 120 (N=2 blocks) trials. The length of each block was approximately eight minutes, for a total of roughly 30 minutes recording time per talker. After the recording, participants filled out a language background questionnaire and received their reimbursement.

## Word and vowel segmentation {#sec:segmentation}
SweFA, a Swedish version of the Montreal Forced Aligner developed by @young2021, was used to obtain estimates for word and segment boundaries. The boundaries were manually corrected by the first author (an L1 talker of Central Swedish). Following standard segmentation protocol and guidelines in @engstrand2001, segment boundaries were adjusted using spectrogram, waveforms and pitch and intensity tracks. The boundaries between /h/ and the vowel were adjusted to align with clear appearance of an F1, and the boundaries between the vowel and the coda consonant were aligned to a simultaneous rapid cessation of most or all formants.

## Extraction of phonetic cues {#sec:cue-extraction}
We used the Burg algorithm in Praat [@boersma2022] to extract estimates of the first three formants (F1-F3) at five points of the vowel (20, 35, 50, 65, and 80 percent into the vowel). The following parameterization of the Burg algorithm was used:

 * Time step (s): 0.01
 * Max. number of formants: 5
 * Formant ceiling (Hz): 5500
 * Window length (s): 0.025
 * Pre-emphasis from (Hz): 50

In addition to F1-F3, we automatically extracted vowel duration and the fundamental frequency (F0) across the entire vowel.

```{r set-outlier-cutoff-again, include=F}
# What proportion of the most extreme values should be considered outliers?
# (if set to e.g., .05 that means that points with cumulative densities below
# .025 or above .975 are considered outliers)
outlier_probability_cutoff = .01
```

```{r spectrogram, echo=FALSE, fig.cap="Example of Praat textgrid with annotated segment boundaries and measurement points for the automatic extraction of F1-F3 formant frequencies.", fig.width=base.width*1.5, fig.height=base.height*1.5, out.width='40%', fig.align='center'}
knitr::include_graphics("spectrogram.png")
```

In order to correct for measurement errors in the automatic extraction of cues, we estimated the joint multivariate distribution along all five extracted cues (F0, F1, F2, F3, and vowel duration) for each unique combination of vowel and talker. This approach allowed us to detect outliers relative to the joint distribution of the five cues for that vowel and talker. Points outside of the `r 100 * (outlier_probability_cutoff/2)`th to `r 100 * (1 - outlier_probability_cutoff/2)`th quantile of the multivariate Gaussian distribution of each vowel were identified, checked for measurements errors, and corrected. For measurements of the first three formants, we first checked the segmentation boundaries in the Praat textgrid and then manually measured new formant values using visual approximation of time points and Praat's function *Formant: Formant listing* or manually reading off the spectrogram. Segmentation boundaries were also checked for the identified vowel duration outliers. For measurements of F0, we extracted new estimated F0s across the vowel, after changing the pitch range settings. Given that there were still instances of pitch halving after measurement correction, in order to be conservative, we also checked all F0 values below the point of intersection between the two halves. The database available via OSF reports these corrected values (since the recordings and annotation grids are also available via OSF, other researchers can easily derive alternative measurements).^[We note that outlier detection and correction was based on raw, rather than transformed/normalized, cue values. For the studies we report below, this potentially introduces a bias *against* normalization. If anything, the present study is thus likely to under-estimate the effects of normalization.]

The procedure of adding written guides to *hod* and *hodd* to facilitate vowel identification was mostly successful, however not for all talkers. Some talkers corrected themselves after one trial, others failed to produce the intended vowel altogether. The SwehVd database contains columns for both the targeted vowel category, and the vowel category that the talker actually produced (as annotated by the first author).

For the vast majority of talkers, *hädd* productions elicited the same vowel as *hedd* (see Figure \@ref(fig:hedd)). This confirms the common assumption that the short allophone to /e/ neutralizes with the short allophone to [`r linguisticsdown::cond_cmpl("ɛ")`] in Central Swedish.

(ref:hedd) The *hedd* and *hädd* words in the SwehVd vowel data in unnormalized F1-F2 space. Points show recordings of the *hedd* and *hädd* words ([`r linguisticsdown::cond_cmpl("ɛ")`]) by the 23 female native talkers in the database, averaged across the five measurement points within each vowel segment. Word labels indicate word means across talkers. Since *hädd* and *hedd* resulted in the same allophone, we exclude *hädd* from this and all other visualizations below. This facilitates comparison of, for example, densities across vowels (see diagonal of Figure \@ref(fig:swe-vowels-all-cues)).

```{r hedd, fig.width=base.width*1.5, fig.height=base.height*1.5, out.width='30%', fig.align='center', fig.cap="(ref:hedd)"}
d.SwehVd %>%
  filter(Transcribed_vowel == "targeted", Word %in% c("hedd", "hädd")) %>%
  # Get the geometric mean F1-F2 across the five time points
  group_by(Talker, Word, Token) %>%
  summarise(across(c(F1, F2), ~ geometric.mean(.x))) %>%
  ggplot(
    aes(
      x = F2,
      y = F1,
      color = Word)) +
  geom_point(alpha = .4) +
  stat_ellipse() +
  # Add between-talker mean
  geom_label(
    data =
      ~ .x %>%
      group_by(Word) %>%
      summarise(across(c(F1, F2), ~ geometric.mean(.x))),
    mapping = aes(
      colour = Word,
      label = Word),
    alpha = .8,
    size = 4,
    label.size = NA,
    label.padding = unit(.03, "cm")) +
  scale_x_reverse("F2 (in Hz)", position = "top", breaks = scales::breaks_pretty(6)) +
  scale_y_reverse("F1 (in Hz)", position = "right", breaks = scales::breaks_pretty(6)) +
  guides(color = "none") +
  theme(legend.position = "top")
```
```{r echo=FALSE}
# Keep code for reproducibility.
# d.SwehVd %<>%
#   mutate(Location = factor(Location))
# contrasts(d.SwehVd$Location) <- MASS::contr.sdif(5)
# m <- lmerTest::lmer(F2~ Location + (1 + Location | Talker), data = d.SwehVd %>% filter(category == "[iː]"))
# summary(m)
```

## Characterizing vowel productions in SwehVd {#sec:characterizing-swehvd}
Figure \@ref(fig:swe-vowels) visualizes the vowel data from the SwehVd in F1-F2 space. The plot highlights the density of the Swedish vowel space, the categories are numerous and closely located. Category overlap is especially large among some of the high vowels (e.g., [`r linguisticsdown::cond_cmpl("iː")`] & [`r linguisticsdown::cond_cmpl("yː")`]; [`r linguisticsdown::cond_cmpl("uː")`], [`r linguisticsdown::cond_cmpl("oː")`]  & [`r linguisticsdown::cond_cmpl("ʊ")`]). The contextually conditioned allophone [`r linguisticsdown::cond_cmpl("æ")`], almost completely overlaps with the long [`r linguisticsdown::cond_cmpl("ɛː")`], whereas the contextual allophones to [`r linguisticsdown::cond_cmpl("ø")`] are more separated. Not all contextual allophones are articulated lower (higher F1) in relation to their phonemes [compare e.g., @riad2014]. They are, however, all articulated further back (lower F2).

In line with Riad [-@riad2014, cf. Table \@ref(tab:swedish-vowels) above], the short vowels are overall more centralized and form a more condensed space, whereas the long vowels are more dispersed.^[[`r linguisticsdown::cond_cmpl("ɪ")`] and [`r linguisticsdown::cond_cmpl("ʏ")`] are, however, more fronted than their long counterparts, which does not replicate previous descriptions of Central Swedish. We elaborate on this result in other ongoing work [@persson2023].] Differences in formant patterns between long and short vowels have been found to be smallest for the allophones to [`r linguisticsdown::cond_cmpl("ɛ")`] and [`r linguisticsdown::cond_cmpl("ø")`], and largest for /u/ ([`r linguisticsdown::cond_cmpl("ʉː")`] and [`r linguisticsdown::cond_cmpl("ɵ")`]), and /a/ ([`r linguisticsdown::cond_cmpl("ɑː")`] and [`r linguisticsdown::cond_cmpl("a")`]) [e.g., @fant2001; @kuronen2000]. This pattern does not entirely replicate here. We do see large differences in F1-F2 for the allophones to /u/ and /a/, but also substantial differences between [`r linguisticsdown::cond_cmpl("ɛ")`] and [`r linguisticsdown::cond_cmpl("ɛː")`]. Formant differences are apparent even for some category distinctions for which quantity has been found to be the primary cue [as shown in perceptual studies, see e.g., @behne1997; @haddingkoch1964], ([`r linguisticsdown::cond_cmpl("ɛː")`] - [`r linguisticsdown::cond_cmpl("ɛ")`], [`r linguisticsdown::cond_cmpl("øː")`] - [`r linguisticsdown::cond_cmpl("ø")`], [`r linguisticsdown::cond_cmpl("iː")`] - [`r linguisticsdown::cond_cmpl("ɪ")`], and [`r linguisticsdown::cond_cmpl("oː")`] - [`r linguisticsdown::cond_cmpl("ɔ")`]).

Figure \@ref(fig:swe-vowels-all-cues) visualizes the vowel data from the SwehVd database for all pairwise combinations of five cues: F0, F1, F2, F3 and vowel duration. As is to be expected, vowels differing in quality are most separated in the F1-F2 plot, indicating the two cues most important for vowel category distinction. However, the F1-F3 and F3-F2 plots both display less overlap between the high vowels [`r linguisticsdown::cond_cmpl("iː")`], [`r linguisticsdown::cond_cmpl("yː")`] and [`r linguisticsdown::cond_cmpl("ʉː")`], comparing to when plotted along F1-F2. The increased separation of these categories along F3 in vowel production data could point to the importance of F3 for some category distinctions, as found in previous studies [see e.g., @fant1969; @fujimura1967; @kuronen2000, for [`r linguisticsdown::cond_cmpl("iː")`] and [`r linguisticsdown::cond_cmpl("yː")`] categorization].

Also as expected, duration is the primary cue that distinguishes vowel quantity: in the last column of Figure \@ref(fig:swe-vowels-all-cues), the short vowels cluster on the left, and the long vowels on the right. They are separable, but overlapping. Overall, the short vowels seem to display less variability in duration than the long vowels, a common pattern for measures with a lower bound. In addition to duration, F1-F3 can also carry information about vowels differing in quantity. This is evident, for example, for [`r linguisticsdown::cond_cmpl("iː")`] vs. [`r linguisticsdown::cond_cmpl("ɪ")`], [`r linguisticsdown::cond_cmpl("yː")`] vs. [`r linguisticsdown::cond_cmpl("ʏ")`], [`r linguisticsdown::cond_cmpl("ʉː")`] vs. [`r linguisticsdown::cond_cmpl("ɵ")`], [`r linguisticsdown::cond_cmpl("ɑː")`] vs. [`r linguisticsdown::cond_cmpl("a")`], [`r linguisticsdown::cond_cmpl("ɛː")`] vs. [`r linguisticsdown::cond_cmpl("ɛ")`] in F1-F2 space, and for [`r linguisticsdown::cond_cmpl("iː")`] vs. [`r linguisticsdown::cond_cmpl("ɪ")`], [`r linguisticsdown::cond_cmpl("yː")`] vs. [`r linguisticsdown::cond_cmpl("ʏ")`], [`r linguisticsdown::cond_cmpl("ʉː")`] vs. [`r linguisticsdown::cond_cmpl("ɵ")`] in F2-F3 space.

Finally, the densities along the diagonal of Figure \@ref(fig:swe-vowels-all-cues) suggest that F0 carries the least information about vowel identity, exhibiting the least between-category separation, followed by F3. This, too, is not surprising: while some accounts use F0 to _normalize_ F1 and F2 [e.g., @miller1989c; @Syrdal1986], F0 is not considered an important cue to vowel identity by itself. <!--AP: do we need to repeat the indirect influence argument here as well? And refs to @barreda2012a; @barreda2020a--> 

(ref:swe-vowels) The SwehVd vowel data in unnormalized F1-F2 space. Points show recordings of each of the 21 Central Swedish vowels by the 23 female native talkers in the database, averaged across the five measurement points within each vowel segment. Vowel labels indicate category means across talkers. Long vowels are boldfaced. Vowels that mismatched intended label are excluded (`r signif((d.SwehVd %>% filter(Transcribed_vowel != "targeted") %>% nrow() / d.SwehVd %>% nrow()) * 100)`% of all recordings). Note that the F1 and F2 axes are reversed. We follow this convention whenever plotting vowels in the F1-F2 space.

(ref:swe-vowels-all-cues) The SwehVd vowel data for all pairwise combinations of five cues: F0, F1, F2, F3, and vowel duration, with the marginal cue densities along the diagonal. Points show recordings of each of the 21 Central Swedish vowels by the 23 female native talkers in the database, averaged across all five measurement points. Vowel labels indicate category means across talkers. Long vowels are boldfaced. Ellipses show bivariate Gaussian 95% confidence interval of category means. Note that, unlike in Figure \@ref(fig:swe-vowels), axis directions are not reversed. Vowels that mismatched the intended label are excluded (`r signif((d.SwehVd %>% filter(Transcribed_vowel != "targeted") %>% nrow() / d.SwehVd %>% nrow()) * 100)`% of all recordings).

```{r swe-vowels, fig.width=base.width*3, fig.height=base.height*3, out.width='70%', fig.align='center', fig.cap="(ref:swe-vowels)"}
d.SwehVd %>%
  filter(Transcribed_vowel == "targeted", Word != "hädd") %>%
  # Get the geometric mean F1-F2 across the five time points
  group_by(Talker, category, Token, Quantity) %>%
  summarise(across(c(F0, F1, F2, F3, Duration), ~ geometric.mean(.x))) %>%
  ungroup() %>%
  ggplot(
    aes(
      x = F2,
      y = F1)) +
  geom_point(
    aes(
      colour = category,
      shape = Quantity),
    alpha = .4) +
  # Add between-talker mean
  geom_label(
    data =
      ~ .x %>%
      group_by(category, Quantity) %>%
      summarise(across(c(F0, F1, F2, F3, Duration), ~ geometric.mean(.x))),
    mapping = aes(
      colour = category,
      label = category,
      fontface = ifelse(category %in% levels.vowel.IPA.swe.long, 2, 1)),
    alpha = .8,
    size = 4,
    label.size = NA,
    label.padding = unit(.06, "cm")) +
  scale_colour_manual(name = "category", values = colors.vowel.swe) +
  scale_x_reverse("F2 (in Hz)", position = "top", breaks = scales::breaks_pretty(6)) +
  scale_y_reverse("F1 (in Hz)", position = "right", breaks = scales::breaks_pretty(6)) +
  guides(color = "none") + 
  myGplot.defaults(base_size+2)  +
  theme(legend.position = "top")
```

```{r swe-vowels-all-cues, fig.width=base.width*4.5, fig.height=base.height*4.5+.5, out.width = '100%', fig.cap="(ref:swe-vowels-all-cues)"}
p.matrix.cues <-
  d.SwehVd %>%
  filter(Transcribed_vowel == "targeted", Word != "hädd") %>%
  # Get the geometric mean across all five time points for the five cues
  group_by(Talker, category, Token, Quantity) %>%
  summarise(across(c(F0, F1, F2, F3, Duration), ~ geometric.mean(.x))) %>%
  ungroup() %>%
  ggplot(
    aes(
      x = .panel_x,
      y = .panel_y)) +
  geom_point(
    aes(
      colour = category,
      shape = Quantity),
    alpha = .1) +
  geom_label(
    data =
      ~ .x %>%
      group_by(category, Quantity) %>%
      summarise(across(c(F0, F1, F2, F3, Duration), ~ mean(.x))),
    mapping = aes(
      colour = category,
      label = category,
      fontface = ifelse(category %in% levels.vowel.IPA.swe.long, 2, 1)),
    alpha = .4, size = 3, label.size = NA) +
  geom_autodensity(
    mapping = aes(fill = category, linetype = Quantity),
    alpha = .3, position = "identity") +
  stat_ellipse(
    mapping = aes(
      colour = category,
      linetype = Quantity),
    alpha = .4) +
  geom_point(
    data =
      ~ .x %>%
      group_by(category, Quantity) %>%
      summarise(across(c(F0, F1, F2, F3, Duration), ~ mean(.x))),
    mapping = aes(
      colour = category,
      shape = Quantity),
    alpha = .8, size = 1) +
  scale_colour_manual(name = "category", values = colors.vowel.swe, aesthetics = c("colour", "fill")) +
  guides(color = "none", fill = "none", shape = guide_legend(override.aes = list(alpha = .4))) +
  facet_matrix(
    vars(F0, F1, F2, F3, Duration),
    layer.lower = c(1,2),
    layer.diag = 3,
    layer.upper = c(4, 5)) +
  myGplot.defaults(base_size+2) + 
  theme(legend.position = "top")

p.matrix.cues
```

# Study 1: Comparing the effects of normalization accounts on between- vs. within-category variability {#sec:studyI}
In Study 1, we follow previous research on the effects of different normalization accounts on category variability, by evaluating how effectively different normalization accounts reduce the within-category variability of Swedish vowels. We visualize the vowel space under different normalization accounts, and assess the effects on vowel category variability by calculating a measure of category separability. To anticipate one take-home point of Study 1, the results highlight important shortcomings of separability indices in evaluating normalization accounts.

```{r}
#Write table of previous studies
norm_accounts_eval <- tibble(
      "Language investigated" = c(
        "US English",
        "US English",
        "US English",
        "US English",
        "US English",
        "US English, Norwegian, Swedish, German, Danish, Dutch",
        "UK English",
        "UK English",
        "Russian"),

      "Article" = c(
               "Barreda & Nearey, 2018",
               "Clopper, 2009",
               "Hindle, 1978",
               "Kohn & Farrington, 2012",
               "Labov, 2010",
               "Disner, 1980",
               "Fabricius, Watt & Johnson, 2009",
               "Flynn & Foulkes, 2011",
               "Lobanov, 1971"),

  "Speech materials" = c(
                         "120,000 simulated languages (of 5 or 9 vowels) modeled on Hillenbrand et al.'s (1995) data (98 female/male child/adult talkers * 12 vowels)",
                         "2 female/male talkers from Ohio (1 token * 10 vowels)",
                         "Peterson & Barney's (1952) database; 19 female/male talkers from Philadelphia + 60 telephone informants (minimum 3 tokens per category; analysis focus on /ay/)",
                         "Longitudinal data from 10 female/male African American talkers from North Carolina (approx. 10 tokens * 10 vowels * 5 ages)",
                         "Peterson & Barney's (1952) database; Philadelphia/Linguistic Change and Variation project (120 female/male talkers, stratified for age, sociolinguistic factors)",  
                         "Differing number of tokens, vowels, and phonetic contexts across the six languages",
                         "20 old/young female/male talkers of Received pronunciation (11 vowels); 6 old/young female/male talkers of Aberdeen English (8 vowels in different phonetic contexts)",
                         "20 old/young female/male Nottingham talkers (mean 180 recordings per talker; categories not reported)",
                         "5 female/male talkers (9 vowels in different phonetic contexts)"),

  "Normalization accounts" = c(
    "Nearey2, Lobanov, log-mean in linear regression framework",                                     
    "Bladon et al.'s scale factor of 1 Bark (1994), Syrdal & Gopal, Nordström & Lindblom, Nearey1, Nearey2, Watt & Fabricius, Gerstman, Lobanov, Miller",
    "Nearey2, Nordström-Lindblom, Sankoff-Shorrock-McKay",
    "Lobanov, Gerstman, Nearey1, Nordström & Lindblom, Syrdal & Gopal/Thomas, Watt & Fabricius",
    "Nearey2, Nordström-Lindblom, Sankoff-Shorrock-McKay ",
    "Gerstman, Lobanov, Nearey2, Harshman's PARAFAC model",
    "Watt & Fabricius, Lobanov, Nearey1",
    "log-transformation (base 10), log-transformation (natural), Mel, ERB, Bark (*2 gender-specific versions), Syrdal & Gopal, Nordström (*2 gender-specific versions), LCE, Gerstman, Lobanov, Watt & Fabricius (* 4 versions), lettER, Nearey (*4 versions)",
    "linear compression or expansion (Fant, 1960), Gerstman, Lobanov"),

  "Approach" = c(
    "distance between means (Eucledian distance)",                    
    "variance reduction (visual inspection)",
    "distance between means, variance reduction (regression)",
    "variance reduction (regression)",
    "distance between means (F-statistics)",
    "variance reduction (visual inspection)",
    "variance reduction (SCV in talker-means)",
    "variance reduction (SCV in talker-means)",
    "distance between means"),

  "Best two performing" = c(
    "log-mean in linear regression framework (1), Nearey2 (2)",
    "Nearey, Watt & Fabricius, Gerstman, Lobanov (no order)",
                            "Sankoff (1)",
                            "Lobanov (1), Gerstman, Watt & Fabricius (2)",
                            "Sankoff (1), Nearey2 (2)",
                            "Nearey2 (1), Lobanov (2)",
                            "Lobanov (1), Watt & Fabricius (2)",
                            "Gerstman (1), LCE (2)",
                            "Lobanov (1), Gerstman (2)"))
```


```{r norm-evaluation-variability, results='asis'}
norm_accounts_eval %>%
  kable(
    format = "latex",
    booktabs = TRUE,
    caption = "Previous studies comparing the effectiveness of normalization accounts in reducing within-category cue variability") %>%
  kable_styling(font_size = 7) %>%
  column_spec(1:2, width = "2cm") %>%
  column_spec(3, width = "5.5cm") %>%
  column_spec(4, width = "6cm") %>%
  column_spec(5:6, width = "2.5cm") %>%
  landscape() %>%
  collapse_rows()
```

Table \@ref(tab:norm-evaluation-variability) lists previous studies that have compared normalization accounts in terms of their effectiveness in reducing inter-talker variability. These studies varied in the specific metrics they employed to assess the effects of normalization, the languages they studied, and the conclusions they arrived at. Two generalizations emerge from Table \@ref(tab:norm-evaluation-variability). First, transformation to a perceptual scale alone does not seem to be sufficient to reduce inter-talker variability [see also @adank2004; @carpenter1993; @clopper2009; @escudero2007; @Flynn2011; @kohn2012a]. Second, normalization accounts that include centering and/or standardizing seem to perform best in reducing inter-talker variability [see e.g. @barreda2018a; @disner1980; @fabricius2009; @kohn2012a; @labov2010; @lobanov1971]. When Lobanov and Gerstman normalization---both involving standardizing---were included in a study, they often rank among the top two performing accounts. Of note, Nearey normalization [@nearey1978] seems to perform well even though it does not involve the computationally more complex operation of standardizing. This suggests that simple centering of formants relative to the talker's mean *might* be sufficient to achieve significant variance reduction [but see @disner1980 for Swedish, which is revisited in this study].<!-- Commented out for now as it doesn't seem critical. ^[Some studies have further investigated the extent to which different normalization accounts remove socially-relevant variance along with the intended removal of physiologically-caused variance [e.g., @adank2004; @disner1980; @hindle1978; @labov2010]. Removal of socially-relevant variance has been argued to be problematic for two separate reasons. First, for *researchers* who employ normalization as part of their data analysis, it can make it difficult to investigate the effects of social variables on pronunciation. Second, as a theory of how *listeners* overcome the lack of invariance in the speech signal, it has been argued to conflict with the finding that listeners infer social group membership from speech signal [@REFS]. Only this latter concern is of relevant for the present study, and---as others have pointed out---normalization does not necessarily mean that the raw input to normalization is discarded [@sumner2014; @OTHERS]. We thus do not further discuss this aspect.]  -->

## Methods {#sec:methodsI}

```{r}
# Make temp exclusions file for identifying no of talkers to exclude
d.SwehVd.exclusions <-
  d.SwehVd %>%
  select(c(Talker, category, Transcribed_vowel, Token)) %>%
  distinct() %>%
  group_by(Talker, category) %>%
  summarise(
    N_tokens_per_category = n_distinct(Token),
    Transcribed_vowel = Transcribed_vowel) %>%
  filter(Transcribed_vowel != "targeted") %>%
  group_by(Talker, category, N_tokens_per_category) %>%
  summarise(
    N_unidentifiable_vowels = length(Transcribed_vowel)) %>%
  group_by(Talker, category) %>%
  mutate(
    exclude_Talker = case_when(N_tokens_per_category < 6 & N_unidentifiable_vowels >= 1 ~ "TRUE",
                               N_tokens_per_category >= 10 & N_unidentifiable_vowels > 6 ~ "TRUE",
                               TRUE ~ "FALSE")) %>%
  filter(exclude_Talker == TRUE)
```

```{r filter-data-for-study}
set.seed(234215432)
# Exclude talkers that failed to produce *hodd* altogether + the mispronounced words by remaining talkers. This approach results in exclusion of an additional two talkers, given that they only did five recordings for each vowel. Also exclude measurements at 20 and 80% into the vowel, and all /hädd/ words since they are a duplicate of "[ɛ]" - the short allophone to /e/ neutralizes with the short allophone to /ɛ/. Also exclude all NAs in F0s.
d.SwehVd.forStudy <-
  d.SwehVd %>%
  filter(!Talker %in% d.SwehVd.exclusions$Talker, Transcribed_vowel == "targeted", Location %in% c(35, 50, 65), Word != "hädd", !is.na(F0)) %>%
  select(-Transcribed_vowel) %>%
  # Get the geometric mean across the three time points for the five cues
  group_by(Talker, Age, L1, category, Word, Token, Trial, Quantity) %>%
  summarise(across(c(F0, F1, F2, F3, Duration), ~ geometric.mean(.x))) %>%
  ungroup()
```

```{r createCV}
# This creates K = 5 copies of the data, each distinguished by crossvalidation_group
# Each copy consists of K = 5 bins each, K - 1 = 4 of which are of fold_type "training"
# and 1 of which is of fold_type "test".
d.SwehVd.forStudy %<>%
# Split data into five equally sized bins  
  split_data() %>%
  #add groupID, assign bins to training or testing depending on groupID
  crossing(crossvalidation_group = 1:5) %>%
  mutate(
    fold_type = case_when(crossvalidation_group == 1 & fold != 5 ~ "training",
                     crossvalidation_group == 2 & fold != 1 ~ "training",
                     crossvalidation_group == 3 & fold != 2 ~ "training",
                     crossvalidation_group == 4 & fold != 3 ~ "training",
                     crossvalidation_group == 5 & fold != 4 ~ "training"),
    fold_type = replace_na(fold_type, "test")) %>%
  arrange(crossvalidation_group)
```

### Speech materials {#sec:speechMaterialsI}
We use the SwehVd database with some exclusions. Since we are interested in assessing the effects of normalization, we excluded any productions on which the talker did not produce the targeted vowel. We then excluded all talkers (N = `r n_distinct(d.SwehVd.exclusions$Talker)`) with fewer than 5 remaining recordings for at least one of the vowels. Five of these talkers rarely ever produced the targeted [`r linguisticsdown::cond_cmpl("ʊ")`] vowel despite our recording instructions (see Section \@ref(sec:cue-extraction)). Instead, they often mispronounced the vowel. This left data from `r n_distinct(d.SwehVd$Talker) - n_distinct(d.SwehVd.exclusions$Talker)` female native talkers, with on average `r d.SwehVd.forStudy %>% group_by(category) %>% tally() %>% summarise(x = mean(n)) %>% pull() %>% round(digits = 0)` (se= `r d.SwehVd.forStudy %>% group_by(category) %>% tally() %>% summarise(x = se(n)) %>% pull() %>% round(digits = 1)`) tokens per vowel (range = `r d.SwehVd.forStudy %>% group_by(category) %>% tally() %>% summarise(x = min(n)) %>% pull() %>% round(digits = 0)` to `r d.SwehVd.forStudy %>% group_by(category) %>% tally() %>% summarise(x = max(n)) %>% pull() %>% round(digits = 0)`), for a total of `r nrow(d.SwehVd.forStudy)` observations.

Since our goal is to obtain a reliable estimate of the formant values during the steady state of the vowel, we use only the three formant measurements extracted from the middle of the vowel (at 35%, 50%, and 65% into the vowel).^[An alternative approach that might better target the same point of the vowel, given that the long and short vowels systematically differ in duration, would be to extract formants at e.g., 20 ms after onset and 20 ms before offset of the vowel.]<!--AP: should this footnote be moved to the SwehVd section instead, where time points are first mentioned?-->

We also exclude all *hädd* productions, as they elicited the same vowel as *hedd* (see Section \@ref(sec:cue-extraction)). This way, we have about equally many tokens from all vowels, simplifying the cross-validation procedure presented below and facilitating visual comparisons across vowels in our figures.

### Cues included in the normalization {#sec:cues}
We compare the effect of different normalization accounts on the variability of Swedish vowels under three different assumptions about the relevant cues. The first comparison follows most previous research and focuses on the two primary cues to vowel perception, F1 and F2. The second comparison considers F3 in addition to F1 and F2, following @adank2004, @barreda2018a, @nearey1989 and @syrda1985.^[Some of these studies additionally included F0 [@adank2004; @nearey1989; @syrda1985]. However, since F0 is a cue that can display substantial cross-talker variability without directly contributing much information to vowel categorization (recall Figure \@ref(fig:swe-vowels-all-cues)), its inclusion can reduce the informativeness of the separability index. We therefore decided to add only F3 to F1-F2 in the second evaluation.]<!--AP: do we need to repeat the indirect influence argument here as well? And refs to @barreda2012a; @barreda2020a--> Finally, the third comparison includes F0 and duration in addition to F1-F3. Since @Syrdal1986's bark-difference model only considers normalization along two dimensions---height, implemented as F1-F0, and backness, implemented as F2-F1---this account will only be included in the first comparison. Furthermore, given that C-CuRE is the only account that applies to any type of cue, we will consider duration as centered to each talker's mean (for the C-CuRE accounts), or as raw input (in ms; for all other accounts). To our knowledge, duration has not been considered in previous studies on normalization, presumably because the present study is the first to evaluate normalization accounts against a vowel system with a systematic quantity distinction (long vs. short vowels). We evaluate the effect on variability both separately for long and short vowels, and on all 21 vowels together.

### Separability index {#sec:separabilityIndex}
Previous studies have used different measures to assess the relative success of a normalization procedure in reducing inter-talker variability [see Table \@ref(tab:norm-evaluation-variability) and @nearey1989 for an overview on classification accounts]. This includes assessing the reduction in variance or distance between means by visual inspection [e.g., @clopper2009; @disner1980; @hindle1978], or by calculating the reduction in within-category variance across talkers [e.g., @disner1980; @fabricius2009; @Flynn2011; @hindle1978], or comparing the degree of separation between category means for unnormalized and normalized data, i.e., an F-ratio [e.g., @labov2010].

We will assess how distinguishable vowels become under different normalization accounts by calculating a separability index, as described in Equation \@ref(eq:separability-index). Following some previous studies [e.g., @labov2010], this separability index is essentially an F statistics, where the F statistics is the ratio of the within- and between-category variances:

\begin{equation}\label{eq:separability-index}
\begin{split}
 separability\ index &= \frac{between\ category\ MS}{within\ category\ MS}\\
 &= \frac{\sum\limits_{c=1,\ldots,K}(N_{c}-1)}{K-1}\frac{\sum\limits_{c=1,\ldots,K}(\bar{x}_{c}-\bar{x})^{2}}{\sum\limits_{c=1,\ldots,K} \sum\limits_{i=1,\ldots,N_{c}}(x_{i,c}-\bar{x}_{c})^{2}}
\end{split}
\end{equation}

where $K$ is the number of categories, $N_c$ is the number of observations for category $c$, $x_{i,c}$ is the cue vector (for all cues considered in the calculation of the separability index) for observation $i$ of category $c$, $\bar{x}_c$ is the cue mean vector for category $c$, and $\bar{x}$ is the overall cue mean vector. We calculated this separability index separately for each combination of normalization account, cues, and training-test fold, as described next.

### Guarding against over-fitting: cross-validation {#sec:folds}
As shown in Table \@ref(tab:norm-accounts), many of the normalization accounts involve parameters that are set based on the data [e.g., @gerstman1968; @lobanov1971; @mcmurray-jongman2011; @miller1989c; @nearey1978]. This raises the question of how much these parameters can be affected by outliers, or other issues such as over-fitting to the sample. Unlike previous work, we thus use 5-fold cross-validation to obtain 5 separate estimates of the separability index for each combination of normalization procedure and cues. Specifically, we randomly split the data for each unique combination of talker and vowel into 5 even parts (folds). On each of the five folds, we then fit the normalization parameters based on four of the folds (the training data) and evaluated the effects of the normalization on the fifth fold (the test data). This resulted in five separability indices for each combination of normalization procedure and cues.

## Results {#sec:resultsI}

### Visualizing the distribution of vowel productions {#sec:normVowelSpace}
Figures \@ref(fig:swe-vowels-normalized-long) and \@ref(fig:swe-vowels-normalized-short) visualize the Swedish vowels in the test data, after applying the 15 different scale-transformations and normalization accounts for a visual inspection. For this purpose, we focus on F1 and F2 only. The SI includes similar pairwise correlation plots of all cues for all different normalization accounts we compare (see Section \@ref(sec:correlation-matrices) in SI).

Visual inspection suggests a few initial observations. The most striking difference is perhaps between intrinsic normalization accounts [@Syrdal1986; @miller1989c] and all other approaches, though it is not immediately visually obvious which type of approach achieves better separability. Second, transforming the vowels to a different perceptual scale does not seem to affect the vowel distributions much, besides a minor decrease in category variance for some of the vowels. Some transformations bring the vowel categories closer together, towards the center of the vowel space, e.g., ERB and semitones. Third, centering formants to each talkers' mean [@mcmurray-jongman2011; @nearey1978] reduces some of the category variance, and as a result, increases the category separability. Transforming the vowel data into different scales prior to centering also seems to further improve separability (compare e.g., C-CuRE (Hz) and C-CuRE (semitones)). Overall, the top two performing accounts across the long and short vowels appear to be @lobanov1971 and @nearey1978.

Notably, even for the best performing accounts, there is still considerable category overlap. This involves some of the high long vowels, and some of the mid-center short vowels. This highlights the need to more systematically quantify the effects of normalization, as we do next for category separability and then in more depth in Study 2.

```{r norm-data}
#Remove temp file
rm(d.SwehVd.exclusions)

# Normalize all data based on the respective training of each cross-validation group
d.SwehVd.forStudy %<>%
  group_by(crossvalidation_group) %>%
  # Get transformations, apply normalizations (both classic formants one and C-CuRE)
  group_map(
    .f = ~ apply_all_transformations_and_normalization(data = .x),
    .keep = T
  ) %>%
  reduce(bind_rows) %>%
  ungroup()
```

(ref:swe-vowels-normalized-long) The Central Swedish long vowels in the unnormalized and normalized test data used in Study 1. Points show all tokens of each of the 11 Central Swedish long vowels included in the test data in F1-F2 space. Unnormalized vowels and vowels transformed to different perceptual scales (**grey**), vowels normalized by intrinsic accounts (**yellow**), vowels in all scale-transformations further normalized to C-CuRE and other centering accounts (**blue**), and finally, vowels normalized by standardizing accounts (**purple**).

(ref:swe-vowels-normalized-short) The Central Swedish short vowels in the unnormalized and normalized test data used in Study 1. Points show all tokens of each of the 10 Central Swedish short vowels included in the test data in F1-F2 space. Unnormalized vowels and vowels transformed to different perceptual scales (**grey**), vowels normalized by intrinsic accounts (**yellow**), vowels in all scale-transformations further normalized to C-CuRE and other centering accounts (**blue**), and finally, vowels normalized by standardizing accounts (**purple**).

```{r echo=FALSE}
# Pivot data to long format for plotting and calculation of separability index
d.SwehVd.forStudy.long <-
  d.SwehVd.forStudy %>%
  pivot_longer(
    cols = starts_with("F", ignore.case = FALSE),
    names_to = c("Cue", "Normalization.Scale", "Normalization.Type"),
    names_sep = "_",
    values_to = "Cue.Value") %>%
  pivot_wider(
    names_from = "Cue",
    values_from = "Cue.Value") %>%
  # Mutate both
  mutate(
    Normalization.Type = paste(Normalization.Scale, Normalization.Type, sep = "_")) %>%
  mutate(
    Normalization.Type = factor(plyr::mapvalues(Normalization.Type, levels.normalization, labels.normalization), levels = labels.normalization, ordered = T),
    Duration = ifelse(Normalization.Type %in% c("C-CuRE (Hz)", "C-CuRE (Mel)", "C-CuRE (ERB)", "C-CuRE (Bark)", "C-CuRE (semitones)"), Duration_CCuRE, Duration)) %>%
   select(-c(Duration_CCuRE, Normalization.Scale)) %>%
   relocate(Talker, L1, Age, Normalization.Type, crossvalidation_group, fold_type, fold, category, Quantity, Token)

#Attempt with grob.element
element_textbox_highlight <- function(
    ...,
    hi.labels = NULL, hi.fill = NULL,
    hi.col = NULL, hi.box.col = NULL,
    hi.labels2 = NULL, hi.fill2 = NULL,
    hi.col2 = NULL, hi.box.col2 = NULL,
    hi.labels3 = NULL, hi.fill3 = NULL,
    hi.col3 = NULL, hi.box.col3 = NULL
) {
  structure(
    c(ggtext::element_textbox(...),
      list(hi.labels = hi.labels, hi.fill = hi.fill, hi.col = hi.col, hi.box.col = hi.box.col,
           hi.labels2 = hi.labels2, hi.fill2 = hi.fill2, hi.col2 = hi.col2, hi.box.col2 = hi.box.col2,
           hi.labels3 = hi.labels3, hi.fill3 = hi.fill3, hi.col3 = hi.col3, hi.box.col3 = hi.box.col3)),
    class = c("element_textbox_highlight", "element_textbox", "element_text", "element",
              "element_textbox_highlight", "element_textbox", "element_text", "element",
              "element_textbox_highlight", "element_textbox", "element_text", "element"))
}

element_grob.element_textbox_highlight <- function(element, label = "", ...) {
  if (label %in% element$hi.labels) {
    element$fill <- element$hi.fill %||% element$fill
    element$colour <- element$hi.col %||% element$colour
    element$box.colour <- element$hi.box.col %||% element$box.colour
  }
  if (label %in% element$hi.labels2) {
    element$fill <- element$hi.fill2 %||% element$fill
    element$colour <- element$hi.col2 %||% element$colour
    element$box.colour <- element$hi.box.col2 %||% element$box.colour
  }
  if (label %in% element$hi.labels3) {
    element$fill <- element$hi.fill3 %||% element$fill
    element$colour <- element$hi.col3 %||% element$colour
    element$box.colour <- element$hi.box.col3 %||% element$box.colour
  }
  NextMethod()
}

# Plot vowel data in all normalization formats
p.vowels.norm.long <-
  d.SwehVd.forStudy.long %>%
  # filter down to test folds since that's what we later evaluate SI and IOs for + the best performing SyrdalGopal
  filter(fold_type == "test", Quantity == "long", Normalization.Type != "SyrdalGopal2 (Bark)") %>%
  ggplot(
    aes(
      x = F2,
      y = F1)) +
  geom_point(
    aes(
      colour = category,
      shape = Quantity),
    alpha = 0.4,
    size = .7) +
  scale_colour_manual(name = "category", values = colors.vowel.swe) +
  scale_x_reverse("F2", position = "top", scales::pretty_breaks(n = 3)) +
  scale_y_reverse("F1", position = "right", scales::pretty_breaks(n = 3)) +
  guides(alpha = "none", color = "none", shape = "none") +
  facet_wrap(~ factor(Normalization.Type, levels = labels.normalization), scales = "free", ncol = 5) +
  theme(
    axis.title.y = element_blank()) +
    cowplot::theme_half_open(12) +
    cowplot::background_grid() +
    theme(
      strip.background = element_blank(),
      strip.text = element_textbox_highlight(
        size = 8,
        color = "black", fill = "#C9C0BB", box.color = "#C9C0BB",
        halign = 0.5, linetype = 1, r = unit(3, "pt"),
        #width = unit(1, "npc"),
        padding = margin(2, 3, 2, 3), margin = margin(3, 3, 3, 3),
        #margin = margin(0.6, 0.5, 0.5, 0.3),
        # this is new relative to element_textbox():
        # first named set
        hi.labels = c("SyrdalGopal (Bark)", "Miller (log)"),
        hi.fill = "#E6BE8A", hi.col = "black", hi.box.col = "#E6BE8A",
        # add second set
        hi.labels2 = c("C-CuRE (Hz)", "C-CuRE (Mel)", "C-CuRE (Bark)", "C-CuRE (ERB)", "C-CuRE (semitones)", "Nearey1 (log)", "Nearey2 (log)"),
        hi.fill2 = "#ABCDEF", hi.col2 = "black", hi.box.col2 = "#ABCDEF",
        # add third set
        hi.labels3 = c("Gerstman (Hz)", "Lobanov (Hz)"),
        hi.fill3 = "#DDADAF", hi.col3 = "black", hi.box.col3 = "#DDADAF"),
      axis.text.x = element_text(size=8, vjust=1),
      axis.text.y = element_text(size=8, hjust=1, vjust=.5),
      axis.title.x = element_text(size=8, vjust=0, hjust=0.5, face = "bold"),
      axis.title.y = element_text(size=8, hjust= 0.5, vjust=0.5, face = "bold"),
      legend.title = element_text(size=8, face = "bold", hjust= 0),
      legend.text = element_text(size=8),
      strip.placement = "outside",
      aspect.ratio = 1,
      panel.grid.major = element_blank())
```

\begin{landscape}

```{r swe-vowels-normalized-long, fig.width=base.width * 4, fig.height=base.height * 3, fig.align='center', fig.cap="(ref:swe-vowels-normalized-long)"}
p.vowels.norm.long
```

\end{landscape}

```{r echo=FALSE}
# Plot vowel data in all normalization formats
p.vowels.norm.short <- p.vowels.norm.long %+%
  (d.SwehVd.forStudy.long %>%
     #Filter down to test data, and to the best performing implementation of Syrdal&Gopal
     filter(fold_type == "test", Quantity == "short", Normalization.Type != "SyrdalGopal2 (Bark)")) +
  geom_point(aes(color = category),
             shape = 17,
             alpha = .4,
             size = .7)
```

\begin{landscape}
```{r swe-vowels-normalized-short, fig.width=base.width * 4, fig.height=base.height * 3, fig.align='center', fig.cap="(ref:swe-vowels-normalized-short)"}
p.vowels.norm.short
```

\end{landscape}

### The effect of normalization accounts on the variability of Central Swedish vowels {#sec:normVariability}
In order to assess the effects of normalization accounts on category separability, we calculate a separability index under different assumptions about the relevant cues and the size of the vowel space (the long and short vowels separately, or the entire space). Before we evaluate how category separability is affected by normalization in F1-F2, F1-F3, and F0-F3 and duration space, we look at how the normalization accounts affect the separability of vowels along each cue separately (Figure \@ref(fig:separability-by-cue)). As we show below, this is helpful in understanding the subsequently presented results for combinations of cues.

```{r}
cues <- c("F0", "F1", "F2", "F3", "Duration")

# Calculate a separability index for all categories and all normalization accounts.
# First get within-category means
d.SwehVd.forStudy.long.within_category_MS <-
  d.SwehVd.forStudy.long %>%
  # Reduce to test fold of each crossvalidation group since that's what we want to know SI for
  filter(fold_type == "test") %>%
  # Get within category MS and pseudo-MS
  group_by(Normalization.Type, category, crossvalidation_group, fold_type, fold) %>%
  summarise(
    # First obtain df and SS for each cues
    across(
      .cols = cues,
      .fns = list(
        "within_df" = ~ if (sum(!is.na(.x)) == 0) { NA } else { sum(!is.na(.x)) - 1}, # Set cases with 0 DFs to NA (happens when cue is not defined for a normalization type)
        "category_mean" = ~ mean(.x, na.rm = T)),
      .names = "{.fn}_{.col}"),
    across(
      .cols = cues,
      .fns = list("within_SS" = ~ if (sum(!is.na(.x)) == 0) { NA } else { sum((.x - get(glue("category_mean_{cur_column()}")))^2, na.rm = T) }),
      .names = "{.fn}_{.col}"),
    # Now get all the measures *across* cues
    within_df_F1F2 = pmin(within_df_F1, within_df_F2),
    within_df_F1F3 = pmin(within_df_F1, within_df_F2, within_df_F3),
    within_df_F0F3 = pmin(within_df_F0, within_df_F1, within_df_F2, within_df_F3),
    within_df_all = pmin(within_df_F0, within_df_F1, within_df_F2, within_df_F3, within_df_Duration),
    within_SS_F1F2 = within_SS_F1 + within_SS_F2,
    within_SS_F1F3 = within_SS_F1 + within_SS_F2 + within_SS_F3,
    within_SS_F0F3 = within_SS_F0 + within_SS_F1 + within_SS_F2 + within_SS_F3,
    within_SS_all = within_SS_F0 + within_SS_F1 + within_SS_F2 + within_SS_F3 + within_SS_Duration,
    # Get within-category MS
    across(
      .cols = paste0("within_SS_", c(cues, "F1F2", "F1F3", "all")),
      .fns = list("pseudo_within_MS" = ~ .x / get(glue(gsub("within_SS_", "within_df_", cur_column())))),
      .names = "{.fn}_{.col}")) %>%
  rename_with(~ gsub("_within_SS", "", .x))
```

```{r}
get_SI <-
  . %>%
  group_by(Normalization.Type, crossvalidation_group) %>%
  summarise(
    across(
      .cols = paste0("within_SS_", c(cues, "F1F2", "F1F3", "all")),
      .fns = list("within_MS" = ~ sum(.x, na.rm = T) / sum(get(glue(gsub("within_SS_", "within_df_", cur_column()))), na.rm = T)),
      .names = "{.fn}_{.col}")) %>%
  rename_with(~ gsub("_within_SS", "", .x)) %>%
  left_join(
    d.SwehVd.forStudy.long %>%
      # Get overall mean within each normalization approach
      group_by(Normalization.Type, crossvalidation_group) %>%
      mutate(
        across(
          .cols = cues,
          .fns = list("overall_mean" = ~ mean(.x, na.rm = T)),
          .names = "{.fn}_{.col}")) %>%
      group_by(Normalization.Type, category, crossvalidation_group) %>%
      # Get category means and carry through overall mean
      summarise(
        across(
          .cols = paste0("overall_mean_", cues),
          first),
        across(
          .cols = cues,
          .fns = list("category_mean" = ~ mean(.x, na.rm = T)),
          .names = "{.fn}_{.col}")) %>%
      # Get between-category SS and MS
      group_by(Normalization.Type, crossvalidation_group) %>%
      summarise(
        # First obtain df and SS for each cues
        across(
          .cols = paste0("category_mean_", cues),
          .fns = list(
            "between_df" = ~ if (sum(!is.na(.x)) == 0) { NA } else { sum(!is.na(.x)) - 1},  # Set cases with 0 DFs to NA (happens when cue is not defined for a normalization type)
            "between_SS" = ~ if (sum(!is.na(.x)) == 0) { NA } else { sum((.x - get(glue(gsub("category_mean", "overall_mean", cur_column()))))^2, na.rm = T) }),
          .names = "{.fn}_{.col}"),
        # Now get all the measures *across* cues
        between_df_category_mean_F1F2 = pmin(between_df_category_mean_F1, between_df_category_mean_F2),
        between_df_category_mean_F1F3 = pmin(between_df_category_mean_F1, between_df_category_mean_F2, between_df_category_mean_F3),
        between_df_category_mean_F0F3 = pmin(between_df_category_mean_F0, between_df_category_mean_F1, between_df_category_mean_F2, between_df_category_mean_F3),
        between_df_category_mean_all = pmin(between_df_category_mean_F0, between_df_category_mean_F1, between_df_category_mean_F2, between_df_category_mean_F3, between_df_category_mean_Duration),
        between_SS_category_mean_F1F2 = between_SS_category_mean_F1 + between_SS_category_mean_F2,
        between_SS_category_mean_F1F3 = between_SS_category_mean_F1 + between_SS_category_mean_F2 + between_SS_category_mean_F3,
        between_SS_category_mean_F0F3 = between_SS_category_mean_F0 + between_SS_category_mean_F1 + between_SS_category_mean_F2 + between_SS_category_mean_F3,
        between_SS_category_mean_all = between_SS_category_mean_F0 + between_SS_category_mean_F1 + between_SS_category_mean_F2 + between_SS_category_mean_F3 + between_SS_category_mean_Duration,
        # Get between-category MS
        across(
          .cols = paste0("between_SS_category_mean_", c(cues, "F1F2", "F1F3", "all")),
          .fns = list("between_MS" = ~ sum(.x / get(glue(gsub("between_SS", "between_df", cur_column()))))),
          .names = "{.fn}_{.col}")) %>%
      rename_with(~ gsub("(_between_SS)?_category_mean", "", .x)),
        by = c("Normalization.Type", "crossvalidation_group")) %>%
  # Now get the separability index
  group_by(Normalization.Type, crossvalidation_group) %>%
  mutate(
    across(
      .cols = paste0("between_MS_", c(cues, "F1F2", "F1F3", "all")),
      .fns = list("SI" = ~ sum(.x / get(glue(gsub("between_", "within_", cur_column()))))),
      .names = "{.fn}_{.col}")) %>%
  rename_with(~ gsub("_between_MS", "", .x)) %>%
  mutate_if(is.numeric, round, digits = 4)

d.SwehVd.forStudy.SI <- rbind(
  d.SwehVd.forStudy.long.within_category_MS %>%
    filter(category %in% levels.vowel.IPA.swe.long) %>%
    get_SI() %>%
    mutate(
      Quantity = "long vowels"),
  d.SwehVd.forStudy.long.within_category_MS %>%
    filter(category %in% levels.vowel.IPA.swe.short) %>%
    get_SI() %>%
    mutate(
      Quantity = "short vowels"),
  d.SwehVd.forStudy.long.within_category_MS %>%
    get_SI() %>%
    mutate(
      Quantity = "all vowels"))

d.SwehVd.forStudy.SI.long <-
  d.SwehVd.forStudy.SI %>%
  # include all separate SIs
  select(c(Normalization.Type, crossvalidation_group, Quantity, SI_F1F2, SI_F1F3, SI_Duration, SI_F0, SI_F1, SI_F2, SI_F3, SI_all)) %>%
  pivot_longer(
    cols = starts_with("SI_", ignore.case = FALSE),
    names_to = c("SI", "Cues"),
    names_sep = "_",
    values_to = "Cue.Value") %>%
  pivot_wider(
    names_from = "SI",
    values_from = "Cue.Value")
```

```{r}
plot_separability <- function(data) {
  data %>%
    ggplot(
    aes(x = Normalization.Type,
        y = SI,
        color = Normalization.Type)) +
  stat_summary(
     fun.data = mean_cl_boot,
     geom = "linerange") +
  stat_summary(
    fun.y = mean,
    geom = "label",
    aes(label = signif(..y..,2),
        x = as.integer(Normalization.Type)),
    size = 2.7, label.size = 0, label.padding = unit(0.05, "lines")) +
  scale_colour_manual(
    labels = labels.normalization.1SG,
    values = colors.all.procedures.1SG) +
  scale_y_continuous("Separability index (F-value)") +
  myGplot.defaults(base_size + 2) +
  theme(
    axis.text.x = ggtext::element_markdown(angle = 60, vjust = 1, hjust=1, colour = colors.all.procedures.1SG),
    axis.title.x = element_blank(),
    aspect.ratio = 3/6) +
  guides(color = "none")
}

p.separability.by_cue <- plot_separability(d.SwehVd.forStudy.SI.long %>%
                                             #Filter down to best performing implementation of Syrdal&Gopal
                                             filter(Cues %in% c("F0", "F1", "F2", "F3", "Duration"), Normalization.Type != "SyrdalGopal2 (Bark)") %>%
                                             mutate(Normalization.Type = factor(plyr::mapvalues(Normalization.Type, levels.normalization.1SG, labels.normalization.1SG), levels = labels.normalization.1SG, ordered = T))) +
  facet_grid(factor(Cues, levels = c("F1", "F2", "F3", "F0", "Duration"), labels = c("F1", "F2", "F3", "F0", "duration")) ~ factor(Quantity, levels = c("long vowels", "short vowels", "all vowels")), scales = "free_y")
```

(ref:separability-by-cue) Separability indices by normalization accounts for long vowels, short vowels, and long and short vowels together (columns), shown for each of the five cues considered in this study (rows). Labels indicate mean across the five test folds. Intervals show average bootstrapped 95% confidence intervals across the test folds. Note that the ranges of the y-axes varies across plots.

```{r separability-by-cue, fig.width=base.width * 4, fig.height=base.height * 5.5, fig.align='center', fig.cap="(ref:separability-by-cue)"}
p.separability.by_cue
```

For F1 (first row of Figure \@ref(fig:separability-by-cue)), we see a clear advantage for centering (in blue) and standardizing (in purple) compared to transformations (in grey) and intrinsic accounts (in yellow). In particular Lobanov normalization seems to maximize category separability along F1, at least for the long vowels and all vowels together. Notably, the accounts pattern differently along F2 (second row of Figure \@ref(fig:separability-by-cue)). Overall, differences between accounts are much smaller along F2, and the clear advantage of centering and standardizing accounts along F1 does not extend to F2.

An altogether different picture is observed for F3. Compared to F1 and F2, the intrinsic account (Miller) performs substantially better in separating categories along F3, while all other accounts perform poorly. This result is surprising: one of the downsides of intrinsic approaches that has been noted in previous work is their sensitivity to measurement error [@thomas2007]. This sensitivity is caused by the fact that intrinsic accounts use a single measurement for normalization, rather than the less noisy estimates resulting from aggregating across segments that are used in extrinsic accounts. Since the third formant is often described as more difficult to reliably estimate than other formants (leading to more measurement error), F3 would be expected to be particularly affected by this weakness of intrinsic accounts.

Yet, further visualization in Figure \@ref(fig:F3-densities) confirms that F3 indeed separates categories particularly well when intrinsic normalization is applied. Compared to other accounts, @miller1989c seems to be particularly successful in separating vowels that differ in lip rounding [in line with @REF]. For example, @miller1989c separates two clusters among the high and mid-high vowels, one consisting of the back vowels `r linguisticsdown::cond_cmpl("[oː]")` and `r linguisticsdown::cond_cmpl("[uː]")`, and the other one of the front `r linguisticsdown::cond_cmpl("[iː]")`, and rounded `r linguisticsdown::cond_cmpl("[yː]")` and `r linguisticsdown::cond_cmpl("[ʉː]")`. One possible explanation for this result is that intrinsic normalization is indeed particularly effective for F3, and that our correction of measurement errors---equally applied to all formants---effectively reduced the issue with F3 measurement errors (presumably the human brain, too, can do better than an uncorrected Praat algorithm without error correction). As we show below, this result for F3 carries over to any combination of cues that includes F3. It is, however, an artifact of using category separability to assess the effectiveness of normalization, as we show in Study 2. We elaborate on this issue in the discussion of Study 1.

Returning to Figure \@ref(fig:separability-by-cue), normalization does not increase category separability for F0. This is expected given that F0 is known not to increase category separability, but rather have indirect influences on vowel quality [e.g., @barreda2012a; @barreda2020a].<!--AP: adjusted after Barreda meeting--> Finally, for duration all of the C-CuRE accounts group together against the remaining accounts. This, too, is expected since all other accounts are formant-specific and thus do not normalize duration. In summary, the five cues contribute to category separability in different ways, and this is reflected in varying effectiveness of different normalization accounts. We also note that the best performing normalization account for any combination of cues and vowel qualities is typically never significantly better than the next best performing model (the 95% confidence intervals of the best model overlap with the mean of the next best model). In fact, for many combinations of cues and vowel qualities, many of the models perform similarly.

(ref:F3-densities) Category densities along F3 illustrates the effectiveness of vowel-intrinsic normalization for this cue. Here shown for Miller, compared to vowel-extrinsic accounts that center and/or standardize cues. For reference, densities in the absence of normalization are also shown.

```{r F3-densities, fig.width= base.width * 4, fig.height = base.height * 2.5, fig.align='center', fig.cap="(ref:F3-densities)"}
# Generate list of manual y-scale limits, in order to have category labels fit in at density tops
scales <- list(
  # Specify all the scales, one for each facet
  scale_y_continuous(limits = c(0,.003)),
  scale_y_continuous(limits = c(0,8)),
  scale_y_continuous(limits = c(0, .004)),
  scale_y_continuous(limits = c(0,1)),
  scale_y_continuous(limits = c(0,.003)),
  scale_y_continuous(limits = c(0,10)),
  scale_y_continuous(limits = c(0, .003)),
  scale_y_continuous(limits = c(0,.8))
)

d.SwehVd.forStudy.long %>%
  filter(fold_type == "test", Normalization.Type %in% c("no normalization (Hz)", "Miller (log)", "C-CuRE (Hz)", "Lobanov (Hz)")) %>%
  ggplot(
    aes(F3, fill = factor(category))) +
  geom_density(alpha = .5) +
  geomtextpath::geom_textdensity(aes(label = category),
                                 size = 3,
                                 hjust = "ymax",
                                 vjust = -0.5, text_only = T, straight = T) +
  theme(legend.position = "none") +
  scale_colour_manual(name = "category", values = colors.vowel.swe, aesthetics = c("colour", "fill")) +
  guides(linetype = "none", color = "none", fill = "none") +
  ggh4x::facet_grid2(factor(Quantity, levels = c("long", "short"), labels = c("long vowels", "short vowels")) ~ Normalization.Type, scales = "free", independent = "all") +
  ggh4x::facetted_pos_scales(y = scales)
```

Next, we summarize how normalization affects category separability when combinations of the fives cues are considered. Figure \@ref(fig:separability) shows the separability index for the different normalization accounts for three different combinations of cues. For the first row of Figure \@ref(fig:separability), we followed most previous research in assessing category separability for the combination of F1 and F2 [e.g., @disner1980; @fabricius2009; @Flynn2011; @hindle1978; @labov2010]. Accounts that center against the talker's overall formant mean (in blue) are among the best performing normalization accounts. No matter the assumed perceptual scale, centering always improves category separability. Standardizing accounts (in purple), primarily @lobanov1971, also perform well at separating categories, more so for the long vowels. However, scale transformations (in grey), and intrinsic accounts (in yellow), do not improve category separability compared to unnormalized Hz, at least not when assessed on the long vowels or the entire vowel space. 

The remaining rows of Figure \@ref(fig:separability) compare normalization accounts when F3 (second row) or F0, F3, and duration are included (third row). Overall, the category separability is now lower, a result of how the accounts affect category separability along the cues added (see Figure \@ref(fig:separability-by-cue)). The most drastic change in performance concerns the intrinsic @miller1989c and the standardizing accounts. When including F3, @miller1989c performs as well or better, in absolute numbers, as when evaluated on the combination of F1 and F2, thereby increasing its performance relative to other accounts. The standardizing accounts, however, drop substantially in performance and perform worse even than unnormalized cues as soon as any cue besides F1 and F2 is included. As surprising as this might appear, it mirrors what was found when assessing the category separability separately for each cue (Figure \@ref(fig:separability-by-cue)). The high performance of @miller1989c seems to be driven by its ability to increase category separability along F3, whereas the low performance of @gerstman1968 and @lobanov1971 appears to be a result of their inability to increase separability along F3 and duration. For a language like Swedish, where F3 carry information to vowel identity, intrinsic accounts such as @miller1989c, that appear to do very well at successfully distinguish categories along F3, seem to be particularly helpful in increasing category separability.

Finally, looking across all three rows, category separability is consistently higher for short than long vowels. The same pattern is evident for each cue separately in Figure \@ref(fig:separability-by-cue). This result might initially be puzzling, given that previous descriptions of Swedish vowel inventories characterize the inventory of short vowels as being more centralized and more densely clustered [e.g., @kuronen2000; @riad2014]. Indeed, this claim seems to hold for SwehVd---compare Figures \@ref(fig:swe-vowels-normalized-long) and \@ref(fig:swe-vowels-normalized-short). However, the short vowels exhibit less category variability and less category overlap, making them overall more separable. 

```{r}
#"F1F2", "F1F3", "F0F3", "F0F2", "all", "allNOF0", "allNOF3"
p.separability <- plot_separability(d.SwehVd.forStudy.SI.long %>%
                                            #Filter down to test data, and to the best performing implementation of Syrdal&Gopal
                                             filter(Cues %in% c("F1F2", "F1F3", "all"), Normalization.Type != "SyrdalGopal2 (Bark)") %>%
                                             mutate(Normalization.Type = factor(plyr::mapvalues(Normalization.Type, levels.normalization.1SG, labels.normalization.1SG), levels = labels.normalization.1SG, ordered = T))) +
  facet_grid(factor(Cues, levels = c("F1F2", "F1F3", "all"), labels = c("F1-F2", "F1-F3", "F0-F3, duration")) ~ factor(Quantity, levels = c("long vowels", "short vowels", "all vowels")), scales = "free_y")
```

(ref:separability) Separability indices by normalization accounts for long vowels, short vowels, and both long and short vowels together (columns) shown for three different combinations of cues (rows). Labels indicate mean across the five test folds. Intervals show average bootstrapped 95% confidence intervals across the test folds. Note that the ranges of the y-axes varies across plots.

```{r separability, fig.width= base.width * 4, fig.height = base.height * 3, fig.align='center', fig.cap="(ref:separability)"}
cowplot::plot_grid(NULL, p.separability, rel_widths = c(.01, 1))
```

## Discussion
When only F1 and F2 are considered, as in most previous work on vowel normalization, we find that extrinsic centering and standardizing accounts achieve the best category separability. Within these two types of accounts, there is considerable variability. For example, among the intrinsic accounts, Miller performs worse than Syrdal & Gopal, among the extrinsic accounts, versions of C-CuRE seem to consistently perform best. It is also worth noting, however, that there is never a single account that performs significantly better than all other normalizations. This points to the inherent similarities across normalization accounts, and perhaps limitations of the approach taken here (and in some previous work). We return to this point in the general discussion. Regardless of these caveats, the findings for F1 and F2 of Study I, revise the results of @disner1980 for Swedish, and instead replicates previous findings for the other Germanic languages in Disner's sample as well as the majority of previous studies on other languages [e.g., @fabricius2009; @Flynn2011; @labov2010]. 

However, when F3 is considered along with F1 and F2, this result does no longer hold. Key to understanding this result and what it says about the suitability of category separability as a measure of normalization accounts is Figure \@ref(fig:separability-by-cue): while extrinsic normalization performs better than other approaches for F1 and F2, the absolute differences in performance are small compared to the advantage of the intrinsic account observed for F3. Combined with a seemingly innocuous aspect of the separability index in Equation \@ref(eq:separability-index), this allows separability along F3 to dominate separability along the other cue dimensions. Our separability index takes the *sum* of (squared) distances along each cue dimension, essentially assuming that the effect of all cues is simply a sum of each cue's effect considered separately. This means that the separability index cannot capture the *joint* effect of cues---whether, for example, one cue effectively separates one set of categories and another cue separates another set of categories, rather than both cues separating the same categories. The separability index thus cannot recognize, for example, that F1 and F2 capture largely complementary aspects of the vowel inventory (as evident in, for example, Figures \@ref(fig:swe-vowels-normalized-long) and \@ref(fig:swe-vowels-normalized-short)).

This is not the only deficiency of the separability index or similar measures of category variability. The use of *squared* distances means that even a small number of observations located far away from the category mean can disproportionally affect the index. Consider, for example, the F3 densities in Figure \@ref(fig:F3-densities). For non-intrinsic normalizations, some categories have low but non-zero densities far away from the mode. Because of the use of squared distances, this results in low category separability for these normalization accounts despite the fact that observations with such cue values are rare and thus not expected to have a large effect on the *average* perceptual separability of vowels. For the same reason (the use of squared distances), category separability can be high even if a cue separates only a small subset of categories (as is the case for F3), compared to another cue that more gradiently separates *all* categories (as is the case for F1 and F2; see Figure \@ref(fig:swe-vowels-all-cues)).

Finally, measures like the separability index suffer from a conceptual issue: the goal of speech perception is presumably not to reduce cue variability around the category mean but rather to increase the probability of correct recognition (of both linguistic and social information, where we focus on the former here). These two goals are not the same [see also discussion in @barreda2020a]. In sum, indices of variability and category separability like that in Equation \@ref(eq:separability-index) fail to adequately assess the expected consequences of normalization for perception, which is the primary interest of this study. Study 2 addresses this issue.

# Study 2: Comparing the expected effects of normalization on perception {#sec:studyII}
Study 2 takes a more direct approach to evaluating the expected effects of normalization for the perception of vowels. Specifically, we use a general model of speech perception, Bayesian ideal observers [e.g., @clayards2008; @nearey1986a; @norris-mcqueen2008], to predict the vowel identities in the SwehVd database under different normalization accounts. We then compare normalization accounts based on the recognition accuracy that they achieve when the (un)normalized cues are fed into the otherwise identical categorization model. We evaluate the same normalization accounts as those investigated in Study 1. And, as in Study 1, we repeat this comparisons for different combinations of cues, and while categorizing just long vowels, just short vowels, or both long and short vowels together. 

\begin{landscape}\begin{table}

\caption{\label{tab:norm-evaluation-percep}Previous studies comparing normalization accounts' predictions for perception}
\centering
\fontsize{7}{9}\selectfont
\begin{tabular}[t]{>{\raggedright\arraybackslash}p{2cm}>{\raggedright\arraybackslash}p{2cm}>{\raggedright\arraybackslash}p{5.5cm}>{\raggedright\arraybackslash}p{5.5cm}>{\raggedright\arraybackslash}p{2cm}>{\raggedright\arraybackslash}p{2cm}>{\raggedright\arraybackslash}p{1.5cm}}
\toprule
Language(s) investigated & Article & Speech materials & Normalization accounts & Approach & Accuracy assessed & Best two performing\\
\midrule
 & Barreda, 2021 & synthesized stimuli representing 6 talker types (based on data from 30 female/male talkers of California English (15 tokens * 11 vowels)) & Nearey2, Watt \& Fabricius, Lobanov & regression & against perceived category & Nearey2 (1), Watt \& Fabricius (2)\\
\cmidrule{2-7}
 & Carpenter \& Govindarajan, 1993 & Peterson \& Barney's (1952) database, 75 female/male child/adult talkers (2 tokens * 10 vowels) & Bark, Mel, ERB, 2 log-transformations, Syrdal \& Gopal, Miller, Nearey1, Nearey2, Gerstman, linear transformation (Watrous, 1993) & fuzzy ARTMAP, K-nearest neighbour & & linear transformation (1), Nearey1 (2)\\
\cmidrule{2-5}
\cmidrule{7-7}
 & Cole, Linebaugh, Munson \& McMurray, 2010 & 10 female/male talkers (3 tokens * 2 target vowels * 4 context vowels * 6 consonants) & C-CuRE & regression &  & C-CuRE (1)\\
\cmidrule{2-5}
\cmidrule{7-7}
 & Johnson \& Sjerps, 2021 & Peterson \& Barney's (1952) database, 75 female/male child/adult talkers (2 tokens * 10 vowels); Hillenbrand et al.'s (1995) database, 138 female/male child/adult talkers (1-3 tokens * 12 vowels) & Mean $\lambda$, F3 anchor, F1 anchor, Mean F* anchor (Sussman, 1986), Nordström, VTLN (Lammert \& Narayanan, 2015), Nearey2, Gerstman, VTLN ($\Delta$F), Nearey1, Watt \& Fabricius, Lobanov, Miller, Syrdal \& Gopal & support vector machine classification models &  & Lobanov (1), Watt \& Fabricius (2)\\
\cmidrule{2-5}
\cmidrule{7-7}
 & McMurray, Cole \& Munson, 2011 & Cole et al. (2010) database, 10 female/male talkers (1 token * 2 target vowels * 4 context vowels * 6 consonants) &  &  & \multirow{-12}{2cm}{\raggedright\arraybackslash against intended category} & \\
\cmidrule{2-3}
\cmidrule{6-6}
 & McMurray \& Jongman, 2016 & Jongman et al. (2000) database, 10 female/male talkers (1 token * 4 vowels * 8 fricatives) & \multirow{-2}{5cm}{\raggedright\arraybackslash C-CuRE} & \multirow{-2}{2cm}{\raggedright\arraybackslash regression} & & \multirow{-2}{2cm}{\raggedright\arraybackslash C-CuRE (1)}\\
\cmidrule{2-5}
\cmidrule{7-7}
 & Nearey, 1989 & synthesized stimuli of male child/adult talker (based on male talker data from Fant, 1973, and Peterson \& Barney, 1952) & intrinsic normalization, extrinsic normalization & response patterns (F-ratio) & & extrinsic effects (1), intrinsic effects (2)\\
\cmidrule{2-5}
\cmidrule{7-7}
 & Richter, Feldman, Salgado \& Jansen, 2017 & models based on Clopper \& Pisoni's (2006) NSP vowel corpus, 60 female/male talkers, 6 varieties (5 tokens * 10 vowels); perceptual data from Feldman et al., 2009 (synthesized stimuli of male talker) & Vocal Tract Length Normalization (VTLN), Lobanov & discrimination model likelihoods & \multirow{-6}{2cm}{\raggedright\arraybackslash against perceived category} & VTLN (1), Lobanov (2)\\
\cmidrule{2-7}
\multirow{-26}{2cm}{\raggedright\arraybackslash US English} & Syrdal, 1985 & Peterson \& Barney's (1952) database, 75 female/male child/adult talkers (2 tokens * 10 vowels) & log-transformation, Bark, Syrdal's bark-difference model, Miller (2 accounts), Nearey1, Nearey2, Gerstman & linear discriminant analysis &  & Nearey1 (1), Nearey2 (2)\\
\cmidrule{1-5}
\cmidrule{7-7}
Brazilian Portuguese \& US English & Escudero \& Hoffman Bion, 2007 & models trained on 400,000 F1-F2 combinations generated on recordings of 8 female/male talkers (20 tokens * 7 vowels and 15 tokens * 11 vowels) & Nearey1, Lobanov, Gerstman & constraint rankings &  & \\
\cmidrule{1-5}
Dutch & Adank, Smits \& van Hout, 2004 & 160 female/male talkers, 8 varieties (2 tokens * 9 vowels) & log-transformation, Bark, Mel, ERB, Syrdal \& Gopal, Lobanov, Nearey1, Nearey2, Gerstman, Nordström, Miller & linear discriminant analysis & \multirow{-8}{2cm}{\raggedright\arraybackslash against intended category} & \multirow{-2}{2cm}{\raggedright\arraybackslash Lobanov (1), Nearey1 (2)}\\
\bottomrule
\end{tabular}
\end{table}
\end{landscape}

Table \@ref(tab:norm-evaluation-percep) lists previous studies that have compared normalization accounts in terms of their expected consequences for perception. While some previous studies have evaluated normalization accounts against listeners' responses in perception experiments [@barreda2021; @mcmurray-jongman2016; @nearey1989; @richter2017], the majority of previous work has evaluated accounts against the category intended by the talker---i.e., against production data. Here, we follow this majority (though we plan to conduct perception studies on Swedish in the future).

Across languages and approaches, the studies in Table \@ref(tab:norm-evaluation-percep) yield similar results as those summarized in Table \@ref(tab:norm-evaluation-variability) for category separability. Normalization improves recognition accuracy compared to unnormalized cues. Perceptual transformations perform worse than intrinsic or extrinsic normalization at predicting perception from production data. Furthermore, the same normalization accounts that have been found to be most successful at reducing inter-talker variability [e.g., @lobanov1971; @nearey1978] are also often found to achieve higher recognition accuracy [e.g., @adank2004; @escudero2007; @johnson-sjerps2021; @syrda1985]. Despite these overall similarities in results, it is important to keep in mind that the two approaches---category separability and models of perception---do not *have* to yield the same results. In the present study, we go beyond previous work by modeling perception of both vowel quality and vowel quantity over a particularly dense vowel space, and by considering additional cues. We expect, in particular, that the approach in Study 2 will remove the deficiency of the separability index related to F3 observed in Study 1.

As also shown in Table \@ref(tab:norm-evaluation-percep), previous work has employed a number of model types to compare the expected effects of normalization on perception, ranging from models based on phonological theory [e.g., optimality theory, @escudero2007], to more general models of categorization [e.g., linear discriminant analysis, @adank2004; @syrda1985; k-nearest neighbors as in exemplar theory or ARTMAP, @carpenter1993; Bayesian inference, @Kleinschmidt2018; @richter2017; support vector machine classification models, @johnson-sjerps2021], to general frameworks for data analysis [e.g., regression, @cole2010; @mcmurray-jongman2016]. We use ideal observers, rather than other approaches, because they remove *all* degrees of freedom from the modeling. For example, k-nearest neighbor categorization requires the choice of a similarity metric, which can introduce one or more degrees of freedom into the modeling, and requires a choice for $k$. Linear discriminant analysis or regression introduce at least one degree of freedom for each cue considered. Bayesian ideal observers encode the assumption that listeners use and integrate cues *optimally*. As a consequence, the predicted posterior probabilities of all categories for a given acoustic input are perfectly determined by the combination of (1) the category-specific distribution of cues in the previous input and (2) the cue values of the input. Next, we describe ideal observers in more detail. After introducing ideal observers, we detail how this approach avoids the pitfalls of the separability index employed in Study 1.

## Methods {#sec:methodsII}

### Speech materials {#sec:speechMaterialsII}
Study 2 employs the same speech materials as in Study 1.

### Ideal Observers to predict the consequences of normalization for perception {#sec:IOs}
Ideal observers provide an analytical framework for estimating how a rational listener would optimally behave in response to input (here: $n$-way alternative forced-choice categorization). Ideal observer models have been found to provide a good qualitative and quantitative fit against human speech perception [e.g., @clayards2008; @feldman2009; @kleinschmidt-jaeger2015; @kronrod2016; @norris-mcqueen2008; @xie2021cognition]. Unlike most other models of speech perception, ideal observers in their simplest form---as employed here---have zero degrees of freedom in the link from production to perception: once the ideal observer is trained on phonetic data from a database of *productions*, its predictions about *perception* are not mediated by additional parameters (unlike, e.g., exemplar models, connectionist accounts, or neural networks). This removes researchers' degrees of freedom in the evaluation of normalization accounts, which is the reason we chose ideal observers for Study 2. We emphasize, however, that other researchers can download the R markdown document for this article (which contains the R code for our models) from OSF and substitute any other perceptual model for the ideal observers to assess the extent to which our choice of computational framework affects the findings reported below.

In line with influential theories of speech perception [e.g., exemplar theory, @johnson1997; Bayesian accounts, @luce-pisoni1998; @nearey1990; @norris-mcqueen2008; interactive-activation accounts and their offsprings, @magnuson2020; @mcclelland-elman1986], ideal observers describe the posterior probability of a category as dependent both on the prior probability of the category in the current context, $p(category)$, and the likelihood of the acoustic input under the hypothesis that it originates from the category, $p(cues|category)$:

\begin{equation}
 p(category|cues) = \frac{p(cues|category) \times p(category)}{\sum_c p(cues|category_c) \times p(category_c)} (\#eq:Bayes-rule)
\end{equation}

The category prior, $p(category)$, describes how much the surrounding context favors each category. For Study 2, the choice of category prior cannot affect the qualitative results since category priors are independent of the cues and held identical across all normalization accounts.^[Specifically, category priors have a constant additive effect on the posterior log-odds of categories.] We arbitrarily assume uniform category priors. Specifically, for ideal observers trained and tested on the long and short vowels separately, we model categorization as an 11- and 10-alternatives-forced-choice task, respectively, resulting in $p(category) = .091$ for the former and $p(category) = .1$ for the latter. For ideal observers trained and tested on the entire vowel space, we model categorization as a 21-alternatives-forced-choice task, resulting in $p(category) = .048$.

The likelihood, $p(cues|category)$, describes the distribution of cues for each category. Here, we follow previous work and assume multivariate Gaussian distributions to describe the cue likelihood [e.g., @clayards2008; @kleinschmidt-jaeger2015; @kronrod2016; @xie2021cognition]. That is, we use the model in equation \@ref(eq:Bayes-rule-normal), where $\mu$ and $\Sigma$ refer to the category mean and variance-covariance matrix of the category's multivariate normal distribution. In terms of representational complexity, the assumption of multivariate Gaussian categories strikes a compromise between exemplar storage [less representationally parsimonious, @johnson1997; @pierrehumbert2001] and cue integration over multiple separate univariate Gaussians [more parsimonious, @toscano-mcmurray2010].^[Human perception is affected by an additional source of uncertainty beyond category variability: perceptual noise [for review, see @feldman2009]. There is now evidence that including such perceptual noise in models provides a better fit against human behavior [e.g., @kronrod2016; @tan2022]. Since Study 2 assesses the *relative* recognition accuracy of different normalization accounts, it is not immediately obvious how the inclusion of noise could affect our results. To avoid additional researchers degrees of freedom---such as the decision as to which acoustic or perceptual space (Hz, Mel, Bark, etc.) perceptual noise is additive in---we do not model the perceptual consequences of noise. To the best of our knowledge, no previous comparisons of normalization accounts has considered perceptual noise.]

\begin{equation}
 p(category|cues) = \frac{\mathcal{N}(cues| \mu, \Sigma) \times p(category)}{\sum_c \mathcal{N}(cues|\mu_c, \Sigma_c) \times p(category_c)} (\#eq:Bayes-rule-normal)
\end{equation}

Paralleling Study 1, we trained and tested separate ideal observers for each combination of normalization account, cues, and training-test fold. Specifically, we use the exact same cross-validation folds as in Study 1. Each ideal observer was trained on the training portion of the folded unnormalized and normalized data, and subsequently evaluated on the held-out test fold. This means that the parameters of each normalization account (e.g., the cue means in C-CuRE) and the resulting category parameters (the $\mu_c$s and $\Sigma_c$s for all categories) were set on the training data, and not changed for the test data. This reflects the realities of speech perception: although this is often ignored in evaluations of normalization accounts [e.g., @barreda2021; @mcmurray-jongman2011], listeners do not *a priori* know the cue means, cue variance, etc. of an unfamiliar talker. Rather, listeners need to incrementally *infer* those statistical properties from the talker's speech input [for discussion and a model, see @xie2022]. An additional advantage of cross-validation is that it gives us an estimate of the uncertainty about the model predictions. The performance of each ideal observer during test is assessed by calculating the ideal observer's predicted posterior probability of the *intended* category for each test token. This is identical to assuming Luce's choice rule for categorization [@luce1959], as in most models of speech perception and spoken word recognition.

### Advantages compared to separability index and similar measures of category variability
By using a categorization model to estimate the consequence of normalization for perception, we avoid the pitfalls of the separability index discussed in Study 1. First, by using the density of an acoustic input under the multivariate distribution of all cues, the ideal observers we employ capture the *joint* effect of all cues. This captures that an input can be an improbable instance of a category based on one of its cue values but a probable instance given the values for the other cues. In particular, since we assume multivariate likelihoods, the model can account for category-specific covariances between cues. In the presence of strong correlations between cues, an acoustic input can be an improbable instance of a category based on the marginal distribution of each cue---i.e., if each cue is considered separately---but be a highly probable instance of that category if considered relative to the joint distribution of all cues (and vice versa). This is illustrated by Figure \@ref(fig:gaussians)A.<!-- TO DO: consider giving cumulative probability for both marginals and for joint.-->

```{r}
p.marginal.joint.1cat <- d.SwehVd %>%
  filter(Word != "hädd", Transcribed_vowel == "targeted") %>%
  select(F1, F2, F3, Talker, Token, category) %>%
  # Get the geometric mean across the three time points for the five cues
  group_by(Talker, category, Token) %>%
  summarise(across(c(F1, F2, F3), ~ geometric.mean(.x))) %>%
  filter(category == "[ɑː]") %>%
  ggplot(
    aes(x=F2,
        y=F1,
        color = category)) +
  geom_point(alpha = .6, size = 1) +
  stat_ellipse() +
  geom_label(
    data =
      ~ .x %>%
      group_by(category) %>%
      summarise(across(c(F1, F2), ~ mean(.x))),
    mapping = aes(
      colour = category,
      label = category,
      fontface = ifelse(category %in% levels.vowel.IPA.swe.long, 2, 1)),
    alpha = .4, size = 4, label.size = NA) +
    scale_colour_manual(name = "category", values = colors.vowel.swe, aesthetics = "colour") +
  scale_x_reverse(breaks = scales::pretty_breaks(n = 4), limits = c(1400, 550)) +
  scale_y_reverse(breaks = scales::pretty_breaks(n = 4), limits = c(900, 350)) +
  geom_point(
    aes(x=1180,
        y=790),
    color = "black",
    size = 1) +
    guides(color = "none") +
  geom_rug(
    mapping = aes(
      x=1180,
      y=790),
    color = "black",
    sides = "tr",
    length = unit(0.05, "npc"),
    linewidth = 1)

p.marginal.joint.2cat <- p.marginal.joint.1cat %+%
  (d.SwehVd %>%
    select(F1, F2, F3, Talker, Token, category) %>%
    # Get the geometric mean across the three time points for the five cues
    group_by(Talker, category, Token) %>%
    summarise(across(c(F1, F2, F3), ~ geometric.mean(.x))) %>%
    filter(category %in% c("[ɑː]", "[oː]"))) +
  geom_point(
    aes(x=880,
        y=510),
    color = "black",
    size = 1) +
    guides(color = "none") +
  geom_rug(
    mapping = aes(
      x=880,
      y=510),
    color = "black",
    sides = "tr",
    length = unit(0.05, "npc"),
    linewidth = 1)

p.marginal.joint.1cat %<>% ggExtra::ggMarginal(p.marginal.joint.1cat, groupColour = TRUE, groupFill = TRUE)
p.marginal.joint.2cat %<>% ggExtra::ggMarginal(p.marginal.joint.2cat, groupColour = TRUE, groupFill = TRUE)

```

(ref:gaussians) Using a perceptual model to evaluate normalization accounts avoids the pitfalls of separability/variability indices. **Panel A:** an acoustic token can be an improbable instance of a category if each cue is considered separately (the marginal densities along the sides of the plot), but highly probable if considered relative to the joint distribution of cues (the bivariate distribution indicated by the ellipse). **Panel B:** two acoustic tokens that are equally far from the mean of one category can have radically different consequences for perception, depending on where the tokens fall relative to other categories. Under the hypothesis that the two black points are instances of category `r linguisticsdown::cond_cmpl("[ɑː]")`, they would be attributed the same separability index but radically different probabilities given the joint distribution of cues relative to the other category in the space. Ellipses show bivariate Gaussian 95% cumulative probability mass. Ticks on axis show marginal cue means for the tokens. 

```{r gaussians, fig.width= base.width * 4, fig.height = base.height * 1.5, out.height='80%', fig.align='center', fig.cap="(ref:gaussians)"}
cowplot::plot_grid(p.marginal.joint.1cat, p.marginal.joint.2cat, nrow = 1, labels = c("A", "B"))
```

Second, by normalizing the support for a category by the support for all other categories (the denominator in Equations \@ref(eq:Bayes-rule) and \@ref(eq:Bayes-rule-normal)), ideal observers consider the perceptual consequences of an acoustic input *relative to all possible categories*. This means that a token that is relatively far away from its category mean does not necessarily result in low recognition accuracy. Rather, low recognition accuracy is only predicted if the relative position of the acoustic input in the acoustic-phonetic space makes it more probably that the input originated from another (unintended) category. This is illustrated in Figure \@ref(fig:gaussians)B, and parallels human perception: e.g., while a /d/ with hyper-articulated voice onset timing is atypical, human listeners are as likely or more likely to recognize it as a /d/ (rather than a /t/), compared to a casually articulated /d/, presumably *because the observed phonetics would be even less likely to occur if the talker intended a /t/*. Measures of between- vs. within-category variability like the separability index in Study 1, however, have no means of directly capturing this.

Finally, when an acoustic input is indeed improbable under its intended category relative to other unintended categories, the ideal observer model will correctly predict low recognition accuracy. Unlike the separability index in Study 1, however, the ideal observer will not disproportionally weight this single observation: it will simply be one of many observations---much like human speech perception does not collapse simply because one word (or one vowel) has been misunderstood. As we show next, these differences between the approaches taken in Studies 1 and 2 can, and sometimes do, cause differences in results.

```{r}
#Function for training IOs
train_io <- function(cues, data, group = NULL, no_noise = T, n.category = length(unique(data$category)), verbose = F) {
  cue_transformation = unique(gsub("^_([A-Za-z]+)_.*$" , "\\1", cues))
  cue_normalization = unique(gsub("^.*_([a-z])$" , "\\1", cues))

  # Add noise_variance depending on the no of cues
  noise_variance <- if(no_noise) {
    rep(0, n_distinct(cues))
  } else {
    rep(878, n_distinct(cues)) }# in Mel

  if (any(stringr::str_ends(cues, "_[cs]"))) {
    # calculate how much variance is changed compared to untransformed cues
    stats <-
      data %>%
      ungroup() %>%
      summarise_at(vars(contains("F")), sd) %>%
      select(cues, gsub("hertz", cues)) %>%
      pivot_longer(
        cols = everything(),
        names_pattern = "([A-Za-z]*)_(F[12])_([A-Za-z])",
        names_to = c("cue_transform", "formant", "cue_normalization")) %>%
      pivot_wider(names_from = "cue_normalization") %>%
      mutate(scale_factor = r / !! sym(cue_normalization))

    noise_variance <- noise_variance / stats$scale_factor
  }

  Sigma_noise <- diag(noise_variance)
  dimnames(Sigma_noise) <- list(cues, cues)

  m <- data %>%
    make_MVG_ideal_observer_from_data(
      verbose = verbose,
      category = "category",
      cues = cues,
      group = group,
      prior = rep(1/n.category, n.category),
      lapse_rate = 0,
      lapse_bias = rep(1/n.category, n.category),
      Sigma_noise = Sigma_noise
      )

  return(m)
}
```

```{r}
make_IOs_and_add_test_data <- function(data, cues, separate_by = NULL) {
  separate_by <- c(separate_by, "Normalization.Type", "crossvalidation_group")
  data %>%
  filter(fold_type == "training") %>%
  group_by(!!! syms(separate_by)) %>%
  # train IOs, one for each cross_validation group
  group_map(
    .f = ~ train_io(
      data = .x,
      cues = cues,
      no_noise = T) %>%
      nest(io = everything()) %>%
      bind_cols(.y)) %>%
    reduce(bind_rows) %>%
    # Add test data *that matches the IO*
    left_join(
      data %>%
        filter(fold_type == "test") %>%
        select(Talker, category, Token, !!! syms(cues), !!! syms(separate_by)) %>%
        # Renaming category here to avoid confusion downstream (with IO.Vowel)
        rename(Intended.Vowel = category),
      by = separate_by) %>%
    mutate(x = pmap(.l = list(!!! syms(cues)), ~ c(...))) %>%
    nest(test_data = c(Talker, Intended.Vowel, Token, !!! syms(cues), x)) %>%
    # Rename columns to identify each IO by
    mutate(
      Normalization.Type =
        factor(
          plyr::mapvalues(Normalization.Type, labels.normalization, levels.normalization.plots),
          levels = levels.normalization.plots)) %>%
    rename_with(
      .cols = separate_by,
      .fn = ~ paste0("IO.", .x)) %>%
    separate(IO.Normalization.Type, c("IO.cue_normalization", "IO.cue_transform"), remove = F) %>%
    mutate(
      IO.cue_transform = factor(IO.cue_transform, levels = c("Hz", "Mel", "Bark", "ERB", "log", "semitones")),
      IO.cue_normalization = factor(IO.cue_normalization, levels = c("r", "SyrdalGopal", "CCuRE", "Lobanov", "Nearey1", "Nearey2", "Gerstman", "Miller"))) %>%
    # Categorize test by IO
    mutate(
      # Store all of posterior distribution
      posterior_of_all_vowels = map2(
        test_data, io,
        ~ get_categorization_from_MVG_ideal_observer(
          x = .x$x,
          model = .y,
          decision_rule = "proportional",
          noise_treatment = "sample",
          lapse_treatment = "marginalize") %>%
          rename(Posterior = response, IO.Vowel = category) %>%
          # Join back in all other information about the test data
          left_join(.x) %>%
          relocate(Talker, Token, Intended.Vowel, observationID, x, everything())),
      # Store only the posterior of intended vowel
      posterior_of_intended_vowel = map(posterior_of_all_vowels, ~ .x %>% filter(Intended.Vowel == IO.Vowel)),
      # Format the posterior for all vowels to be wide
      posterior_of_all_vowels = map(posterior_of_all_vowels, ~ .x %>% pivot_wider(names_from = IO.Vowel, values_from = Posterior))) %>%
    relocate(starts_with("IO", ignore.case = F), io, test_data, posterior_of_all_vowels, posterior_of_intended_vowel)
}

# Make talker-independent IOs on long and short vowels *separately*, for different cue combinations
m.io.SwehVd.F1F2_by_quantity <-
  make_IOs_and_add_test_data(
    data = d.SwehVd.forStudy.long %>%
      #Filter down to the best performing implementation of Syrdal&Gopal
      filter(Normalization.Type != "SyrdalGopal2 (Bark)"),
    cues = c("F1", "F2"),
    separate_by = c("Quantity"))

m.io.SwehVd.F1F3_by_quantity <-
  make_IOs_and_add_test_data(
    data = d.SwehVd.forStudy.long %>%
      filter(!Normalization.Type %in% c("SyrdalGopal (Bark)", "SyrdalGopal2 (Bark)")),
    cues = c("F1", "F2", "F3"),
    separate_by = c("Quantity"))

m.io.SwehVd.all_by_quantity <-
  make_IOs_and_add_test_data(
    data = d.SwehVd.forStudy.long %>%
      filter(!Normalization.Type %in% c("SyrdalGopal (Bark)", "SyrdalGopal2 (Bark)")),
    cues = c("F0", "F1", "F2", "F3", "Duration"),
    separate_by = c("Quantity"))

# Make talker-independent IOs on long and short vowels *combined*, for different cue combinations
m.io.SwehVd.F1F2 <-
  make_IOs_and_add_test_data(
    data = d.SwehVd.forStudy.long %>%
      #Filter down to the best performing implementation of Syrdal&Gopal
      filter(Normalization.Type != "SyrdalGopal2 (Bark)"),
    cues = c("F1", "F2")) %>%
  # Add column for plotting
  mutate(
    IO.Quantity = "all")

m.io.SwehVd.F1F3 <-
  make_IOs_and_add_test_data(
    data = d.SwehVd.forStudy.long %>%
      filter(!Normalization.Type %in% c("SyrdalGopal (Bark)", "SyrdalGopal2 (Bark)")),
    cues = c("F1", "F2", "F3")) %>%
  # Add column for plotting
  mutate(
    IO.Quantity = "all")

m.io.SwehVd.all <-
  make_IOs_and_add_test_data(
    data = d.SwehVd.forStudy.long %>%
      filter(!Normalization.Type %in% c("SyrdalGopal (Bark)", "SyrdalGopal2 (Bark)")),
    cues = c("F0", "F1", "F2", "F3", "Duration")) %>%
  # Add column for plotting
  mutate(
    IO.Quantity = "all")

#Make combined dataframe for plotting
m.io.SwehVd <- rbind(
  m.io.SwehVd.F1F2_by_quantity %>%
    mutate(Cue_space = "F1-F2"),
  m.io.SwehVd.F1F2 %>%
    mutate(Cue_space = "F1-F2"),
  m.io.SwehVd.F1F3_by_quantity %>%
    mutate(Cue_space = "F1-F3"),
  m.io.SwehVd.F1F3  %>%
    mutate(Cue_space = "F1-F3"),
  m.io.SwehVd.all_by_quantity %>%
    mutate(Cue_space = "F0-F3, duration"),
  m.io.SwehVd.all %>%
    mutate(Cue_space = "F0-F3, duration")) %>%
  mutate(Cue_space = factor(Cue_space, levels = c("F1-F2", "F1-F3", "F0-F3, duration")))
```
```{r}
# Accuracies compared to the intended vowel
d.max.acc.toINTEND <- m.io.SwehVd %>%
  unnest(posterior_of_intended_vowel) %>%
  group_by(IO.Normalization.Type, Cue_space, IO.crossvalidation_group, IO.Quantity) %>%
  summarise(mean.acc = mean(Posterior)) %>%
  group_by(IO.Normalization.Type, Cue_space, IO.Quantity) %>%
  summarise(mean = mean(mean.acc))

d.max.acc.toINTEND.diff <- d.max.acc.toINTEND %>% 
  group_by(Cue_space, IO.Quantity) %>% 
  filter(mean == max(mean)) %>%
  left_join(d.max.acc.toINTEND %>%
              filter(IO.Normalization.Type == "r_Hz"),
            by = c("Cue_space", "IO.Quantity")) %>%
  mutate(diff = mean.x - mean.y) %>%
  ungroup()
```

## Results aggregating across vowels {#sec:resultsII}
Figure \@ref(fig:predictions) visualizes the unnormalized and normalized models' predictions for perception of Stockholm Swedish vowels, under different assumptions about the relevant cues. As in Study 1, this figure aggregates results across vowels of a given type (long, short, both). We first discuss these results, and then briefly summarize how different vowels are affected by normalization.

The first observation is that---unlike for the separability index in Study 1---the relative performance of the different normalization accounts within each panel is remarkably constant across all panels (compare to Figure \@ref(fig:separability)). Regardless of the combination of cues or the vowel types considered (long, short, both), transformation into a perceptual space does little to improve recognition accuracy, compared to unnormalized cues. Intrinsic normalization, too, does not improve recognition accuracy. And, unlike in Study 1, this result holds even when F3 is included as a cue. This replicates previous work on Dutch [@adank2004] but conflicts with some evaluations of English [e.g., @syrda1985]. @adank2004 discussed whether the discrepancy in results might be attributed to implementations of the Bark-transformation, or to what @syrda1985 describes as language-specificity of the second dimension of @Syrdal1986 normalization. The present results would seem to confirm this vulnerability of intrinsic normalizations. <!-- TO DO: Starting at @adank2004 discussed, this feels to me more like sth that should go into the discussion. Perhaps we do the same with any replication statements? (but at least these more complicated ones) -->
Extrinsic normalization, however, tends to substantially improve recognition accuracy (with the exception of Gerstman normalization). Depending on the specific combination of cues and the vowel qualities considered, the best-performing normalization model increases recognition accuracy by at least `r d.max.acc.toINTEND.diff %>% filter(mean.x == min(mean.x)) %>% pull(mean.x) %>% round(digits = 3) * 100`% (from `r d.max.acc.toINTEND.diff %>% filter(mean.x == min(mean.x)) %>% pull(mean.y) %>% round(digits = 3) * 100`% for unnormalized cues for all vowels when only F1-F2 are considered) to `r d.max.acc.toINTEND.diff %>% filter(mean.x == max(mean.x)) %>% pull(mean.x) %>% round(digits = 3) * 100`% (from `r d.max.acc.toINTEND.diff %>% filter(mean.x == max(mean.x)) %>% pull(mean.y) %>% round(digits = 3) * 100`% for short vowels when all cues are considered). The benefit of extrinsic normalization models, as well as the lower performance of perceptual transformations, replicates previous findings on other languages [e.g., @adank2004; @escudero2007; @nearey1989 found effects of both intrinsic and extrinsic accounts, but larger effects for extrinsic].

We also see that all models---even for unnormalized cues---perform substantially above chance. When long and short vowels are considered separately, the best ideal observers achieve recognition accuracies of `r d.max.acc.toINTEND.diff %>% filter(IO.Quantity == "long") %>% summarise(max = max(mean.x)) %>% round(digits = 3) * 100`% for long vowels and `r d.max.acc.toINTEND.diff %>% filter(IO.Quantity == "short") %>% summarise(max = max(mean.x)) %>% round(digits = 3) * 100`% for short vowels. For reference, in a recent perception experiment we conducted on the eight monophthongs of US English, L1-US English listeners achieved 71.1% accuracy in categorizing isolated hVd words [chance = 12.5%, @persson-jaeger2023]. The ideal observers for the Swedish vowel system thus achieve performance that is comparable to that of human listeners, at least when cues are normalized.

Looking across columns of Figure \@ref(fig:predictions), short vowels are always recognized with higher accuracy compared to long vowels. This increase in performance cannot be explained by the small increase in the chance baseline alone (10% for the 10 short vowels, compared to 9.1% for the 11 long vowels). It conceptually replicates an initially surprising result of Study 1: while short vowels are more densely clustered in the center of the vowel space, and thus occupy a smaller perceptual space, they also exhibit less variability. Overall, this makes those vowels *easier* to recognize. 

When long and short vowels are categorized together, performance of the ideal observers is comparatively poor unless vowel duration is included as a cue. This is expected given that vowel duration is the primary cue to vowel quantity. Of interest, however, is that even the inclusion of only F3 (second row) yields a substantial improvement in recognition accuracy, in line with @carpenter1993 [see also @hillenbrand1995 and @johnson-sjerps2021 for recognition accuracy of unnormalized F1-F2 vs. unnormalized F0-F3]. Remarkably, once vowel duration is included, the best-performing ideal observer achieves 75% recognition accuracy across the 21 long and short vowels (compared to chance = 4.8%).

Looking across rows, we note that Lobanov normalization clearly performs best when only the first two formants are considered. Indeed, when only F1 and F2 are considered and all vowels are categorized (top right panel of Figure \@ref(fig:predictions)), Lobanov performs *significantly* better than any of the other normalization models (the 95% confidence intervals of Lobanov normalization does not include the mean of the second best performing model). However, this advantage of Lobanov normalization decreases and is no longer significant when additional cues are considered.^[\label{fn:best-performing} Indeed, when all five cues are considered for the categorization of all 21 short and long vowels, the best centering account perform numerically better (`r d.max.acc.toINTEND.diff %>% filter(IO.Quantity == "all", Cue_space == "F0-F3, duration") %>% summarise(max = max(mean.x)) %>% round(digits = 3) * 100`%) than Lobanov normalization (`r d.max.acc.toINTEND %>% filter(IO.Quantity == "all", Cue_space == "F0-F3, duration", IO.Normalization.Type == "Lobanov_Hz") %>% pull(mean) %>% round(digits = 3) * 100`%). This is, however, an artifact of our decision to only center vowel duration---the primary cue to vowel quantity---for the C-CuRE model (paralleling Study 1). Separate modeling not shown here confirmed that Lobanov normalizaton achieves the same recognition accuracy as the C-CuRE models when duration is centered and combined with Lobanov-normalized formants (74.9%, 95%-CI: 73.9-75.9%).]

```{r}
#Remove temp file
rm(d.max.acc.toINTEND)

# Plot the overall accuracy of the different normalization accounts
plot_io_results <- function(data) {
  data %>%
    # Rename IO.Normalization.Type for plotting
    mutate(
      IO.Normalization.Type =
        factor(
          plyr::mapvalues(IO.Normalization.Type, levels.normalization.plots, labels.normalization),
          levels = labels.normalization)) %>%
    unnest(posterior_of_intended_vowel) %>%
    # Get the CI over the five folds
    { if ("IO.Quantity" %in% names(data)) group_by(., IO.Normalization.Type, IO.Quantity, IO.crossvalidation_group, Cue_space) else  group_by(., IO.Normalization.Type, IO.crossvalidation_group, Cue_space) } %>%
    summarise(
      chance = 1 / n_distinct(Intended.Vowel, na.rm = TRUE),
      ci = list(enframe(Hmisc::smean.cl.boot(Posterior)))) %>%
    unnest(ci) %>%
    spread(name, value) %>%
    { if ("IO.Quantity" %in% names(data)) group_by(., IO.Normalization.Type, IO.Quantity, Cue_space) else  group_by(., IO.Normalization.Type, Cue_space) } %>%
    summarise(
      chance = first(chance),
      mean_CI_lower = mean(Lower),
      mean_CI_upper = mean(Upper),
      mean = mean(Mean)) %>%
    ggplot() +
    geom_pointrange(
      aes(x = IO.Normalization.Type,
          y = mean,
          ymin = mean_CI_lower,
          ymax = mean_CI_upper,
          color = IO.Normalization.Type),
      position = position_dodge2(width = 0.3),
      fatten = 2.5) +
    geom_text(mapping = 
                 aes(x = IO.Normalization.Type,
                     y = mean_CI_upper + .04,
                     colour = IO.Normalization.Type,
                     label = sprintf("%0.2f", mean)),
               alpha = .85,
               size = 3,
               angle = 90,
               hjust = 0) +
    geom_hline(aes(yintercept = chance), color = "gray", linetype = 2) +
    scale_y_continuous("Overall accuracy (of predicting *intended* vowel)", limits = c(0,1))+
    scale_colour_manual(
      "Normalization \nprocedure of IO",
      labels = labels.normalization.1SG,
      values = colors.all.procedures.1SG) +
    guides(color = "none") +
    theme(axis.text.x = ggtext::element_markdown(angle = 60, vjust = 1, hjust = 1, colour = colors.all.procedures.1SG),
        axis.title.x = element_blank())
}

p.accuracy.io.overall <- plot_io_results(m.io.SwehVd) + facet_grid(Cue_space ~ factor(IO.Quantity, levels = c("long", "short", "all"), labels = c("long vowels", "short vowels", "all vowels")))
```

(ref:predictions) Predicted recognition accuracy of ideal observer under different normalization accounts for long vowels, short vowels, and long and short vowels together (columns), shown for for three different combinations of cues (rows). Labels indicate mean across the five test folds. Intervals show average bootstrapped 95% confidence intervals across the test folds. The dashed horizontal line indicates chance (different across columns because of the different number of long and short vowels).

```{r predictions, fig.width= base.width * 4.5, fig.height = base.height * 5.5, fig.align='center', fig.cap="(ref:predictions)"}
p.accuracy.io.overall
```

## Results for specific vowels
Finally, the use of a perceptual model lets us assess vowel-specific effects on the predictions of the ideal observers. While this is not the main focus of this paper, it might be of interest to other researchers. In the SI, we therefore plot both the predicted categorization accuracy per vowel in the different evaluations (see \@ref(sec:accuracy-per-vowel)), as well as confusion matrices of the best and the worst performing ideal observers (see \@ref(sec:confusion)), to further investigate *how* normalization improves recognition accuracy. Here, we briefly mention some of the main findings that emerge from these additional visualizations. For reference, Figure \@ref(fig:predictions-per-vowel) visualizes the predicted recognition accuracy for five vowels that illustrate some of the vowel-specific effects across different types of normalization.

Unsurprisingly, some vowels are recognized with much higher accuracy than others---at least when uniform category priors are assumed, as we did here. This is a direct consequence of the position of the vowel in the acoustic-phonetic space, relative to neighboring vowels: the more neighboring vowels overlap with each other, the lower the accuracy with which they are recognized. Which vowels will benefit from normalization will thus naturally vary between languages, reflecting the language-specific properties of the vowel space. For instance, [`r linguisticsdown::cond_cmpl("iː")`] is often described as more easily recognized in previous work on other languages. This contrasts with our findings for Swedish: here,  [`r linguisticsdown::cond_cmpl("iː")`] is part of the dense clustering of vowels along the height dimension and so has many close competitors. This highlights that recognition accuracy is due to the position of a vowel *relative* to its competitors [e.g., @Peterson1952; @Kuhl1991; @Polka2003], rather than its *absolute location* in the vowel space (e.g., [`r linguisticsdown::cond_cmpl("iː")`] being a peripheral vowel). 

Also of interest is that not all vowels exhibit the benefit of normalization. In general, across evaluations, it seems to be vowels that are already recognized with relatively high accuracy that particularly benefit from normalization, which does not replicate previous studies that have included per-vowel accuracies [e.g., @adank2003; @Syrdal1986]. In fact, @adank2003 reports larger improvements in error rates after normalization for vowels with higher error rates prior to normalization. Finally, while there are minor differences across vowels in the relative goodness of different normalizations, the models that perform overall best also perform best on each vowel [in line with @adank2003]. This further demonstrates the plausibility of these normalization accounts for perception.

(ref:predictions-per-vowel) Predicted recognition accuracy of ideal observer under different normalization accounts for five of the 21 vowels. Point ranges indicate the average mean accuracy and average 95% bootstrapped CI across the five folds. Labels indicate mean across the five test folds. Chance level is indicated by grey line.

```{r cache.lazy=FALSE}
#Plot the overall accuracy of the different normalization accounts
plot_io_results_per_vowel <- function(data) {
  data %>%
  # Rename IO.Normalization.Type for plotting
  mutate(
    IO.Normalization.Type =
      factor(
        plyr::mapvalues(IO.Normalization.Type, levels.normalization.plots, labels.normalization),
        levels = labels.normalization)) %>%
    unnest(posterior_of_intended_vowel) %>%
    # Get the CI over the five folds
    { if ("IO.Quantity" %in% names(data)) group_by(., IO.Normalization.Type, IO.Quantity, IO.crossvalidation_group, Intended.Vowel, Cue_space) else group_by(., IO.Normalization.Type, IO.crossvalidation_group, Intended.Vowel, Cue_space) } %>%
    summarise(
      chance = 1 / n_distinct(Intended.Vowel),
      ci = list(enframe(Hmisc::smean.cl.boot(Posterior)))) %>%
    unnest(ci) %>%
    spread(name, value) %>%
    { if ("IO.Quantity" %in% names(data)) group_by(., IO.Normalization.Type, IO.Quantity, Intended.Vowel, Cue_space) else  group_by(., IO.Normalization.Type, Intended.Vowel, Cue_space) } %>%
    summarise(
      chance = first(chance),
      mean_CI_lower = mean(Lower),
      mean_CI_upper = mean(Upper),
      mean = mean(Mean)) %>%
    ggplot() +
    geom_pointrange(
      aes(x = IO.Normalization.Type,
          y = mean,
          ymin = mean_CI_lower,
          ymax = mean_CI_upper,
          color = IO.Normalization.Type),
      position = position_dodge2(width = 0.3),
      fatten = 2.5) +
    geom_text(mapping = 
                 aes(x = IO.Normalization.Type,
                     y = mean_CI_upper + .01,
                     colour = IO.Normalization.Type,
                     label = sprintf("%0.1f", mean)),
               alpha = .85,
               size = 2.5,
               angle = 90,
               hjust = 0) +
    geom_hline(aes(yintercept = case_when(IO.Quantity == "long" ~ 1/11,
                                          IO.Quantity == "short" ~ 1/10,
                                          IO.Quantity == "all" ~ 1/21)), color = "gray", linetype = 2) +
    scale_y_continuous("Accuracy (of predicting *intended* vowel)", limits = c(0,1))+
    scale_colour_manual(
      "Normalization \nprocedure of IO",
      labels = labels.normalization.1SG,
      values = colors.all.procedures.1SG) +
    guides(color = "none") +
    theme(axis.text.x = ggtext::element_markdown(angle = 60, vjust = 1, hjust = 1, colour = colors.all.procedures.1SG, size = 7),
        axis.title.x = element_blank())
}

p.accuracy.io.per.vowel <- plot_io_results_per_vowel(
  m.io.SwehVd %>% nplyr::nest_filter(posterior_of_intended_vowel, Intended.Vowel %in% c("[eː]", "[æ]", "[ɑː]", "[yː]", "[iː]")) %>%
    filter(IO.Quantity == "all")) +
  facet_grid(Cue_space ~  factor(Intended.Vowel, levels = levels.vowel.IPA.swe))
```

\begin{landscape}

```{r predictions-per-vowel, fig.width=base.width * 5.5, fig.height=base.height * 4, fig.align='center', fig.cap="(ref:predictions-per-vowel)"}
p.accuracy.io.per.vowel
```

\end{landscape}

# General discussion {#sec:discussion}
We have compared low-level pre-linguistic normalization accounts against a new phonetically annotated database of Stockholm Swedish vowels. We set out to evaluate how the different accounts affect the category separability (Study 1), and how they differ in predicted consequences for perception (Study 2). As we have already discussed the methodological shortcomings of separability and variability indices like that employed in Study 1, we focus here on the discussion of Study 2. 

Previous work found that the types of normalization accounts that performed well on other languages did not seem to perform well on Swedish vowel data [@disner1980]. However, as pointed out by Disner, the Swedish data differed from the data for other languages in that study, and the majority of studies on other languages. Here, we followed the majority of previous work on vowel productions and analyzed productions of hVd recordings. We find---both in Study 2 and in Study 1 (as long as additional cues are not included)---that the same accounts found in previous work to perform well on other languages also perform well for the dense vowel space of Swedish. Specifically, Lobanov and centering approaches---incl. Nearey normalization and C-CuRE normalization---were the top-performing accounts, replicating the pattern found in previous studies on other languages [e.g., @adank2004; @carpenter1993; @escudero2007; @syrda1985]. 

This result suggests that the (somewhat) diverging results for Swedish in @disner1980's study, were not caused by properties inherent to Swedish, but more likely were an artifact of the dataset employed by Disner. It also suggests that languages with dense vowel spaces do not necessarily require more complex normalization mechanisms. The best-performing normalization in Study 2 achieved `r d.max.acc.toINTEND.diff %>% filter(IO.Quantity == "all") %>% filter(mean.x == max(mean.x)) %>% pull(mean.x) %>% round(digits = 3) * 100`% recognition accuracy across all 21 vowels, which is comparable to the performance we found in for the same approach when compared to a database of eight monopthong hVd words in L1-US English [XXX.X%; @persson-jaeger2023]. <!-- TO DO: start an OSF for that project on English perception, put the ExLing paper in there and cite it as a manuscript, University of Stockholm. Somewhere in there, we can include in an SI the info of categorizing intended productions. -->

Additionally, we find that the best-performing centering accounts (C-CuRE) often achieve performance that is statistically indistinguishable from the best-performing standardization accounts (Lobanov). This is the case, in particular, when all five cues were considered and all 21 vowels were included in the categorization (see footnote \@ref(fn:best-performing)). Together with similar findings from research on consonants and supra-segmental categories [e.g., @apfelbaum2014; @crinnion2020; @kleinschmidt2019; @kulikov2022; @mcmurray-jongman2011; @mcmurray-jongman2016; @toscano2015; @xie2021cognition; @xie2022], this suggests that simple centering operations might be sufficient to maximize the benefits achievable by normalization. In the remainder, we first summarize some methodological considerations based on the present study, and then discuss limitations of our work, and how they can be addressed in future work.

```{r}
#Remove temp file
rm(d.max.acc.toINTEND.diff)
```

## Methodological considerations
We considered two methods of evaluations. In Study 1, we compared the reduction of within-category variability relative to between-category variability by calculating a separability index (i.e., an F-statistics). This methodology facilitated comparison to previous studies, that has most often assessed the efficacy of normalization accounts by means of increase in between-talker category overlap or category separability, or decrease in category variability [@disner1980; @fabricius2009; @Flynn2011; @hindle1978; @labov2010]. However, given the limitations inherent in this index, in the second study, we used Bayesian ideal observers to investigate how normalization accounts differ in predictions for perception. Previous studies have employed linear discriminant analysis [e.g., @adank2004; @syrda1985], fuzzy ARTMAP or K-nearest neighbour classification [e.g., @carpenter1993], or constraint ranking grammars [e.g., @escudero2007]. While these different approaches will generally return similar results, we see two advantages with ideal observers. First, ideal observers as used here have 0 degrees of freedom in the link from production to perception, thus removing researchers' degrees of freedom in the evaluation of normalization accounts [see @tan2021]. Second, representing the cue likelihood for each category as multivariate Gaussian distributions [e.g., @kronrod2016; @norris-mcqueen2008; @xie2021cognition], strikes a middle ground between less parsimonious models such as exemplar models [e.g., @johnson1997; @pierrehumbert2001], and more parsimonious models, such as models of cue integration over multiple separate univariate Gaussians [e.g., @toscano-mcmurray2010].^[Parsimony here refers both to the number of degrees of freedom these models afford to the researcher *and* to the amount of information that listeners are assumed to store [for discussion, see @xie2022].] However, like any other model of speech perception, the approach adopted here comes with a set of simplifying assumptions. All of the assumptions in the model, e.g., uniform priors, models of linguistic representations, the normalization accounts selected, can, however, be revisited and altered by the reader, as this paper is written in R markdown and all data and code is provided on OSF.

As a final note on methodology, we find the 5-fold cross-validation approach used for normalization of the acoustic data adopted here, advantageous for several reasons, the two most important being that: (1) it allows us to avoid over-fitting to the sample, while also (2) providing a more realistic reflection of how parameters used for normalization are incrementally inferred from the talker's speech input. Even though many of the commonly adopted normalization accounts involve parameters that are set based on the data, previous studies have rarely considered how these parameters might be affected by the specific dataset used for normalization [for exceptions, see e.g., @barreda2018a]. In the present study, we have seen that accounting for researchers' uncertainty about the effects of normalization, highlights that many of the normalization accounts exhibit statistically indistinguishable performance---at least under the approach taken here and in the majority of previous work. This means that future studies should aim to increase statistical power, in order to determine the normalization mechanism that best describes human behaviour. This will require even larger datasets, and/or by targeted sampling of vowel tokens for which predictions of different normalization accounts are maximally contrasted [see e.g., @barreda2021; and see @xie2022 for more general discussion of how to increase the statistical power to determine what mechanism underlie adaptive speech perception]. Next, we close by discussing additional limitations of the present work and future directions.

## Limitations and future directions
Four limitations of the present study, three of which are shared with most previous work, deserve discussion. First, the present study compared normalization accounts against speech from only female talkers of one regional variety of Swedish (Stockholm Swedish). In contrast, many previous studies included data from talkers of different genders [e.g., @barreda2021; @clopper2009; @cole2010; @mcmurray2011; @mcmurray-jongman2016], and sometimes from talkers of different ages [e.g., @barreda2018a; @carpenter1993; @Flynn2011; @hindle1978; @johnson-sjerps2021; @kohn2012a; @syrda1985] and/or language backgrounds [e.g., @adank2004; @disner1980; @escudero2007; @fabricius2009; @labov2010; @richter2017]. Given that age, gender, etc. tends to affect formants (and other cues) beyond talker-variability, it is likely that the inclusion of more diverse talkers would increase the lack of invariance problem. For example, we would expect the ideal observers over unnormalized cues (Study 2) to achieve lower recognition performance if vowel productions from male talkers would be included in the data. In short, the models in Study 2 likely over-estimates the recognition accuracy that can be achieved for unnormalized cues if a more diverse range of talkers is considered.

What does that mean for the relative effect of normalization? To the extent that normalization successfully overcomes inter-talker variability that is caused by gender, age, and other social or physiological factors, we expect that the benefit of normalization accounts should show more clearly, relative to unnormalized cues. In this sense, the present study might *under*-estimate the relative benefits of normalization. Whether the *relative* performance of normalization accounts---i.e., the finding of primary interest to us---would differ if a more diverse range of talkers was considered is unclear. To the extent that vowel-specific accounts were originally developed specifically to eliminate physiological differences that are correlated with gender [as reviewed in, e.g., @johnson-sjerps2021], it is theoretically possible that the high performance of general normalization accounts [e.g., C-CuRE, @mcmurray-jongman2011] might not replicate when talkers of different genders are included. Future releases of the SwehVd database will contain data from male talkers, which will allow us or other researchers to revisit these questions.

Second, the present study aggregated acoustic-phonetic measurements taken at different points of the vowel (at 35%, 50%, and 65% into the vowel) into a single formant measurement. This follows previous comparisons of normalization accounts but is a simplifying assumption that should be revisited in future work. Formant dynamics carry important information for category distinctions [e.g., @Assmann2005; @hillenbrand1999; @nearey1986], and are hypothesized to be of particular importance for some vowel distinctions in other varieties of Central Swedish [e.g., @kuronen2000]. Prior to other consideration, this means that Study 2 likely under-estimates the recognition accuracy that could be achieved even from unnormalized cues alone. It is an open question whether the findings of primary interest---the relative performance of different normalization accounts---would be affected if formant dynamics were considered. Some normalization accounts, for example, consider normalization of such formant dynamics to take place *after* basic formant normalization (but before the mapping of cues to category representations, S. Barreda, personal communication, 01/06/2023). <!-- TO DO: or perhaps this is even in one of the papers? --> Future work could employ SwehVd to compare ideal observers or other classification models while taking into consideration formant measurements throughout the vowel.

Third, we only considered competing *normalization* accounts. This, too, follows previous research on normalization but is potentially problematic.
As mentioned in the introduction, it is now believed that at least three different mechanisms contribute to adaptive speech perception, including not only normalization but also changes in category representations and decision-making [for review, see @xie2022]. This has consequences for research on normalization. For example, @xie2021cognition compared normalization accounts against the production of prosodic phrasing in L1-US English, while also considering alternative hypotheses about listeners' ability to adapt category representations. Xie and colleagues found that the effectiveness of cue normalization is substantially reduced if listeners can learn and maintain talker- or group-specific category representations [as assumed in some influential theories of speech perception, exemplar models, e.g., @johnson1997; @pierrehumbert2001; Bayesian ideal adaptors, @kleinschmidt-jaeger2015]. Xie and colleagues only considered two general types of normalization, and their focus was on the interpretation of prosodic signals. But their results call for caution in interpreting studies like the present that do not consider the possibility of talker-specific representations---an assumption shared with basically all previous work on vowel normalization.

Similarly, we limited our evaluation to a single level of normalization (and combinations of perceptual transformations and a single level of normalization). Some proposals, however, assume multiple separate normalization steps. For example, some accounts hold that evolutionarily early mechanisms first transform spectral percepts into a phonetic space [e.g., uniform scaling accounts, @barreda2020a; @nearey1983], on which additional subsequent normalization might operate. There is also evidence that speech perception combines aspects of intrinsic and extrinsic normalization [@nearey1989]. The present study---like most existing evaluations---did not consider these possibilities [for exceptions, see e.g., @barreda2021; @nearey2018].  

Fourth and finally, we followed the majority of previous work and evaluated normalization accounts against *production* data [for exceptions, see e.g., @barreda2020a; @barreda2021; @mcmurray-jongman2016; @nearey1989; @richter2017; @xie2021cognition]. This is potentially problematic, especially when measures like category separability or reduced cross-talker variability in category means are used to evaluated normalization accounts (as in our Study 1 and many previous studies). These evaluations essentially assume that the goal of speech perception is to make the perceptual realizations of the same category by different talkers as similar as possible in the normalized space [for an in-depth critique, see @barreda2021]. However, the goal of speech perception is presumably to reliably infer the category intended by the talker,^[Or somewhat more precisely, cooperative listeners aim to understand the meaning intended by the talker, and this inference is generally believed to benefit from the correct recognition of phonological categories, such as phonemes, syllables, or word forms. For discussion, see also @hume2016.] and this aim does not necessarily entail perfect removal of cross-talker variability (as evidenced, for example, by the different findings of Studies 1 and 2). To some extent, Study 2 addresses this potential issue by evaluating normalization accounts in terms of how well they predict the vowel category intended by the talker. However, if the goal is to compare how well normalization accounts explain human perception, more informative comparison will require comparison against listeners' categorization responses (which we plan to conduct in the near future).


# References{#sec:references}

\begingroup
\setlength{\parindent}{-0.5in}
\setlength{\leftskip}{0.5in}

<div id="refs" custom-style="Bibliography"></div>
\endgroup

\newpage
\setcounter{page}{1}
\renewcommand{\thesection}{\S \arabic{section}}
\renewcommand{\theHsection}{sisection. \arabic{section}}

# Supplementary information {-}

\setcounter{section}{0}

# Additional information about the SwehVd databasee

## Participant recruitment {#sec:recruitment}
Participants were recruited through word-of-mouth, flyers at Stockholm University Campus, and online channels (accindi.se). Figure \@ref(fig:flyer) is an example of flyers distributed at Stockholm University Campus. The flyer gives information on criteria for participation, recording procedure, reimbursement and contact information to experimenter (first author).

(ref:flyer) Example flyer for recruiting Stockholm Swedish talkers for recording of the SwehVd database.

```{r flyer, fig.cap="(ref:flyer)"}
include_graphics("ad_recruitment.png")
```

## Word list
Word list with all target and filler words, recorded by all talkers in the SwehVd database.

\begin{table}
\caption{\label{tab:word-list}Words recorded by the female talkers of Swedish for the SwehVd database}
\centering
\begin{tabular}[t]{c|c}
\hline
Target words&Vowel IPA\\
\hline
hid&`r linguisticsdown::cond_cmpl("[iː]")`\\
\hline
hidd&`r linguisticsdown::cond_cmpl("[ɪ]")`\\
\hline
hyd&`r linguisticsdown::cond_cmpl("[yː]")`\\
\hline
hydd&`r linguisticsdown::cond_cmpl("[ʏ]")`\\
\hline
hed&`r linguisticsdown::cond_cmpl("[eː]")`\\
\hline
hedd&`r linguisticsdown::cond_cmpl("[ɛ]")`\\
\hline
häd&`r linguisticsdown::cond_cmpl("[ɛː]")`\\
\hline
hädd&`r linguisticsdown::cond_cmpl("[ɛ]")`\\
\hline
härd&`r linguisticsdown::cond_cmpl("[æː]")`\\
\hline
härr&`r linguisticsdown::cond_cmpl("[æ]")`\\
\hline
höd&`r linguisticsdown::cond_cmpl("[øː]")`\\
\hline
hödd&`r linguisticsdown::cond_cmpl("[ø]")`\\
\hline
hörd&`r linguisticsdown::cond_cmpl("[œː]")`\\
\hline
hörr&`r linguisticsdown::cond_cmpl("[œ]")`\\
\hline
hud&`r linguisticsdown::cond_cmpl("[ʉː]")`\\
\hline
hudd&`r linguisticsdown::cond_cmpl("[ɵ]")`\\
\hline
hod&`r linguisticsdown::cond_cmpl("[uː]")`\\
\hline
hodd&`r linguisticsdown::cond_cmpl("[ʊ]")`\\
\hline
håd&`r linguisticsdown::cond_cmpl("[oː]")`\\
\hline
hådd&`r linguisticsdown::cond_cmpl("[ɔ]")`\\
\hline
had&`r linguisticsdown::cond_cmpl("[ɑː]")`\\
\hline
hadd&`r linguisticsdown::cond_cmpl("[a]")`\\
\hline
\end{tabular}
\hspace{2em}
\begin{tabular}[t]{c|c}
\hline
\multicolumn{2}{c}{Filler words}\\
\hline
titt&tand\\
\hline
damm&dipp\\
\hline
tå&buss\\
\hline
bål&ding\\
\hline
dill&porr\\
\hline
tugga&mitt\\
\hline
mat&dopp\\
\hline
norr&tal\\
\hline
must&namn\\
\hline
pil&pall\\
\hline
dina&bar\\
\hline
biff&till\\
\hline
Tina&mål\\
\hline
borr&Nina\\
\hline
dal&då\\
\hline
Pål&nick\\
\hline
nunna&ditt\\
\hline
mil&dugga\\
\hline
ting&mall\\
\hline
ball&bil\\
\hline
piff&par\\
\hline
tipp&morr\\
\hline
puss&nav\\
\hline
topp&nå\\
\end{tabular}
\end{table}

# Additional information for Study 1

## Evaluation of implementations of Syrdal & Gopal's (1986) second dimension {#sec:SG-eval}
For the second dimension, distinguishing between front and back vowels, @Syrdal1986 evaluates two different bark-difference measures: F2-F1 and F3-F2. Previous studies had concluded that F2-F1 distinguishes between all Swedish vowels [@fant1983], however, in @Syrdal1986's evaluation of American English, the F3-F2 dimension provided a better fit. Given that there seems to be language specific effects concerning @Syrdal1986's second dimension [e.g., @adank2003], here we compare the two difference measures for the vowels in the SwehVd database.

```{r}
levels.norm.SG <- c("Bark_SyrdalGopal", "Bark_SyrdalGopal2")
labels.norm.SG <-  c("SyrdalGopal (Bark)", "SyrdalGopal2 (Bark)")
levels.norm.plots.SG <- c("SyrdalGopal_Bark", "SyrdalGopal2_Bark")
p.separability.by_cue.SG <- plot_separability(d.SwehVd.forStudy.SI.long %>%
                                             filter(Cues %in% c("F0", "F1", "F2", "Duration", "F1F2"), Normalization.Type %in% c("SyrdalGopal (Bark)", "SyrdalGopal2 (Bark)")) %>%
                                             mutate(Normalization.Type = factor(plyr::mapvalues(Normalization.Type, levels.norm.SG, labels.norm.SG), levels = labels.norm.SG, ordered = T))) +
  scale_colour_manual(values =  c("#E6BE8A", "#E6BE8A")) +
  theme(
    axis.text.x = ggtext::element_markdown(angle = 60, vjust = 1, hjust=1, colour = "#E6BE8A")) +
  facet_grid(factor(Cues, levels = c("F1", "F2", "F0", "Duration", "F1F2"), labels = c("F1", "F2", "F0", "duration", "F1F2")) ~ factor(Quantity, levels = c("long vowels", "short vowels", "all vowels")), scales = "free_y")
```

(ref:separability-by-cue-SG) Separability indices of the two versions of the Syrdal & Gopal (1986) account for long vowels, short vowels, and long and short vowels together, shown for four of the five cues considered in this study and the combined F1-F2. Labels indicate mean across the five test folds. Intervals show average bootstrapped 95% confidence intervals across the test folds. Note that the ranges of the y-axes varies across plots.

Figure \@ref(fig:separability-by-cue-SG) displays the separability index for the two implementations. The first version uses the F2-F1 bark-difference metric for the second dimension, whereas the second version (labelled *SyrdalGopal2 (Bark)*) implements the second dimension as suggested by @Syrdal1986, F3-F2. As evident from Figure \@ref(fig:separability-by-cue-SG), the first implementation performs better at separating categories in the SwehVd data, which replicates @fant1983.

```{r separability-by-cue-SG, fig.width=base.width * 4, fig.height=base.height * 5.5, fig.align='center', out.height='90%', fig.cap="(ref:separability-by-cue-SG)"}
p.separability.by_cue.SG
```

```{r}
# Make talker-independent IOs on long and short vowels *separately*, for different cue combinations
m.io.SwehVd.F1F2_by_quantity.SG <-
  make_IOs_and_add_test_data(
    data = d.SwehVd.forStudy.long %>%
      filter(Normalization.Type %in% c("SyrdalGopal (Bark)", "SyrdalGopal2 (Bark)")),
    cues = c("F1", "F2"),
    separate_by = c("Quantity")) %>%
  mutate(IO.cue_normalization = ifelse(is.na(IO.cue_normalization), "SyrdalGopal2", "SyrdalGopal"))

# Make talker-independent IOs on long and short vowels *combined*, for different cue combinations
m.io.SwehVd.F1F2.SG <-
  make_IOs_and_add_test_data(
    data = d.SwehVd.forStudy.long %>%
      filter(Normalization.Type %in% c("SyrdalGopal (Bark)", "SyrdalGopal2 (Bark)")),
    cues = c("F1", "F2")) %>%
  # Add column for plotting
  mutate(
    IO.Quantity = "all",
    IO.cue_normalization = ifelse(is.na(IO.cue_normalization), "SyrdalGopal2", "SyrdalGopal"))

#Make combined dataframe for plotting
m.io.SwehVd.SG <- rbind(
  m.io.SwehVd.F1F2_by_quantity.SG %>%
    mutate(Cue_space = "F1-F2"),
  m.io.SwehVd.F1F2.SG %>%
    mutate(Cue_space = "F1-F2")) %>%
  mutate(Cue_space = factor(Cue_space, levels = c("F1-F2", "F1-F3", "F0-F3, duration")))

p.accuracy.io.overall.SG <- plot_io_results(m.io.SwehVd.SG) + facet_grid(Cue_space ~ factor(IO.Quantity, levels = c("long", "short", "all"), labels = c("long vowels", "short vowels", "all vowels"))) +
  scale_colour_manual(values =  c("#E6BE8A", "#E6BE8A")) +
  theme(
    axis.text.x = ggtext::element_markdown(angle = 60, vjust = 1, hjust=1, colour = "#E6BE8A"))
```
(ref:accuracy-SG) Predicted recognition accuracy of ideal observer under two versions of the Syrdal & Gopal (1986) account for long vowels, short vowels, and long and short vowels together, shown for the F1-F2 cue combination. Labels indicate mean across the five test folds. Intervals show average bootstrapped 95% confidence intervals across the test folds. The dashed horizontal line indicates chance (different across columns because of the different number of long and short vowels).

```{r accuracy-SG, fig.width=base.width * 5, fig.height=base.height * 2, fig.align='center', fig.cap="(ref:accuracy-SG)"}
p.accuracy.io.overall.SG
```

We also evaluated the two Syrdal & Gopal implementations in terms of model predictions for perception. Figure \@ref(fig:accuracy-SG) displays the categorization accuracy for models trained on normalized data under the two implementations of the Syrdal & Gopal account. Mirroring the results from the separability index, the first implementation using F2-F1 for the second dimension, outperforms the implementation using F3-F2 bark-difference measure. These results taken together indicate that the F2-F1 implementation is more suitable for the materials used here, we therefore decided to use the first implementation throughout this paper.

\newpage

## Correlation matrices for all normalization accounts {#sec:correlation-matrices}
Here we include correlation matrices for the SwehVd vowel data, transformed into the 15 different normalization spaces.

(ref:correlation-matrix-Mel) The SwehVd vowel data in Mel space. Points show repetitions of each of the 21 Swedish vowels by 16 female native talkers in the database in F0-F3 and vowel duration cue space. Vowel labels indicate category means across talkers. Long vowels are boldfaced. Ellipses show bivariate Gaussian 95% confidence interval of category means.

```{r correlation-matrix-Mel, fig.width=base.width*3.5, fig.height=base.height*3.5+.5, fig.cap="(ref:correlation-matrix-Mel)"}
p.matrix.cues %+%
  (d.SwehVd.forStudy.long %>%
  filter(fold_type == "test" & Normalization.Type == "transformed (Mel)"))
```

(ref:correlation-matrix-Bark) The SwehVd vowel data in Bark space. Points show repetitions of each of the 21 Swedish vowels by 16 female native talkers in the database in F0-F3 and vowel duration cue space. Vowel labels indicate category means across talkers. Long vowels are boldfaced. Ellipses show bivariate Gaussian 95% confidence interval of category means.

```{r correlation-matrix-Bark, fig.width=base.width*3.5, fig.height=base.height*3.5+.5, fig.cap="(ref:correlation-matrix-Bark)"}
p.matrix.cues %+%
  (d.SwehVd.forStudy.long %>%
  filter(fold_type == "test" & Normalization.Type == "transformed (Bark)"))
```

(ref:correlation-matrix-ERB) The SwehVd vowel data in ERB space. Points show repetitions of each of the 21 Swedish vowels by 16 female native talkers in the database in F0-F3 and vowel duration cue space. Vowel labels indicate category means across talkers. Long vowels are boldfaced. Ellipses show bivariate Gaussian 95% confidence interval of category means.

```{r correlation-matrix-ERB, fig.width=base.width*3.5, fig.height=base.height*3.5+.5, fig.cap="(ref:correlation-matrix-ERB)"}
p.matrix.cues %+%
  (d.SwehVd.forStudy.long %>%
  filter(fold_type == "test" & Normalization.Type == "transformed (ERB)"))
```

(ref:correlation-matrix-semitones) The SwehVd vowel data in semitones space. Points show repetitions of each of the 21 Swedish vowels by 16 female native talkers in the database in F0-F3 and vowel duration cue space. Vowel labels indicate category means across talkers. Long vowels are boldfaced. Ellipses show bivariate Gaussian 95% confidence interval of category means.

```{r correlation-matrix-semitones, fig.width=base.width*3.5, fig.height=base.height*3.5+.5, fig.cap="(ref:correlation-matrix-semitones)"}
p.matrix.cues %+%
  (d.SwehVd.forStudy.long %>%
  filter(fold_type == "test" & Normalization.Type == "transformed (semitones)"))
```

(ref:correlation-matrix-syrdalgopal) The SwehVd vowel data in SyrdalGopal (Bark) space. Points show repetitions of each of the 21 Swedish vowels by 16 female native talkers in the database in F0-F3 and vowel duration cue space. Vowel labels indicate category means across talkers. Long vowels are boldfaced. Ellipses show bivariate Gaussian 95% confidence interval of category means.

```{r correlation-matrix-syrdalgopal, fig.width=base.width*3.5, fig.height=base.height*3.5+.5, fig.cap="(ref:correlation-matrix-syrdalgopal)"}
p.matrix.cues %+%
  (d.SwehVd.forStudy.long %>%
  filter(fold_type == "test" & Normalization.Type == "SyrdalGopal (Bark)"))
```

(ref:correlation-matrix-miller) The SwehVd vowel data in Miller (log) space. Points show repetitions of each of the 21 Swedish vowels by 16 female native talkers in the database in F0-F3 and vowel duration cue space. Vowel labels indicate category means across talkers. Long vowels are boldfaced. Ellipses show bivariate Gaussian 95% confidence interval of category means.

```{r correlation-matrix-miller, fig.width=base.width*3.5, fig.height=base.height*3.5+.5, fig.cap="(ref:correlation-matrix-miller)"}
p.matrix.cues %+%
  (d.SwehVd.forStudy.long %>%
  filter(fold_type == "test" & Normalization.Type == "Miller (log)"))
```
(ref:correlation-matrix-ccure-hz) The SwehVd vowel data in C-CuRE Hz space. Points show repetitions of each of the 21 Swedish vowels by 16 female native talkers in the database in F0-F3 and vowel duration cue space. Vowel labels indicate category means across talkers. Long vowels are boldfaced. Ellipses show bivariate Gaussian 95% confidence interval of category means.

```{r correlation-matrix-ccure-hz, fig.width=base.width*3.5, fig.height=base.height*3.5+.5, fig.cap="(ref:correlation-matrix-ccure-hz)"}
p.matrix.cues %+%
  (d.SwehVd.forStudy.long %>%
  filter(fold_type == "test" & Normalization.Type == "C-CuRE (Hz)"))
```

(ref:correlation-matrix-ccure-mel) The SwehVd vowel data in C-CuRE Mel space. Points show repetitions of each of the 21 Swedish vowels by 16 female native talkers in the database in F0-F3 and vowel duration cue space. Vowel labels indicate category means across talkers. Long vowels are boldfaced. Ellipses show bivariate Gaussian 95% confidence interval of category means.

```{r correlation-matrix-ccure-mel, fig.width=base.width*3.5, fig.height=base.height*3.5+.5, fig.cap="(ref:correlation-matrix-ccure-mel)"}
p.matrix.cues %+%
  (d.SwehVd.forStudy.long %>%
  filter(fold_type == "test" & Normalization.Type == "C-CuRE (Mel)"))
```

(ref:correlation-matrix-ccure-bark) The SwehVd vowel data in C-CuRE Bark space. Points show repetitions of each of the 21 Swedish vowels by 16 female native talkers in the database in F0-F3 and vowel duration cue space. Vowel labels indicate category means across talkers. Long vowels are boldfaced. Ellipses show bivariate Gaussian 95% confidence interval of category means.

```{r correlation-matrix-ccure-bark, fig.width=base.width*3.5, fig.height=base.height*3.5+.5, fig.cap="(ref:correlation-matrix-ccure-bark)"}
p.matrix.cues %+%
  (d.SwehVd.forStudy.long %>%
  filter(fold_type == "test" & Normalization.Type == "C-CuRE (Bark)"))
```

(ref:correlation-matrix-ccure-erb) The SwehVd vowel data in C-CuRE ERB space. Points show repetitions of each of the 21 Swedish vowels by 16 female native talkers in the database in F0-F3 and vowel duration cue space. Vowel labels indicate category means across talkers. Long vowels are boldfaced. Ellipses show bivariate Gaussian 95% confidence interval of category means.

```{r correlation-matrix-ccure-erb, fig.width=base.width*3.5, fig.height=base.height*3.5+.5, fig.cap="(ref:correlation-matrix-ccure-erb)"}
p.matrix.cues %+%
  (d.SwehVd.forStudy.long %>%
  filter(fold_type == "test" & Normalization.Type == "C-CuRE (ERB)"))
```

(ref:correlation-matrix-ccure-semitones) The SwehVd vowel data in C-CuRE semitones space. Points show repetitions of each of the 21 Swedish vowels by 16 female native talkers in the database in F0-F3 and vowel duration cue space. Vowel labels indicate category means across talkers. Long vowels are boldfaced. Ellipses show bivariate Gaussian 95% confidence interval of category means.

```{r correlation-matrix-ccure-semitones, fig.width=base.width*3.5, fig.height=base.height*3.5+.5, fig.cap="(ref:correlation-matrix-ccure-semitones)"}
p.matrix.cues %+%
  (d.SwehVd.forStudy.long %>%
  filter(fold_type == "test" & Normalization.Type == "C-CuRE (semitones)"))
```

(ref:correlation-matrix-nearey1) The SwehVd vowel data in Nearey1 (log) space. Points show repetitions of each of the 21 Swedish vowels by 16 female native talkers in the database in F0-F3 and vowel duration cue space. Vowel labels indicate category means across talkers. Long vowels are boldfaced. Ellipses show bivariate Gaussian 95% confidence interval of category means.

```{r correlation-matrix-nearey1, fig.width=base.width*3.5, fig.height=base.height*3.5+.5, fig.cap="(ref:correlation-matrix-nearey1)"}
p.matrix.cues %+%
  (d.SwehVd.forStudy.long %>%
  filter(fold_type == "test" & Normalization.Type == "Nearey1 (log)"))
```

(ref:correlation-matrix-nearey2) The SwehVd vowel data in Nearey2 (log) space. Points show repetitions of each of the 21 Swedish vowels by 16 female native talkers in the database in F0-F3 and vowel duration cue space. Vowel labels indicate category means across talkers. Long vowels are boldfaced. Ellipses show bivariate Gaussian 95% confidence interval of category means.

```{r correlation-matrix-nearey2, fig.width=base.width*3.5, fig.height=base.height*3.5+.5, fig.cap="(ref:correlation-matrix-nearey2)"}
p.matrix.cues %+%
  (d.SwehVd.forStudy.long %>%
  filter(fold_type == "test" & Normalization.Type == "Nearey2 (log)"))
```

(ref:correlation-matrix-gerstman) The SwehVd vowel data in Gerstman (Hz) space. Points show repetitions of each of the 21 Swedish vowels by 16 female native talkers in the database in F0-F3 and vowel duration cue space. Vowel labels indicate category means across talkers. Long vowels are boldfaced. Ellipses show bivariate Gaussian 95% confidence interval of category means.

```{r correlation-matrix-gerstman, fig.width=base.width*3.5, fig.height=base.height*3.5+.5, fig.cap="(ref:correlation-matrix-gerstman)"}
p.matrix.cues %+%
  (d.SwehVd.forStudy.long %>%
  filter(fold_type == "test" & Normalization.Type == "Gerstman (Hz)"))
```

(ref:correlation-matrix-lobanov) The SwehVd vowel data in Lobanov (Hz) space. Points show repetitions of each of the 21 Swedish vowels by 16 female native talkers in the database in F0-F3 and vowel duration cue space. Vowel labels indicate category means across talkers. Long vowels are boldfaced. Ellipses show bivariate Gaussian 95% confidence interval of category means.

```{r correlation-matrix-lobanov,fig.width=base.width*3.5, fig.height=base.height*3.5+.5, fig.cap="(ref:correlation-matrix-lobanov)"}
p.matrix.cues %+%
  (d.SwehVd.forStudy.long %>%
  filter(fold_type == "test" & Normalization.Type == "Lobanov (Hz)"))
```
\newpage

# Additional information for Study 2

## Per-vowel categorization accuracy of models trained on long and short vowels separately {#sec:accuracy-per-vowel}

```{r}
#Do multiple plots because of plot size
p.accuracy.io.per.vowel.long.1 <- plot_io_results_per_vowel(
  m.io.SwehVd %>%
    filter(IO.Quantity == "long") %>%
    nplyr::nest_filter(posterior_of_intended_vowel, Intended.Vowel %in% c("[iː]", "[yː]", "[ʉː]", "[eː]", "[ɛː]"))) +
  facet_grid(Cue_space ~  factor(Intended.Vowel, levels = levels.vowel.IPA.swe))
p.accuracy.io.per.vowel.long.2 <- plot_io_results_per_vowel(
  m.io.SwehVd %>%
    filter(IO.Quantity == "long") %>%
    nplyr::nest_filter(posterior_of_intended_vowel, Intended.Vowel %in% c("[æː]", "[øː]", "[œː]", "[ɑː]", "[oː]", "[uː]"))) +
  facet_grid(Cue_space ~  factor(Intended.Vowel, levels = levels.vowel.IPA.swe))

axis.title.accuracy <- grid::textGrob("Accuracy (of predicting *intended* vowel)", gp=grid::gpar(fontface="bold", fontsize=8), rot=90)

p.accuracy.io.per.vowel.short.1 <- plot_io_results_per_vowel(
  m.io.SwehVd %>%
    filter(IO.Quantity == "short") %>%
    nplyr::nest_filter(posterior_of_intended_vowel, Intended.Vowel %in% c("[ɪ]", "[ʏ]", "[ɵ]", "[ɛ]", "[æ]"))) +
  facet_grid(Cue_space ~  factor(Intended.Vowel, levels = levels.vowel.IPA.swe)) + theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), axis.title.y = element_blank())
p.accuracy.io.per.vowel.short.2 <- plot_io_results_per_vowel(
  m.io.SwehVd %>%
    filter(IO.Quantity == "short") %>%
    nplyr::nest_filter(posterior_of_intended_vowel, Intended.Vowel %in% c("[ø]", "[œ]", "[a]", "[ɔ]", "[ʊ]"))) +
  facet_grid(Cue_space ~  factor(Intended.Vowel, levels = levels.vowel.IPA.swe))

p.accuracy.io.per.vowel.all.1 <- plot_io_results_per_vowel(
  m.io.SwehVd %>%
    filter(IO.Quantity == "all") %>%
    nplyr::nest_filter(posterior_of_intended_vowel, Intended.Vowel %in% c("[iː]", "[ɪ]", "[yː]", "[ʏ]", "[ʉː]"))) +
  facet_grid(Cue_space ~  factor(Intended.Vowel, levels = levels.vowel.IPA.swe)) + theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), axis.title.y = element_blank())
p.accuracy.io.per.vowel.all.2 <- plot_io_results_per_vowel(
  m.io.SwehVd %>%
    filter(IO.Quantity == "all") %>%
    nplyr::nest_filter(posterior_of_intended_vowel, Intended.Vowel %in% c("[ɵ]", "[eː]", "[ɛ]", "[ɛː]", "[æː]"))) +
  facet_grid(Cue_space ~  factor(Intended.Vowel, levels = levels.vowel.IPA.swe))
p.accuracy.io.per.vowel.all.3 <- plot_io_results_per_vowel(
  m.io.SwehVd %>%
    filter(IO.Quantity == "all") %>%
    nplyr::nest_filter(posterior_of_intended_vowel, Intended.Vowel %in% c("[æ]", "[øː]", "[ø]", "[œː]", "[œ]"))) +
  facet_grid(Cue_space ~  factor(Intended.Vowel, levels = levels.vowel.IPA.swe)) + theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), axis.title.y = element_blank())
p.accuracy.io.per.vowel.all.4 <- plot_io_results_per_vowel(
  m.io.SwehVd %>%
    filter(IO.Quantity == "all") %>%
    nplyr::nest_filter(posterior_of_intended_vowel, Intended.Vowel %in% c("[ɑː]", "[a]", "[oː]", "[ɔ]", "[uː]", "[ʊ]"))) +
  facet_grid(Cue_space ~  factor(Intended.Vowel, levels = levels.vowel.IPA.swe))
```
(ref:predictions-per-vowel-long) Per-vowel predicted categorization accuracy of the ideal observers trained on the **long** vowels, under different assumptions about the relevant cues. Point ranges indicate the average mean accuracy and average 95% bootstrapped CI across the five folds. Chance level is indicated by grey line.

\begin{landscape}

```{r predictions-per-vowel-long, fig.width=base.width * 5, fig.height=base.height * 3, fig.align='center', fig.cap="(ref:predictions-per-vowel-long)"}
p.accuracy.io.per.vowel.long.1
```
\end{landscape}

(ref:predictions-per-vowel-long-2) (*Continued from last page*)Per-vowel predicted categorization accuracy of the ideal observers trained on the **long** vowels, under different assumptions about the relevant cues. Point ranges indicate the average mean accuracy and average 95% bootstrapped CI across the five folds. Chance level is indicated by grey line.

\begin{landscape}

```{r predictions-per-vowel-long-2, fig.width=base.width * 5, fig.height=base.height * 3, fig.align='center', fig.cap="(ref:predictions-per-vowel-long-2)"}
p.accuracy.io.per.vowel.long.2
```
\end{landscape}

(ref:predictions-per-vowel-short) Per-vowel predicted categorization accuracy of the ideal observers trained on the **short** vowels, under different assumptions about the relevant cues. Point ranges indicate the average mean accuracy and average 95% bootstrapped CI across the five folds. Chance level is indicated by grey line.

```{r predictions-per-vowel-short, fig.width=base.width * 4, fig.height=base.height * 5, fig.align='center', fig.cap="(ref:predictions-per-vowel-short)"}
p.accuracy.io.per.vowel.short <- cowplot::plot_grid(p.accuracy.io.per.vowel.short.1, NULL, p.accuracy.io.per.vowel.short.2 + theme(axis.title.y = element_blank()), ncol = 1, align = "hv", axis = "l", rel_heights = c(1,-.15,1))
gridExtra::grid.arrange(gridExtra::arrangeGrob(p.accuracy.io.per.vowel.short, left = axis.title.accuracy))
```

(ref:predictions-per-vowel-all-1) Per-vowel predicted categorization accuracy of the ideal observers trained on **all** vowels, under different assumptions about the relevant cues. Point ranges indicate the average mean accuracy and average 95% bootstrapped CI across the five folds. Chance level is indicated by grey line.

```{r predictions-per-vowel-all-1, fig.width=base.width * 4, fig.height=base.height * 5, fig.align='center', fig.cap="(ref:predictions-per-vowel-all-1)"}
p.accuracy.io.per.vowel.all.first <- cowplot::plot_grid(p.accuracy.io.per.vowel.all.1, NULL, p.accuracy.io.per.vowel.all.2 + theme(axis.title.y = element_blank()), ncol = 1, align = "hv", axis = "l", rel_heights = c(1,-.15,1))
gridExtra::grid.arrange(gridExtra::arrangeGrob(p.accuracy.io.per.vowel.all.first, left = axis.title.accuracy))
```

(ref:predictions-per-vowel-all-2) (*Continued from last page*)Per-vowel predicted categorization accuracy of the ideal observers trained on **all** vowels, under different assumptions about the relevant cues. Point ranges indicate the average mean accuracy and average 95% bootstrapped CI across the five folds. Chance level is indicated by grey line.

```{r predictions-per-vowel-all-2, fig.width=base.width * 4.5, fig.height=base.height * 5, fig.align='center', fig.cap="(ref:predictions-per-vowel-all-2)"}
p.accuracy.io.per.vowel.all.second <- cowplot::plot_grid(
  cowplot::plot_grid(p.accuracy.io.per.vowel.all.3, NULL, rel_widths = c(5/6, 1/6), align = "hv", axis = "l"),
                     p.accuracy.io.per.vowel.all.4 + theme(axis.title.y = element_blank()), ncol = 1, align = "hv", axis = "l", rel_heights = c(3/7, 3.5/7))
gridExtra::grid.arrange(gridExtra::arrangeGrob(p.accuracy.io.per.vowel.all.second, left = axis.title.accuracy))
```

\newpage

## Confusion and difference matrices of ideal observers {#sec:confusion}
To further explore effects of neighbouring categories, and which categories are more easily confused by the models and with what, we plot confusion matrices of the worst and best performing models trained on the long, short or all Swedish vowels, under the different assumptions about the relevant cues. Next to the confusion matrices, we plot difference matrices to facilitate comparison.

```{r, echo=FALSE}
# Keep code for reproducibility
# run a model assessing the difference in performance between models as a function of the normalization scheme.
# data.io <- m.io.SwehVd.F1F2 %>%
#   unnest(posterior_of_intended_vowel) %>%
#   mutate(IO.Normalization.Type = factor(IO.Normalization.Type, levels = levels.normalization.plots, labels = labels.normalization))

#Add treatment coding for IO.Normalization.Type
#contrasts(data.io$IO.Normalization.Type) = contr.treatment(16)
# # contrasts(data.io$IO.cue_normalization) = cbind(
# #   "C-CuRE Hz" = c(0, 1, 0, 0, 0, 0, 0),
# #   "Lobanov Hz" = c(0, 0, 1, 0, 0, 0, 0),
# #   "Gerstman Hz" = c(0, 0, 0, 1, 0, 0, 0),
# #   "Nearey1 log" = c(0, 0, 0, 0, 1, 0, 0),
# #   "Nearey2 log" = c(0, 0, 0, 0, 0, 1, 0),
# #   "Miller log" = c(0, 0, 0, 0, 0, 0, 1))
# 
# model <- glm(Posterior ~ IO.Normalization.Type, family=gaussian, data = data.io)
# summary(model)
```
```{r}
plot_io_confusion <- function(
  data,
  cols = cols) {
  data %>%
    unnest(posterior_of_all_vowels) %>%
    pivot_longer(
    cols = cols,
    values_to = "Posterior",
    names_to = "IO.Vowel") %>%
    { if ("IO.Quantity" %in% names(data)) group_by(., IO.Vowel, Intended.Vowel, IO.Normalization.Type, IO.Quantity, Cue_space) else group_by(., IO.Vowel, Intended.Vowel, IO.Normalization.Type, Cue_space) } %>%
    summarise(across(.cols = Posterior, mean, na.rm = T)) %>%
    ggplot(
      aes(
        x = factor(Intended.Vowel, levels = levels.vowel.IPA.swe),
        y = factor(IO.Vowel, levels = levels.vowel.IPA.swe),
        fill = Posterior)) +
    geom_raster() +
    scale_x_discrete("Intended vowel", expand = c(0,0)) +
    scale_y_discrete("IO response vowel", expand = c(0,0)) +
    scale_fill_viridis_b("Posterior \nprobability \nunder \nideal observer", limits = c(0,1), breaks = seq(0, 1, .1)) +
    facet_grid(Cue_space ~ IO.Normalization.Type) +
    theme(axis.title.x = element_blank(), 
          axis.title.y = element_blank())
}
```

```{r }
# Make confusion matrices of best and worst for all cue evaluations under the assumption of long, short or all vowels
p.confusion.long.F1F2 <- plot_io_confusion(
  m.io.SwehVd %>% filter(IO.Normalization.Type %in% c("Miller_log", "Lobanov_Hz"), Cue_space == "F1-F2", IO.Quantity == "long"),
                         cols = levels.vowel.IPA.swe.long) +
    facet_grid(Cue_space ~ factor(IO.Normalization.Type, levels = c("Miller_log", "Lobanov_Hz"), labels = c("Miller (log)", "Lobanov (Hz)"))) + theme(legend.position="none")
p.confusion.long.F1F3 <- plot_io_confusion(
  m.io.SwehVd %>% filter(IO.Normalization.Type %in% c("Miller_log", "Lobanov_Hz"), Cue_space == "F1-F3", IO.Quantity == "long"),
                         cols = levels.vowel.IPA.swe.long) +
    facet_grid(Cue_space ~ factor(IO.Normalization.Type, levels = c("Miller_log", "Lobanov_Hz"), labels = c("Miller (log)", "Lobanov (Hz)"))) + theme(legend.position="none")
p.confusion.long.all <- plot_io_confusion(
  m.io.SwehVd %>% filter(IO.Normalization.Type %in% c("Gerstman_Hz", "Lobanov_Hz"), Cue_space == "F0-F3, duration", IO.Quantity == "long"),
                         cols = levels.vowel.IPA.swe.long) +
    facet_grid(Cue_space ~ factor(IO.Normalization.Type, levels = c("Gerstman_Hz", "Lobanov_Hz"), labels = c("Gerstman (Hz)", "Lobanov (Hz)"))) + theme(legend.position="none")

p.confusion.short.F1F2 <- plot_io_confusion(
  m.io.SwehVd %>% filter(IO.Normalization.Type %in% c("Miller_log", "CCuRE_Mel"), Cue_space == "F1-F2", IO.Quantity == "short"),
                         cols = levels.vowel.IPA.swe.short) +
    facet_grid(Cue_space ~ factor(IO.Normalization.Type, levels = c("Miller_log", "CCuRE_Mel"), labels = c("Miller (log)", "C-CuRE (Mel)"))) + theme(legend.position="none")
p.confusion.short.F1F3 <- plot_io_confusion(
  m.io.SwehVd %>% filter(IO.Normalization.Type %in% c("Miller_log", "CCuRE_Mel"), Cue_space == "F1-F3", IO.Quantity == "short"),
                         cols = levels.vowel.IPA.swe.short) +
    facet_grid(Cue_space ~ factor(IO.Normalization.Type, levels = c("Miller_log", "CCuRE_Mel"), labels = c("Miller (log)", "C-CuRE (Mel)"))) + theme(legend.position="none")
p.confusion.short.all <- plot_io_confusion(
  m.io.SwehVd %>% filter(IO.Normalization.Type %in% c("Gerstman_Hz", "Lobanov_Hz"), Cue_space == "F0-F3, duration", IO.Quantity == "short"),
                         cols = levels.vowel.IPA.swe.short) +
    facet_grid(Cue_space ~ factor(IO.Normalization.Type,  levels = c("Gerstman_Hz", "Lobanov_Hz"), labels = c("Gerstman (Hz)", "Lobanov (Hz)"))) + theme(legend.position="none")

p.confusion.all.F1F2 <- plot_io_confusion(
  m.io.SwehVd %>% filter(IO.Normalization.Type %in% c("SyrdalGopal_Bark", "Lobanov_Hz"), Cue_space == "F1-F2", IO.Quantity == "all"),
                         cols = levels.vowel.IPA.swe) +
    facet_grid(Cue_space ~ factor(IO.Normalization.Type, levels = c("SyrdalGopal_Bark", "Lobanov_Hz"), labels = c("SyrdalGopal (bark)", "Lobanov (Hz)"))) + theme(legend.position="none")
p.confusion.all.F1F3 <- plot_io_confusion(
    m.io.SwehVd %>% filter(IO.Normalization.Type %in% c("Miller_log", "Lobanov_Hz"), Cue_space == "F1-F3", IO.Quantity == "all"), 
    cols = levels.vowel.IPA.swe) + 
  facet_grid(Cue_space ~ factor(IO.Normalization.Type, levels = c("Miller_log", "Lobanov_Hz"), labels = c("Miller (log)", "Lobanov (Hz)"))) + theme(legend.position="none")
p.confusion.all.all <- plot_io_confusion(
  m.io.SwehVd %>% filter(IO.Normalization.Type %in% c("Gerstman_Hz", "CCuRE_Hz"), Cue_space == "F0-F3, duration", IO.Quantity == "all"),
                         cols = levels.vowel.IPA.swe) +
    facet_grid(Cue_space ~ factor(IO.Normalization.Type, levels = c("Gerstman_Hz", "CCuRE_Hz"), labels = c("Gerstman (Hz)", "C-CuRE (Hz)")))

legend.confusion <- cowplot::get_legend(p.confusion.all.all +
  guides(fill = guide_legend(ncol = 1)))

# Plot a difference matrix, of differences in posteriors between worst and best performing models
# Diff matrices of the long vowels
p.diff.long.F1F2 <- p.confusion.long.F1F2 %+%
  (m.io.SwehVd %>%
    unnest(posterior_of_all_vowels) %>%
    pivot_longer(
    cols = levels.vowel.IPA.swe.long,
    values_to = "Posterior",
    names_to = "IO.Vowel") %>%
    filter(Cue_space == "F1-F2", IO.Quantity == "long") %>%
    group_by(IO.Normalization.Type, IO.Vowel, Intended.Vowel) %>%
    summarise_at(vars(Posterior), mean) %>%
    pivot_wider(
      names_from = IO.Normalization.Type,
      values_from = Posterior) %>%
    mutate(
      "Difference Lobanov (Hz) - Miller (log)" = Lobanov_Hz - Miller_log) %>%
    select(starts_with("Diff"), IO.Vowel, Intended.Vowel) %>%
    pivot_longer(
         cols = starts_with("Diff"),
         names_to = "Comparison",
         values_to = "Difference")) +
    aes(fill = Difference) +
    scale_fill_gradient2("Difference in posterior probability", limits = c(-.25,.25), breaks = seq(-.25, .25, .05)) +
    facet_wrap(~ Comparison, ncol = 1) + 
  theme(legend.position = "none")
p.diff.long.F1F3 <- p.confusion.long.F1F3 %+%
  (m.io.SwehVd %>%
    unnest(posterior_of_all_vowels) %>%
    pivot_longer(
    cols = levels.vowel.IPA.swe.long,
    values_to = "Posterior",
    names_to = "IO.Vowel") %>%
    filter(Cue_space == "F1-F3", IO.Quantity == "long") %>%
    group_by(IO.Normalization.Type, IO.Vowel, Intended.Vowel) %>%
    summarise_at(vars(Posterior), mean) %>%
    pivot_wider(
      names_from = IO.Normalization.Type,
      values_from = Posterior) %>%
    mutate(
      "Difference Lobanov (Hz) - Miller (log)" = Lobanov_Hz - Miller_log) %>%
    select(starts_with("Diff"), IO.Vowel, Intended.Vowel) %>%
    pivot_longer(
         cols = starts_with("Diff"),
         names_to = "Comparison",
         values_to = "Difference")) +
    aes(fill = Difference) +
    scale_fill_gradient2("Difference in posterior probability", limits = c(-.25,.25), breaks = seq(-.25, .25, .05)) +
    facet_wrap(~ Comparison, ncol = 1) + 
  theme(legend.position = "none")
p.diff.long.all <- p.confusion.long.all %+%
  (m.io.SwehVd %>%
    unnest(posterior_of_all_vowels) %>%
    pivot_longer(
    cols = levels.vowel.IPA.swe.long,
    values_to = "Posterior",
    names_to = "IO.Vowel") %>%
    filter(Cue_space == "F0-F3, duration", IO.Quantity == "long") %>%
    group_by(IO.Normalization.Type, IO.Vowel, Intended.Vowel) %>%
    summarise_at(vars(Posterior), mean) %>%
    pivot_wider(
      names_from = IO.Normalization.Type,
      values_from = Posterior) %>%
    mutate(
      "Difference Lobanov (Hz) - Gerstman (Hz)" = Lobanov_Hz - Gerstman_Hz) %>%
    select(starts_with("Diff"), IO.Vowel, Intended.Vowel) %>%
    pivot_longer(
         cols = starts_with("Diff"),
         names_to = "Comparison",
         values_to = "Difference")) +
    aes(fill = Difference) +
    scale_fill_gradient2("Difference in posterior probability", limits = c(-.25,.25), breaks = seq(-.25, .25, .05)) +
    facet_wrap(~ Comparison, ncol = 1) + 
  theme(legend.position = "none")
# Diff matrices of the short vowels
p.diff.short.F1F2 <- p.confusion.short.F1F2 %+%
  (m.io.SwehVd %>%
    unnest(posterior_of_all_vowels) %>%
    pivot_longer(
    cols = levels.vowel.IPA.swe.short,
    values_to = "Posterior",
    names_to = "IO.Vowel") %>%
    filter(Cue_space == "F1-F2", IO.Quantity == "short") %>%
    group_by(IO.Normalization.Type, IO.Vowel, Intended.Vowel) %>%
    summarise_at(vars(Posterior), mean) %>%
    pivot_wider(
      names_from = IO.Normalization.Type,
      values_from = Posterior) %>%
    mutate(
      "Difference C-CuRE (Mel) - Miller (log)" = CCuRE_Mel - Miller_log) %>%
    select(starts_with("Diff"), IO.Vowel, Intended.Vowel) %>%
    pivot_longer(
         cols = starts_with("Diff"),
         names_to = "Comparison",
         values_to = "Difference")) +
    aes(fill = Difference) +
    scale_fill_gradient2("Difference in posterior probability", limits = c(-.25,.25), breaks = seq(-.25, .25, .05)) +
    facet_wrap(~ Comparison, ncol = 1) + 
  theme(legend.position = "none")
p.diff.short.F1F3 <- p.confusion.short.F1F3 %+%
  (m.io.SwehVd %>%
    unnest(posterior_of_all_vowels) %>%
    pivot_longer(
    cols = levels.vowel.IPA.swe.short,
    values_to = "Posterior",
    names_to = "IO.Vowel") %>%
    filter(Cue_space == "F1-F3", IO.Quantity == "short") %>%
    group_by(IO.Normalization.Type, IO.Vowel, Intended.Vowel) %>%
    summarise_at(vars(Posterior), mean) %>%
    pivot_wider(
      names_from = IO.Normalization.Type,
      values_from = Posterior) %>%
    mutate(
      "Difference C-CuRE (Mel) - Miller (log)" = CCuRE_Mel - Miller_log) %>%
    select(starts_with("Diff"), IO.Vowel, Intended.Vowel) %>%
    pivot_longer(
         cols = starts_with("Diff"),
         names_to = "Comparison",
         values_to = "Difference")) +
    aes(fill = Difference) +
    scale_fill_gradient2("Difference in posterior probability", limits = c(-.25,.25), breaks = seq(-.25, .25, .05)) +
    facet_wrap(~ Comparison, ncol = 1) + 
  theme(legend.position = "none")
p.diff.short.all <- p.confusion.short.all %+%
  (m.io.SwehVd %>%
    unnest(posterior_of_all_vowels) %>%
    pivot_longer(
    cols = levels.vowel.IPA.swe.short,
    values_to = "Posterior",
    names_to = "IO.Vowel") %>%
    filter(Cue_space == "F0-F3, duration", IO.Quantity == "short") %>%
    group_by(IO.Normalization.Type, IO.Vowel, Intended.Vowel) %>%
    summarise_at(vars(Posterior), mean) %>%
    pivot_wider(
      names_from = IO.Normalization.Type,
      values_from = Posterior) %>%
    mutate(
      "Difference Lobanov (Hz) - Gerstman (Hz)" = Lobanov_Hz - Gerstman_Hz) %>%
    select(starts_with("Diff"), IO.Vowel, Intended.Vowel) %>%
    pivot_longer(
         cols = starts_with("Diff"),
         names_to = "Comparison",
         values_to = "Difference")) +
    aes(fill = Difference) +
    scale_fill_gradient2("Difference in posterior probability", limits = c(-.25,.25), breaks = seq(-.25, .25, .05)) +
    facet_wrap(~ Comparison, ncol = 1) + 
  theme(legend.position = "none")
# Diff matrices of all vowels
p.diff.all.F1F2 <- p.confusion.all.F1F2 %+%
  (m.io.SwehVd %>%
    unnest(posterior_of_all_vowels) %>%
    pivot_longer(
    cols = levels.vowel.IPA.swe,
    values_to = "Posterior",
    names_to = "IO.Vowel") %>%
    filter(Cue_space == "F1-F2", IO.Quantity == "all") %>%
    group_by(IO.Normalization.Type, IO.Vowel, Intended.Vowel) %>%
    summarise_at(vars(Posterior), mean) %>%
    pivot_wider(
      names_from = IO.Normalization.Type,
      values_from = Posterior) %>%
    mutate(
      "Difference Lobanov (Hz) - SyrdalGopal (Bark)" = Lobanov_Hz - SyrdalGopal_Bark) %>%
    select(starts_with("Diff"), IO.Vowel, Intended.Vowel) %>%
    pivot_longer(
         cols = starts_with("Diff"),
         names_to = "Comparison",
         values_to = "Difference")) +
    aes(fill = Difference) +
    scale_fill_gradient2("Difference in posterior probability", limits = c(-.25,.25), breaks = seq(-.25, .25, .05)) +
    facet_wrap(~ Comparison, ncol = 1) + 
  theme(legend.position = "none")
p.diff.all.F1F3 <- p.confusion.all.F1F3 %+%
  (m.io.SwehVd %>%
    unnest(posterior_of_all_vowels) %>%
    pivot_longer(
    cols = levels.vowel.IPA.swe,
    values_to = "Posterior",
    names_to = "IO.Vowel") %>%
    filter(Cue_space == "F1-F3", IO.Quantity == "all") %>%
    group_by(IO.Normalization.Type, IO.Vowel, Intended.Vowel) %>%
    summarise_at(vars(Posterior), mean) %>%
    pivot_wider(
      names_from = IO.Normalization.Type,
      values_from = Posterior) %>%
    mutate(
      "Difference Lobanov (Hz) - Miller (log)" = Lobanov_Hz - Miller_log) %>%
    select(starts_with("Diff"), IO.Vowel, Intended.Vowel) %>%
    pivot_longer(
         cols = starts_with("Diff"),
         names_to = "Comparison",
         values_to = "Difference")) +
    aes(fill = Difference) +
    scale_fill_gradient2("Difference in posterior probability", limits = c(-.25,.25), breaks = seq(-.25, .25, .05)) +
    facet_wrap(~ Comparison, ncol = 1) + 
  theme(legend.position = "none")
p.diff.all.all <- p.confusion.all.all %+%
  (m.io.SwehVd %>%
    unnest(posterior_of_all_vowels) %>%
    pivot_longer(
    cols = levels.vowel.IPA.swe,
    values_to = "Posterior",
    names_to = "IO.Vowel") %>%
    filter(Cue_space == "F0-F3, duration", IO.Quantity == "all") %>%
    group_by(IO.Normalization.Type, IO.Vowel, Intended.Vowel) %>%
    summarise_at(vars(Posterior), mean) %>%
    pivot_wider(
      names_from = IO.Normalization.Type,
      values_from = Posterior) %>%
    mutate(
      "Difference C-CuRE (Hz) - Gerstman (Hz)" = CCuRE_Hz - Gerstman_Hz) %>%
    select(starts_with("Diff"), IO.Vowel, Intended.Vowel) %>%
    pivot_longer(
         cols = starts_with("Diff"),
         names_to = "Comparison",
         values_to = "Difference")) +
    aes(fill = Difference) +
    scale_fill_gradient2("Difference \nin posterior \nprobability", limits = c(-.25,.25), breaks = seq(-.25, .25, .05)) +
    facet_wrap(~ Comparison, ncol = 1) +
  theme(legend.position = "right")

legend.diff <- cowplot::get_legend(p.diff.all.all +
  guides(fill = guide_legend(ncol = 1)))
```

(ref:confusion-matrix-long) Illustration of the category-specific differences in predictions of the worst and best performing normalization models for each combination of cues (**rows**). The confusion matrices (**Panel A**) plot the predictions for the worst (**left**) and best (**right**) performing models in predicting the **long** vowels, under different assumptions about the relevant cues. Vowel intended by talker (x-axis) is plotted against vowel selected by ideal observer model (y-axis). Color fill indicates the posterior probability of the models predicting the intended vowel. The difference matrices (**Panel B**) illustrates the differences in predictions between the best and the worst performing models. Color fill indicates the difference in the posterior probability of the models predicting the intended vowel. More **purple** indicates an increase in posterior probability for the former over the latter model, more **red** indicates an advantage for the latter over the former.

\begin{landscape}

```{r confusion-matrix-long, fig.width=base.width*5, fig.height=base.height*4.5, fig.align='center', out.height='90%', fig.cap="(ref:confusion-matrix-long)"}
cowplot::plot_grid(
  cowplot::plot_grid(legend.confusion,
                     cowplot::plot_grid(p.confusion.long.F1F2, p.confusion.long.F1F3, p.confusion.long.all, align = "hv", axis = "btlr", ncol = 1),
                     ncol = 2, rel_widths = c(1/8,7/8)),
  cowplot::plot_grid(cowplot::plot_grid(p.diff.long.F1F2, p.diff.long.F1F3, p.diff.long.all, align = "hv", axis = "btlr", ncol = 1), legend.diff,
                     ncol = 2, rel_widths = c(4/5,1/5)),
  ncol = 2, rel_widths = c(.65,.35), labels = c("A", "B"))
```
\end{landscape}
(ref:confusion-matrix-short) Illustration of the category-specific differences in predictions of the worst and best performing normalization models for each combination of cues (**rows**). The confusion matrices (**Panel A**) plot the predictions for the worst (**left**) and best (**right**) performing models in predicting the **short** vowels, under different assumptions about the relevant cues. Vowel intended by talker (x-axis) is plotted against vowel selected by ideal observer model (y-axis). Color fill indicates the posterior probability of the models predicting the intended vowel. The difference matrices (**Panel B**) illustrates the differences in predictions between the best and the worst performing models. Color fill indicates the difference in the posterior probability of the models predicting the intended vowel. More **purple** indicates an increase in posterior probability for the former over the latter model, more **red** indicates an advantage for the latter over the former.

\begin{landscape}

```{r confusion-matrix-short, fig.width=base.width*5, fig.height=base.height*4.5, fig.align='center', out.height='90%', fig.cap="(ref:confusion-matrix-short)"}
cowplot::plot_grid(
  cowplot::plot_grid(legend.confusion,
                     cowplot::plot_grid(p.confusion.short.F1F2, p.confusion.short.F1F3, p.confusion.short.all, align = "hv", axis = "btlr", ncol = 1),
                     ncol = 2, rel_widths = c(1/8,7/8)),
  cowplot::plot_grid(cowplot::plot_grid(p.diff.short.F1F2, p.diff.short.F1F3, p.diff.short.all, align = "hv", axis = "btlr", ncol = 1), legend.diff,
                     ncol = 2, rel_widths = c(4/5,1/5)),
  ncol = 2, rel_widths = c(.65,.35), labels = c("A", "B"))
```

\end{landscape}

(ref:confusion-matrix-allVowels) Illustration of the category-specific differences in predictions of the worst and best performing normalization models for each combination of cues (**rows**). The confusion matrices (**Panel A**) plot the predictions for the worst (**left**) and best (**right**) performing models in predicting the **all** vowels, under different assumptions about the relevant cues. Vowel intended by talker (x-axis) is plotted against vowel selected by ideal observer model (y-axis). Color fill indicates the posterior probability of the models predicting the intended vowel. The difference matrices (**Panel B**) illustrates the differences in predictions between the best and the worst performing models. Color fill indicates the difference in the posterior probability of the models predicting the intended vowel. More **purple** indicates an increase in posterior probability for the former over the latter model, more **red** indicates an advantage for the latter over the former.

\begin{landscape}

```{r confusion-matrix-allVowels, fig.width=base.width*5, fig.height=base.height*4.5, fig.align='center', out.height='90%', fig.cap="(ref:confusion-matrix-allVowels)"}
cowplot::plot_grid(
  cowplot::plot_grid(legend.confusion,
                     cowplot::plot_grid(p.confusion.all.F1F2, p.confusion.all.F1F3, p.confusion.all.all + theme(legend.position = "none"), align = "hv", axis = "btlr", ncol = 1),
                     ncol = 2, rel_widths = c(1/8,7/8)),
  cowplot::plot_grid(cowplot::plot_grid(p.diff.all.F1F2, p.diff.all.F1F3, p.diff.all.all + theme(legend.position = "none"), align = "hv", axis = "btlr", ncol = 1), legend.diff,
                     ncol = 2, rel_widths = c(4/5,1/5)),
  ncol = 2, rel_widths = c(.65,.35), labels = c("A", "B"))
```

\end{landscape}
