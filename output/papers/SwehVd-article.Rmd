---
title             : "Evaluating normalization accounts against the dense vowel space of Central Swedish"
shorttitle        : "Evaluating normalization accounts"
date              : "`r format(Sys.time(), '%B %d, %Y')`"

author:
  - name: Anna Persson
    affiliation: '1'
    corresponding: yes
    address: 'Department of Swedish Language and Multilingualism, Stockholm University, SE-106 91 Stockholm, Sweden'
    email: 'anna.persson@su.se'
  - name: T. Florian Jaeger
    affiliation: '2,3'

affiliation:
  - id: '1'
    institution: Swedish Language and Multilingualism, Stockholm University
  - id: '2'
    institution: Brain and Cognitive Sciences, University of Rochester
  - id: '3'
    institution: Computer Science, University of Rochester

authornote: |
  We are grateful to ### ommitted for review
# Maryann Tan. Phoneticians you met with in preparation of project.
# Tomas Riad for feedback on previous presentations of this materials.
# Nathan Young for feedback on segmentation procedures, and giving access to and support in managing the SweFA for automatic annotation of Swedish vowels.

abstract: |
  Talkers vary in the phonetic realization of their vowels. One influential hypothesis holds that listeners overcome this inter-talker variability through pre-linguistic auditory mechanisms that normalize the acoustic or phonetic cues that form the input to speech recognition. Dozens of competing normalization accounts exist---including both accounts specific to vowel perception and general purpose accounts that can be applied to any type of cue. We add to the cross-linguistic literature on this matter by comparing normalization accounts against a new phonetically annotated vowel database of Central Swedish, a language with a particularly dense vowel inventory of 21 vowels differing in quality and quantity. All data and code for this study are shared via OSF, including the R markdown document that this article is generated from, and an R library that implements the models we present.

keywords          : "speech perception; computational model; accent adaptation; perceptual recalibration"
wordcount         : "X"

bibliography      : ["latex-stuff/library.bib", "latex-stuff/ref_lit.bib", "latex-stuff/r-references.bib"]
link-citations    : yes
csl               : latex-stuff/apa-6th-edition.csl

floatsintext      : yes
figurelist        : no
tablelist         : no
footnotelist      : no
linenumbers       : yes
numbersections    : false
mask              : no
draft             : no

header-includes:
 - \usepackage{animate}
 - \usepackage{amsmath}
 - \usepackage{tikz}
 - \usetikzlibrary{bayesnet}
 - \usepackage{booktabs}
 - \usepackage{siunitx}
 - \usepackage{soul}
 - \usepackage{tabto}
 - \usepackage{xcolor}
 - \usepackage{colortbl}
 - \usepackage{placeins}
 - \setstcolor{red}
 - \usepackage{sectsty}
 - \sectionfont{\color{black}}
 - \subsectionfont{\color{black}}
 - \subsubsectionfont{\color{black}}
 - \usepackage{setspace}\doublespacing
 - \usepackage{subfig}
 - \usepackage{lscape}
 - \usepackage{pdflscape}

documentclass     : "apa6"
classoption       : "man"
fontsize          : 11pt
output:
  papaja::apa6_pdf:
    latex_engine: xelatex
    extra_dependencies: "subfig"
    includes:
      in_header: latex-stuff/header.tex
always_allow_html: true
---

\setcounter{secnumdepth}{5}

```{r libraries, include=FALSE, message=FALSE}
library(curl)             # Check availability of internet for install of remote libraries

# Install remotes package if necessary
if(!requireNamespace("remotes", quietly = TRUE)) if (has_internet()) install.packages("remotes")
# Install the stable development version from GitHub
if (has_internet()) remotes::install_github("crsh/papaja")
library(papaja)           # APA formatted ms

library(tidyverse)        # data wrangling and plotting
library(magrittr)         # pipes, my friend, we need pipes
library(assertthat)       # for error checking
library(rlang)            # quosures and unquoting
library(ggforce)          # correlation matrices
library(plotly)           # for interactive HTML plots
library(mvtnorm)          # multivariate Gaussian distributions

if (has_internet()) remotes::install_github("hlplab/MVBeliefUpdatr")
library(MVBeliefUpdatr)   # for generating Ideal Observers

library(linguisticsdown)  # for inserting IPA symbols
library(kableExtra)       # for styling html format
library(modelr)
library(phonR)            # for vowel normalization functions
library(phonTools)        # for WattFabricius normalization function
```

```{r setup, include=FALSE}
library(knitr)

# Set knit defaults for code chunks
opts_chunk$set(
  dev='jpeg', # default format of figures
  fig.ext="jpeg",
  comment="",
  echo=FALSE, warning=FALSE, message=FALSE,
  cache=TRUE)

# some useful formatting functions for output of knitting
def.chunk.hook  <- knitr::knit_hooks$get("chunk")
knitr::knit_hooks$set(chunk = function(x, options) {
  x <- def.chunk.hook(x, options)
  ifelse(options$size != "normalsize", paste0("\n \\", options$size,"\n\n", x, "\n\n \\normalsize"), x)
})

color_block = function(color) {
  function(x, options) sprintf('\\color{%s}\\begin{verbatim}%s\\end{verbatim}\\color{black}', color, x)
}
knitr::knit_hooks$set(error = color_block('red'))
knitr::knit_hooks$set(warning = color_block('orange'))
```

```{r functions-and-pipes, include=FALSE}
source("constants.R")

myGplot.defaults("paper")

options(knitr.table.format = "latex")
color.transform <- "#C9C0BB"
color.centering <- "#ABCDEF"
color.scaling <- "#DDADAF"

base.width = 2.5
base.height = 2.5
base_size = 10
```

# To Do

  * Update TO DO regularly
  * Check that Lobanov achieves the same accuracy as C-CuRE models when duration is centered and combined w Lobanov formants.
  * Work on previous-research-table for Study II.
    * add @nearey1989 and @johnson-sjerps2021 to the table
    * refs on C-CuRE vowels
  * Add REFS 
    * that SyrdalGopal is particularly successful in separating vowels that differ in lip rounding
    * per-vowel accuracies and benefits of normalization
  * FIGs
    * per-vowel accuracy figs in SI
    * add fig illustrating joint and marginal cue distributions.
    * to work on while in review: fig 10, color labels, or only label a few vowels (or none).
  * Have all tables be the same size
  * Apply normalization to the data at all three time points

```{r}

```

\newpage
\setcounter{page}{1}

# Introduction {#sec:intro}
Talkers differ in their pronunciation of individual speech sounds due to both physiological differences and socio-cultural factors, including style, regional dialect, and second language accents. For listeners, this means that the mapping from acoustic cues to linguistic categories---phonemes, syllables, words, and ultimately word meanings---varies depending on the talker. How listeners manage to typically understand talkers despite this "lack of invariance" [@liberman1967] has remained one of the central questions for research on speech perception. Hypotheses about the mechanisms underlying this ability can be grouped into three, mutually compatible, accounts: (1) low-level, pre-linguistic auditory transformation of the acoustic signal, (2) learning of changes in the linguistic representations, and (3) post-linguistic changes in decision-making biases [see e.g., @johnson2006; @pardo2006; @xie2022]. The present study focuses on the first type of account, that the acoustic signal is transformed and normalized early on during auditory processing [for recent reviews, @johnson-sjerps2021; @stilp2020]. Some studies suggest, for example, that talker-normalized representations of the speech signal are present as early as in the brain stem [e.g., @sjerps2019; @sussman1986], and thus prior to even the earliest cortical areas associated with speech perception. We compare different types of normalization accounts against data from the production of short and long vowels of Stockholm Swedish.

Normalization accounts were originally proposed as a theory of how the brain removes *physiologically*-conditioned variation from the speech signal, reducing variability in, for example, category means between talkers, and thus reducing the overlap of phonological categories in the acoustic-phonetic space [e.g., @Bladon1984; @gerstman1968; @lobanov1971; @miller1989c; @nearey1978; @nordstrom1975; @peterson1961; @Syrdal1986; @sussman1986]. Most of this early work focused specifically on differences in formants, which cross-linguistically are the primary cues to distinctions in vowel quality, and known to be affected by the vocal tract size of the talker [e.g., @fox1995; @Peterson1952; @verbrugge1976; @yang2014]. Figure \@ref(fig:illustrate-normalization) illustrates the effect of one of the most commonly applied normalization accounts [@lobanov1971] for the vowel spaces of three L1 speakers of US English [from the database reported in @xie2020asa]. By normalizing cues prior to categorization, physiological differences between talkers can be reduced, resulting in reduced between-talker variability (compare Figure \@ref(fig:illustrate-normalization)B to \@ref(fig:illustrate-normalization)A). If listeners' category representations pool experiences across talkers into a single talker-independent model, this reduced inter-talker variability results in reduced category overlap (compare Figure \@ref(fig:illustrate-normalization)D to \@ref(fig:illustrate-normalization)C).^[Talker-independent category representations are assumed in many influential models of spoken word recognition [e.g., @luce-pisoni1998; @mcclelland-elman1986; @norris-mcqueen2008]. While talker-independent representations might be a simplifying assumption for some of these theories, this assumption has persisted for decades [e.g. @magnuson2020; @tenbosch2022]. Exceptions include exemplar accounts [e.g., @johnson1997; @pierrehumbert2001] and the Bayesian ideal adaptor account [@kleinschmidt-jaeger2015]. Importantly, it is an unresolved question whether---or for which cues and phonetic contrasts---listeners maintain talker-specific *category* representations [for findings and discussion, see @kraljic-samuel2007; @kleinschmidt-jaeger2015; @kleinschmidt2019; @xie2021cognition]. In the present paper, we follow previous work and compare the effectiveness of normalization under the assumption of talker-independent category representations.]

(ref:illustrate-normalization) Illustrating how normalization reduces category overlap for the 8 monophthongs of L1 US English. Three talkers from @xie2020asa database are shown before (**Panel A**) and after Lobanov normalization (**Panel B**). Lobanov normalization reduces inter-talker variability in the category means and, to some extent, in the category variances. The panels in the rightmost column aggregate the data from all 17 talkers in the database (5 female, 12 male), showing the means and 95% probability mass bivariate Gaussian densities for each vowel before (**Panels C**) and after Lobanov normalization (**Panel D**).

```{r}
# Load native vowel data from Li & Xie database
d.Eng.LiXie <-
  read_csv('../../data/phonetic vowel statistics/English/Li_Xie_2020_L1_vowels_statistics_general.csv') %>%
    #remove variables related to Miller's height backness space to avoid confusion
    select(-F0_gm) %>%
    mutate(Language = "L1 English",
           Vowel = factor(
             plyr::mapvalues(
               Vowel,
               levels.vowel.Arpabet,
               levels.vowel.IPA),
             levels = levels.vowel.IPA)) %>%
  rename(category = Vowel, F0 = F0.mean, F1 = F1_gm, F2 = F2_gm, F3 = F3_gm) %>%
  relocate(F0, .before = F1) %>%
  group_by(Talker, category) %>%
  #Since the normalization and transformation functions does not take NAs, we replace NAs with the average F0 value for that Talker and category
  mutate(
    F0 = replace_na(F0, geometric.mean(F0)))
```

```{r}
set.seed(333421866)

d.Eng.LiXie.long <-
  d.Eng.LiXie %>%
  # Split data into five equally sized bins  
  split_data() %>%
  # Make cross-validation folds
  crossing(crossvalidation_group = 1:5) %>%
  mutate(fold_type = ifelse(crossvalidation_group != (fold + 3) %% 5 + 1, "training", "test")) %>%
  arrange(crossvalidation_group)

apply_all_transformations_and_normalization <-
  function(data) {
    data %>%
      get_transformation() %>%
      get_normalization_functions(
        data = .,
        normalize_based_on_fold_types = "training")() %>%
      rename(F0_Hz = F0, F1_Hz = F1, F2_Hz = F2, F3_Hz = F3) %>%
      add_C_CuRE(
        data = .,
        cues = c("F0_Hz", "F1_Hz", "F2_Hz", "F3_Hz", "F0_Mel", "F1_Mel", "F2_Mel", "F3_Mel", "F0_ERB", "F1_ERB", "F2_ERB", "F3_ERB", "F0_Bark", "F1_Bark", "F2_Bark", "F3_Bark", "F0_semitones", "F1_semitones", "F2_semitones", "F3_semitones", "Duration"),
        normalize_based_on_fold_types = "training")() %>%
      # Add '_r' for 'raw' to columns with scale-transformed data in order for pivoting to work in next chunk
      rename_with(.fn = ~ paste(.x, "r", sep = "_"), .cols = ends_with(c("Hz", "Mel", "Bark", "ERB", "semitones")))
  }

# Normalize all data based on the respective training of each cross-validation group
d.Eng.LiXie.long %<>%
  group_by(crossvalidation_group) %>%
  # Get transformations, apply normalizations (both classic formants one and C-CuRE)
  group_map(
    .f = ~ apply_all_transformations_and_normalization(data = .x),
    .keep = T
  ) %>%
  reduce(bind_rows) %>%
  ungroup() %>%
  pivot_longer(
    cols = starts_with("F", ignore.case = FALSE),
    names_to = c("Cue", "Normalization.Scale", "Normalization.Type"),
    names_sep = "_",
    values_to = "Cue.Value") %>%
  pivot_wider(
    names_from = "Cue",
    values_from = "Cue.Value") %>%
    # Mutate both
  mutate(Normalization.Type = paste(Normalization.Type, Normalization.Scale, sep = "_")) %>%
  select(-Normalization.Scale) %>%
  relocate(Talker, Normalization.Type, crossvalidation_group, fold_type, fold, category, Token)

p.Eng.LiXie.raw <-
  d.Eng.LiXie.long %>%
  filter(fold_type == "test", Normalization.Type == "r_Hz", Talker %in% c("E1", "E4", "E9")) %>%
  ggplot(
    aes(
      x = F2,
      y = F1)) +
  geom_point(
    aes(
      colour = category),
    alpha = .3) +
  # Add category means
  geom_point(
    data =
      ~ .x %>%
      group_by(category, Talker) %>%
      summarise(across(c(F1, F2), ~ mean(.x))),
    mapping = aes(
      colour = category),
    alpha = .8) +
  scale_color_brewer("Vowel", palette = "Paired") +
  scale_x_reverse("F2 (Hertz)", position = "top", breaks = scales::pretty_breaks(n = 3), limits = c(3100, 740)) +
  scale_y_reverse("F1 (Hertz)", breaks = scales::pretty_breaks(n = 3), limits = c(1100, 200)) +
  guides(color = "none") +
  facet_wrap(~ factor(Talker, levels = c("E1", "E4", "E9"), labels = c("Talker E1", "Talker E4", "Talker E9")), ncol = 1) +
  theme(axis.text = element_text(size = 7),
        axis.title.y = element_text(vjust = 0))

p.Eng.LiXie.Lobanov <-
  p.Eng.LiXie.raw %+%
  (d.Eng.LiXie.long %>%
  filter(fold_type == "test", Normalization.Type == "Lobanov_Hz", Talker %in% c("E1", "E4", "E9"))) +
  scale_x_reverse("F2 (Lobanov)", position = "top", breaks = scales::pretty_breaks(n = 3), limits = c(2.55, -1.8)) +
  scale_y_reverse("F1 (Lobanov)", breaks = scales::pretty_breaks(n = 3), limits = c(2, -2))

p.Eng.LiXie.all.raw <-
  d.Eng.LiXie.long %>%
  filter(fold_type == "test", Normalization.Type == "r_Hz") %>%
  ggplot(
    aes(
      x = F2,
      y = F1,
      color = category)) +
  stat_ellipse() +
  geom_point(
    data =
      ~ .x %>%
      group_by(category) %>%
      summarise(across(c(F1, F2), ~ mean(.x))),
    mapping = aes(
      colour = category),
    alpha = .8) +
  scale_color_brewer("Vowel", palette = "Paired") +
  scale_y_reverse("", breaks = scales::pretty_breaks(n = 3)) +
  facet_wrap(~ factor(Normalization.Type, levels = c("r_Hz", "Lobanov_Hz"), labels = c("all talkers", "all talkers")), scales = "free") +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title.x = element_blank())

p.Eng.LiXie.all.Lob <-
  p.Eng.LiXie.all.raw %+%
  (d.Eng.LiXie.long %>%
     filter(fold_type == "test", Normalization.Type == "Lobanov_Hz")) +
  guides(color = "none")

#Get legend from final plot
legend <-
  cowplot::get_legend(
    # create some space to the left of the legend
    p.Eng.LiXie.all.raw +
      guides(color = guide_legend(nrow = 1, byrow = TRUE)) +
      theme(legend.direction = "horizontal",
            legend.justification="center",
            legend.box.just = "top"))
```

```{r illustrate-normalization, fig.width=base.width*2.5, fig.height=base.height*3.5+.5, out.width='75%', fig.align='center', fig.cap="(ref:illustrate-normalization)"}
cowplot::plot_grid(
  legend,
  cowplot::plot_grid(
    cowplot::plot_grid(p.Eng.LiXie.raw, p.Eng.LiXie.all.raw + theme(legend.position = "none"), labels = c("A", "C"), ncol = 1, align = "hv", rel_heights = c(3/4, 1/4)), 
    NULL,
    cowplot::plot_grid(
      p.Eng.LiXie.Lobanov, p.Eng.LiXie.all.Lob, labels = c("B", "D"), ncol = 1, align = "hv", rel_heights = c(3/4, 1/4)),
    ncol = 3, align = "hv", rel_widths = c(1, -.05, .95)),
    align = "hv", axis = "bltr", nrow = 2, rel_heights = c(.05, .95))
```

Dozens of different accounts of vowel normalization have been proposed over the years [e.g., @joos1948; @gerstman1968; @lobanov1971; @fant1975; @nordstrom1975; @nearey1978; @traunmuller1981; @Bladon1984; @Syrdal1986; @miller1989c; @zahorian1991; @watt2002; for reviews, see @adank2004; @weatherholtz-jaeger2016]. @carpenter1993 summarize over 100 different vowel-specific normalization accounts, many of them closely related to each other. More recently, additional *general* normalization accounts have emerged that can be applied to *any* type of cue and phonological contrast [e.g., @cole2010; @mcmurray-jongman2011]. The most widely used of these proposals, C-CuRE, has since been successfully applied to the categorization of US English fricatives [@apfelbaum2014; @crinnion2020; @mcmurray-jongman2011], stop voicing [@kulikov2022; @toscano2015; @xie2022], vowels [@kleinschmidt2019; @mcmurray-jongman2016], and sentence-final rising question vs. statement intonation [@xie2021cognition]. In each of these studies, C-CuRE reduced inter-talker variability and improved categorization. C-CuRE stands for "**c**omputing **cu**es **r**elative to **e**xpectations", capturing the motivation behind many of the earlier normalization accounts that cue values should be interpreted relative to the distribution they are expected to have in the present context. In addition to being more general than earlier accounts, C-CuRE also addresses one of the main arguments against normalization as an account of human speech perception [e.g., @johnson2006, which continues to be frequently cited in reviews of exemplar theory]: by focusing on listeners' expectations rather than talkers' physiology, accounts like C-CuRE capture that inter-talker variability is not limited to physiology.

Table \@ref(tab:norm-accounts) lists the normalization accounts investigated in the present study. This includes both the most influential vowel-specific normalization accounts that have been found to perform well in previous works (e.g., Lobanov and Nearey2 normalization) and several variants of the general purpose normalization C-CuRE. As indicated through shading in the table, the accounts can be grouped into four types based on the computational assumptions they make. *Transformations* are meant to transform the formant data from acoustic (Hz) into a perceptual space that approximates the perceptual organization of auditory information in the human brain. All other accounts instead or additionally adjust each formant value based on either the values of other formants on the same segment (*vowel-intrinsic* approaches) or summary statistics of the formant across segments (*vowel-extrinsic* approaches).^[Miller's formant-ratio account [@miller1989c] is technically a hybrid approach: the first formant (F1) is normalized with regard to an extrinsic sensory reference (based on the average F0 across segments); subsequent formants are (intrinsicly) normalized using the normalized lower formants on the same vowel segment.] We further distinguish two types of vowel-extrinsic approaches: approaches that *center* each cue relative to its mean across all vowel segments, and approaches that instead/additionally *scale* cues relative to the overall variability or range of the cue across all vowel segments [for reviews, see also e.g., @Johnson2005c; @kohn2012a; @weatherholtz-jaeger2016]. The former type includes C-CuRE, and we consider different variants of this approach, one for each transformation approach in Table \@ref(tab:norm-accounts).^[Another frequently used normalization account that involves scaling is Watt & Fabricius [@watt2002; @fabricius2009]. We do not include this account in our evaluation, as it requires making specific assumptions of vowel inventories of the language, and it is limited to normalization of the first two formants.]

\begin{landscape}\begin{table}
\caption{\label{tab:norm-accounts}Normalization accounts considered in the present study. Unless otherwise marked, formant variables ($F$s) in the right-handside of normalization formulas are in Hz.}
\centering
\fontsize{8}{10}\selectfont
\begin{tabular}[t]{>{\arraybackslash}p{0.1cm}>{\arraybackslash}p{0.2cm}>{\arraybackslash}p{0.5cm}|>{\raggedright\arraybackslash}p{3cm}|>{\raggedright\arraybackslash}p{3cm}|>{\raggedright\arraybackslash}p{4cm}|>{\raggedright\arraybackslash}p{6.2cm}}
\hline
& & & Normalization procedure & Perceptual scale & Source & Formula\\
\hline
\hline
& & & n/a & Hz & n/a & n/a \\

\hline

& & \cellcolor[HTML]{C9C0BB}{} & \cellcolor[HTML]{C9C0BB}{n/a} & \cellcolor[HTML]{C9C0BB}{Bark} & \cellcolor[HTML]{C9C0BB}{Traunmüller (1990)} & \cellcolor[HTML]{C9C0BB}{$F_n^{Bark} = \frac{26.81 \times F_n}{1960 + F_n} - 0.53$} \\
& & \cellcolor[HTML]{C9C0BB}{} & \cellcolor[HTML]{C9C0BB}{---} & \cellcolor[HTML]{C9C0BB}{ERB}  & \cellcolor[HTML]{C9C0BB}{Glasberg \& Moore (1990)} & \cellcolor[HTML]{C9C0BB}{$F_n^{ERB} = 21.4 \times \log_{10}(1 + F_n \times 0.00437)$} \\
\multirow[c]{-2}{*}{\rotatebox{90}{trans-}} & & \cellcolor[HTML]{C9C0BB}{} & \cellcolor[HTML]{C9C0BB}{---} & \cellcolor[HTML]{C9C0BB}{Mel}  & \cellcolor[HTML]{C9C0BB}{Stevens \& Volkmann (1940)} & \cellcolor[HTML]{C9C0BB}{$F_n^{Mel} = 2595 \times \log_{10}(1 + \frac{F_n}{700})$} \\
& \multirow[c]{-4}{*}{\rotatebox{90}{formation}} & \cellcolor[HTML]{C9C0BB}{} & \cellcolor[HTML]{C9C0BB}{---} & \cellcolor[HTML]{C9C0BB}{Semitones conversion} & \cellcolor[HTML]{C9C0BB}{Fant et al. (2002)} & \cellcolor[HTML]{C9C0BB}{$F_n^{ST} = 12 \times \frac{ln(\frac{F_n}{100})}{ln}$} \\

\hline

& & \cellcolor[HTML]{E6BE8A}{} & \cellcolor[HTML]{E6BE8A}{Syrdal \& Gopal's} & \cellcolor[HTML]{E6BE8A}{Bark} & \cellcolor[HTML]{E6BE8A}{Syrdal \& Gopal (1986)} & \cellcolor[HTML]{E6BE8A}{$F1^{SyrdalGopal} = F1^{Bark} - F0^{Bark}$} \\
& & \cellcolor[HTML]{E6BE8A}{} & \cellcolor[HTML]{E6BE8A}{Bark-distance model} & \cellcolor[HTML]{E6BE8A}{} & \cellcolor[HTML]{E6BE8A}{} & \cellcolor[HTML]{E6BE8A}{$F2^{SyrdalGopal} = F2^{Bark} - F1^{Bark}$} \\
& & \cellcolor[HTML]{E6BE8A}{} & \cellcolor[HTML]{E6BE8A}{} & \cellcolor[HTML]{E6BE8A}{} & \cellcolor[HTML]{E6BE8A}{} & \cellcolor[HTML]{E6BE8A}{$F3^{SyrdalGopal} = F3^{Bark} - F2^{Bark}$} \\
& & \cellcolor[HTML]{E6BE8A}{} & \cellcolor[HTML]{E6BE8A}{Miller} & \cellcolor[HTML]{E6BE8A}{log} & \cellcolor[HTML]{E6BE8A}{Miller (1989)} & \cellcolor[HTML]{E6BE8A}{$SR = k (\frac{GM f0}{k})^{1/3}$} \\
& & \cellcolor[HTML]{E6BE8A}{} & \cellcolor[HTML]{E6BE8A}{(formant-ratio)} & \cellcolor[HTML]{E6BE8A}{} & \cellcolor[HTML]{E6BE8A}{} & \cellcolor[HTML]{E6BE8A}{$F1^{Miller} = log(\frac{F1}{SR})$} \\
& & \cellcolor[HTML]{E6BE8A}{} & \cellcolor[HTML]{E6BE8A}{} & \cellcolor[HTML]{E6BE8A}{} & \cellcolor[HTML]{E6BE8A}{} & \cellcolor[HTML]{E6BE8A}{$F2^{Miller} = log(\frac{F2}{F1})$} \\
{\multirow[c]{-7}{*}{\rotatebox{90}{intrinsic}}} & & \cellcolor[HTML]{E6BE8A}{} & \cellcolor[HTML]{E6BE8A}{} & \cellcolor[HTML]{E6BE8A}{} & \cellcolor[HTML]{E6BE8A}{} & \cellcolor[HTML]{E6BE8A}{$F3^{Miller} = log(\frac{F3}{F2})$} \\

\hline

& & \cellcolor[HTML]{ABCDEF}{} & \cellcolor[HTML]{ABCDEF}{C-CuRE} & \cellcolor[HTML]{ABCDEF}{Hz} & \cellcolor[HTML]{ABCDEF}{McMurray \& Jongman (2011)} & \cellcolor[HTML]{ABCDEF}{$F^{C-CuRE}_n = F_n - mean(F_n)$} \\
& & \cellcolor[HTML]{ABCDEF}{} & \cellcolor[HTML]{ABCDEF}{---} & \cellcolor[HTML]{ABCDEF}{Bark} & \cellcolor[HTML]{ABCDEF}{} & \cellcolor[HTML]{ABCDEF}{} \\
& & \cellcolor[HTML]{ABCDEF}{} & \cellcolor[HTML]{ABCDEF}{---} & \cellcolor[HTML]{ABCDEF}{ERB} & \cellcolor[HTML]{ABCDEF}{} & \cellcolor[HTML]{ABCDEF}{} \\
& & \cellcolor[HTML]{ABCDEF}{} & \cellcolor[HTML]{ABCDEF}{---} & \cellcolor[HTML]{ABCDEF}{Mel} & \cellcolor[HTML]{ABCDEF}{} & \cellcolor[HTML]{ABCDEF}{} \\
& & \cellcolor[HTML]{ABCDEF}{} & \cellcolor[HTML]{ABCDEF}{---} & \cellcolor[HTML]{ABCDEF}{Semitones conversion} & \cellcolor[HTML]{ABCDEF}{} & \cellcolor[HTML]{ABCDEF}{} \\

& & \cellcolor[HTML]{ABCDEF}{} & \cellcolor[HTML]{ABCDEF}{Nearey1} & \cellcolor[HTML]{ABCDEF}{log} & \cellcolor[HTML]{ABCDEF}{Nearey (1978)} & \cellcolor[HTML]{ABCDEF}{$F^{Nearey1}_n = \ln(F_n) - mean(ln(F_n))$} \\
& & \cellcolor[HTML]{ABCDEF}{} & \cellcolor[HTML]{ABCDEF}{(log-mean)} & \cellcolor[HTML]{ABCDEF}{} & \cellcolor[HTML]{ABCDEF}{} & \cellcolor[HTML]{ABCDEF}{} \\

& & \cellcolor[HTML]{ABCDEF}{} & \cellcolor[HTML]{ABCDEF}{Nearey2} & \cellcolor[HTML]{ABCDEF}{log} & \cellcolor[HTML]{ABCDEF}{Nearey (1978)} & \cellcolor[HTML]{ABCDEF}{$F^{Nearey2}_n = \ln(F_n) - mean(ln(F))$} \\
& & \cellcolor[HTML]{ABCDEF}{} & \cellcolor[HTML]{ABCDEF}{(single parameter} & \cellcolor[HTML]{ABCDEF}{} & \cellcolor[HTML]{ABCDEF}{} & \cellcolor[HTML]{ABCDEF}{} \\
& & \cellcolor[HTML]{ABCDEF}{{\multirow[c]{-10}{*}{\rotatebox{90}{centering}}}} & \cellcolor[HTML]{ABCDEF}{log-mean)} & \cellcolor[HTML]{ABCDEF}{} & \cellcolor[HTML]{ABCDEF}{} & \cellcolor[HTML]{ABCDEF}{} \\

\cline{3-6}

& & \cellcolor[HTML]{DDADAF}{} & \cellcolor[HTML]{DDADAF}{Gerstman} & \cellcolor[HTML]{DDADAF}{Hz} & \cellcolor[HTML]{DDADAF}{Gerstman (1968)} & \cellcolor[HTML]{DDADAF}{$F_n^{Gerstman} = 999 \times \frac{F_n - F_n^{min}}{F_n^{max} - F_n^{min}}$} \\
& & \cellcolor[HTML]{DDADAF}{} & \cellcolor[HTML]{DDADAF}{(range normalization)} & \cellcolor[HTML]{DDADAF}{} & \cellcolor[HTML]{DDADAF}{} & \cellcolor[HTML]{DDADAF}{} \\

{\multirow[c]{-14}{*}{\rotatebox{90}{extrinsic}}} & & \cellcolor[HTML]{DDADAF}{} & \cellcolor[HTML]{DDADAF}{Lobanov} & \cellcolor[HTML]{DDADAF}{Hz} & \cellcolor[HTML]{DDADAF}{Lobanov (1971)} & \cellcolor[HTML]{DDADAF}{$F^{Lobanov}_n = \frac{F_n - mean(F_n)}{sd(F_n)}$} \\
& & \cellcolor[HTML]{DDADAF}{{\multirow[c]{-4}{*}{\rotatebox{90}{scaling}}}} & \cellcolor[HTML]{DDADAF}{(z-score)} & \cellcolor[HTML]{DDADAF}{} & \cellcolor[HTML]{DDADAF}{} & \cellcolor[HTML]{DDADAF}{} \\

\hline
\end{tabular}
\end{table}
\end{landscape}

Previous comparisons of normalization accounts have primarily focused on English [e.g., @adank2004; @barreda2018a; @carpenter1993; @clopper2009; @disner1980; @escudero2007; @fabricius2009; @Flynn2011; @hindle1978; @kohn2012a; @labov2010; @syrda1985]. Additional studies have investigated, for example, Dutch [@adank2004; @disner1980], Russian [@lobanov1971], and Brazilian Portuguese [@escudero2007]. The complexity of the vowel inventories (7-11 monophthongs) and the number of these vowels included in the comparison (2-11) varied across these studies. We add to this literature by comparing normalization accounts against a new phonetically annotated database of Stockholm Central Swedish (SwehVd, introduced below). With a total of 21 monophthong allophones that vary in quantity (long vs. short vowels) and quality, the vowel inventory of Central Swedish is crowded compared to most languages previously studied in the normalization literature. This allows us to test whether the same normalization accounts that work well for simpler vowel inventories generalize well to more crowded vowel spaces. Additionally, the presence of quantity contrasts between long and short allophones means that Central Swedish provides a suitable case study to bridge the literature between vowel-specific normalization accounts (which focus on formants, and thus only quality contrasts) and general normalization accounts that can be applied to any type of cue (and thus also vowel duration, which is expected to be the primary cue to vowel quantity). Relatedly, previous studies have found both F3 and vowel duration to be important cues to vowel categorization in Swedish [e.g., @behne1997; @fujimura1967; @haddingkoch1964]. These two cues have never (duration) or rarely [F3, but see e.g. @adank2004; @barreda2018a; @carpenter1993; @nearey1989; @syrda1985] been included in comparisons of normalization accounts.

We compare the normalization accounts in Table \@ref(tab:norm-accounts) both in terms of their effectiveness in reducing within-category variability relative to between-category variability (Study 1) and in terms of the predicted consequences for recognition accuracy (Study 2). We originally only conducted Study 2, which more directly addresses our goal of assessing the predicted consequences of normalization for perception. We then included Study 1 because it reflects an approach that continues to be common in research on normalization. In hindsight, this addition of Study 1 turned out to reveal serious shortcomings of separability indices and similar measures of between- vs. within-category variability, highlighting the importance of using models of speech perception when evaluating the consequences of normalization for perception (as we do in Study 2).

Following the bulk of previous studies [but see e.g., @nearey1989; @richter2017], the present studies does not compare the predicted consequences of normalization against categorization responses from human listeners, though we plan to do so in future work. In both studies, we compare normalization accounts applied to (1) only F1 and F2, as in the majority of previous studies, (2) F1-F3, as in, e.g., @adank2004, and (3) F0-F3 as well as vowel duration. This allows us to assess whether differences in the effectiveness of normalization accounts depend on the number and types of cues that are considered. Since listeners integrate cues beyond F1 and F2 [e.g., @Assmann1982; @hillenbrand1999; @nearey1986], this is an important gap in evaluating the plausibility of different normalization accounts as models of adaptive speech perception. All three comparisons are evaluated both separately for short and long vowels, and for the entire space of the 21 short and long vowels. This allows us to assess whether the same types of normalization perform well across the entire vowel inventory. 

To the best of our knowledge, only one previous study has compared normalization accounts against Swedish, as part of a cross-linguistic comparison across six Germanic languages [@disner1980]. @disner1980 compared 4 normalization accounts, using F1 and F2 means of the nine long Swedish vowels spoken by 24 male Swedish talkers [from a database presented in @fant1969]. Of interest to the present study, the results for Swedish differed from the other Germanic languages in two unexpected ways. Whereas Lobanov normalization---which involves centering and scaling (cf. Table \@ref(tab:norm-accounts))---performed best for Swedish, Nearey2 normalization---which involves only centering---performed best for the other four languages. And, while normalization effectively reduced inter-talker variability in category variances for the other four languages by 61%-71%, it was substantially less effective for Swedish (41%). As discussed by Disner, this raise the question as to whether these findings reflect an inherent property of Swedish or merely differences in the honetically annotated databases available for each language. In particular, the Swedish data consisted of *vowels* produced in isolation without any lexical or phonetic context, whereas the data for the five other languages consisted of isolated *word* productions (paralleling the majority of research on normalization). The present study addresses this difference: the new database we introduce consists of *h*-VOWEL-*d* word recordings, which makes our stimuli directly comparable to those used in previous work on normalization. Additionally, we complement Disner's study by focusing on female, rather than male talkers, by considering both long and short vowels (separately and together), and by including the general normalization account C-CuRE. This lets us revisit whether simple *centering* accounts perform best for Swedish---like for the other languages in @disner1980.

All data and code for this article can be downloaded from OSF at (URL)<!-- enter htlm-->. This article is written in R markdown, allowing readers to replicate our analyses using freely available software [@R; @RStudio], while changing any of the parameters of our models. Readers can revisit the assumptions we make---for example, by substituting alternative normalization models. The supplementary information (SI) lists the software/libraries required to compile this document. Next we introduce the new phonetically annotated corpus of Stockholm Central Swedish vowel productions employed in our studies.

```{r load-SwehVd}
# Load native Swedish vowel data, manually corrected, but with distributional outliers remaining (generated by Persson-2021-outlierCorrected)
d.SwehVd <-
  read_csv('../../data/phonetic vowel statistics/Swedish/Persson_2021_L1_vowels_wDistrOutliers.csv')
```

# The SwehVd database {#sec:swehvd}
The SwehVd database is a new phonetically annotated corpus of Swedish *h*-VOWEL-*d* (short: hVd) word recordings. All recordings, annotations, and acoustic measurements are available on OSF.<!-- TO DO: insert html here. This might be a separate URL or the same as for the paper.--> SwehVd was collected with the goal to characterize the Stockholm Swedish vowel space within and across talkers. It covers the entire monophthong inventory of Central Swedish, including all nine long vowels (*hid*, *hyd*, *hud*, *hed*, *häd*, *höd*, *had*, *håd*, *hod*), eight short vowels (*hidd*, *hydd*, *hudd*, *hedd*, *hädd*, *hödd*, *hadd*, *hådd*, *hodd*), and four allophones (*härd*, *härr*, *hörd*, *hörr*).^[Central Swedish is described as the regional standard variety of Swedish spoken in an area around and beyond Stockholm (eastern Svealand), including Maelardalssvenska, Sveamaal, Uppsvenska, Mellansvenska [see e.g., @bruce2009; @elert1994; @riad2014]. The SwehVd targets the contemporary Central Swedish spoken in the larger Stockholm area, see more under Section \@ref(sec:participants).] To our knowledge, there are few publicly available databases of Swedish vowel productions that are phonetically annotated [e.g., @bruce1999; @eklund1997; @fant1969; @kuronen2000]. The largest and perhaps best-known is SweDia 2000 [@bruce1999]. SweDia 2000 was developed to characterize differences in vowel pronunciations *across* regional varieties of Swedish. It consists of recordings of spontaneous speech, isolated words in varying phonological contexts, and phrases in isolation from approximately 1300 talkers from 107 regional backgrounds, with about 10-12 recorded talkers per region and about 5-15 recordings per vowel for each talker.

Unlike existing databases, SwehVd focuses on a single regional variety, providing high resolution within and across talkers for this variety: SwehVd consists of N=10 recordings of each hVd word (for a total of 210 recordings for the 21 different hVd words) per talker. We note that this makes the demographic composition of SwehVd relatively homogenous, compared both to some other vowel corpora of Swedish [e.g., @bruce1999; @kuronen2000] and compared some previous studies on normalization---a point we return to in the general discussion. Specifically, we target N = 24 male and female talkers each (current N = `r n_distinct(d.SwehVd$Talker)`, all female) for a total targeted N of tokens = 10,080 (current N = `r nrow(d.SwehVd %>% distinct(Talker, category, Token))` tokens). The accompanying database contains first to third formant (F1-F3) measurements for each talker at five time points across each vowel, together with vowel duration and mean F0 over the entire vowel.

SwehVd follows the gross of research on normalization and uses hVd words for recording in order to minimise coarticulatory effects from the surrounding phonetic context. The hVd context was originally chosen for studies on English because the glottal /h/ in onset position minimizes supraglottal articulations [confirmed in e.g., @chesworth2003; @robb2009]. Since then hVd words have played a central role in research on vowel production [e.g., @hillenbrand1995; @Peterson1952] and perception [e.g., @malinasky2020; @Peterson1952]. Since Swedish onset /h/ is a glottal approximant [@riad2014] similar to English, the use of this context in SwehVd facilitates comparison to similar databases from other languages. It deviates, however, from the majority of previous studies on Swedish vowels, which have either not held phonetic context constant across vowels [e.g., @bruce1999], or have investigated vowel production out of context [@eklund1997; @fant1969; @disner1980] or in different CVC contexts [e.g., *k*V*p* and *p*V*k* in @nordstrand2004; *v*V*t*, *v*V*tt*, *f*V*t*, *f*V*tt*, in @behne1997].

## The Swedish vowel inventory {#sec:sweVowelinventory}
The Central Swedish vowel inventory contains 21 monophthong vowels. Seventeen of these vowels form nine pairs distinguished by quantity (long and short): in Central Swedish, the two long vowels [`r linguisticsdown::cond_cmpl("ɛː")`] and [`r linguisticsdown::cond_cmpl("eː")`] both neutralize to the same short vowel [`r linguisticsdown::cond_cmpl("ɛ")`] (resulting in a total of 17, rather than 18, distinct vowels). The two variants of a pair are considered allophones, the selection of which is determined primarily by stress and syllable complexity. Quantity is neutralized in unstressed positions [@riad2014].^[This reflects the mainstream analytical position in present-day Swedish phonology. The opposite position, distinctive vowel quantity, has also been proposed [e.g., @linell1978; @linell1979; @schaeffler2005a]. This theoretical debate does not affect the interpretation of our results.] Vowels lengthen in open word-final syllables, before morpheme-final single consonants, and in non-final syllables.

Additionally, there are four contextually conditioned allophones to [`r linguisticsdown::cond_cmpl("ɛ")`] and [`r linguisticsdown::cond_cmpl("ø")`]. Before a retroflex, both the long and short versions of these vowels lower to long and short [`r linguisticsdown::cond_cmpl("æ")`] and [`r linguisticsdown::cond_cmpl("œ")`], respectively. As shown in Table \@ref(tab:swedish-vowels) [adapted from @riad2014], some long-short vowel pairs are described to differ not only in quantity but also in quality: generally, short vowels are described as more open and also more centralized, forming a more condensed vowel space. In ongoing work [@persson2023], we found this to be confirmed for SwehVd.

Several of the long vowels have been claimed to be diphthongized in Central Swedish [e.g., @elert1981; @fant1969; @fant1971; @kuronen2000] and/or with consonantal elements [@mcallister1974], though empirical evaluations of this claim have returned mixed results [@eklund1997; @fant1969; @leinonen2010]. In separate work [@persson2023], we have found evidence for diphthongization of some vowels in SwehVd, including some for which it has not previously been reported. Here we do not discuss this issue further since it has no direct consequences for the present study: normalization can be applied to both monophthongs and diphthongs, and listeners presumably use the full information contained in the dynamics of formant trajectories---rather than just aggregate point estimates (the simplifying information we make below, following other work on normalization). 

\begin{table}
\caption{\label{tab:swedish-vowels}The phonological characterization of long (left) and short (right) Central Swedish vowels (based on Riad, 2014)}
\centering
\begin{tabular}[t]{c|c|c|c|c}
\hline
&front&rounded&central&back\\
\hline
high&`r linguisticsdown::cond_cmpl("[iː]")`&`r linguisticsdown::cond_cmpl("[yː]")`&&`r linguisticsdown::cond_cmpl("[uː]")`\\
\hline
mid-high&`r linguisticsdown::cond_cmpl("[eː]")`&`r linguisticsdown::cond_cmpl("[ʉː]")`&&`r linguisticsdown::cond_cmpl("[oː]")`\\
\hline
mid&`r linguisticsdown::cond_cmpl("[ɛː]")`&`r linguisticsdown::cond_cmpl("[øː]")`&&\\
\hline
low&`r linguisticsdown::cond_cmpl("[æː]")`&`r linguisticsdown::cond_cmpl("[œː]")`&&`r linguisticsdown::cond_cmpl("[ɑː]")`\\
\end{tabular}
\hspace{2em}
\begin{tabular}[t]{c|c|c|c|c}
\hline
&front&rounded&central&back\\
\hline
high&`r linguisticsdown::cond_cmpl("[ɪ]")`&`r linguisticsdown::cond_cmpl("[ʏ]")`&`r linguisticsdown::cond_cmpl("[ɵ]")`&`r linguisticsdown::cond_cmpl("[ʊ]")`\\
\hline
&&&&\\
\hline
mid&`r linguisticsdown::cond_cmpl("[ɛ]")`&`r linguisticsdown::cond_cmpl("[ø]")`&`r linguisticsdown::cond_cmpl("[œ]")`&`r linguisticsdown::cond_cmpl("[ɔ]")`\\
\hline
low&`r linguisticsdown::cond_cmpl("[æ]")`&&`r linguisticsdown::cond_cmpl("[a]")`&\\
\end{tabular}
\end{table}

## Participants {#sec:participants}
Native talkers of Stockholm Swedish were recruited through word-of-mouth, flyers at Stockholm University Campus (see example flyer in SI \@ref(sec:recruitment)), and online channels (accindi.se). Participants were selected based on the following criteria: L1 talkers of Swedish, born and raised in the bigger Stockholm area or surroundings (provinces of Södermanland, Uppland), 20-40 years old (mean age=`r mean(d.SwehVd$Age) %>% round(digits = 0)`; SD=`r sd(d.SwehVd$Age) %>% round(digits = 2)`). Four of the participants were bilingual from birth, the L1s of each talker are provided in the database. All participants were reimbursed with a voucher to the value of SEK 100 after completing the recordings.

## Recording procedure {#sec:vowelCorpRec}
Recording for the SwehVd database began in 2020 and is ongoing. The hVd words were recorded by the first author and Maryann Tan (Stockholm University) together with another set of recordings targeting the production of Central Swedish word-initial stop voicing. Recording took place in a sound-attenuated room at the Multilingualism Laboratory, Department of Swedish Language and Multilingualism, Stockholm University.

Prior to recording, participants were informed about the study and given the possibility to ask questions before signing a consent form. They were then given instructions and seated at approximately 10 cm distance from an Audio Technica AT3035 microphone facing a computer screen. Words were presented one at a time, centered on screen, using PsychoPy software [@peirce2019]. Participants were instructed to read the words with their natural voice as they appeared on screen. Each talker read the same 21 target words, with 48 mono- and bi-syllabic filler words interspersed. Each target word was repeated 10 times and each filler word was repeated five times, generating a total of 450 productions per talker, 210 target productions and 240 filler productions. We generated two pseudo-randomized lists of the words, each list divided into four different blocks. Words were blocked across block lists and randomized within block lists, with the constraint that the same word would not appear more than twice in succession. Each participant was randomly assigned to one of the two lists. The pace of the presentation of the words was controlled by the experimenter, who was listening over Sennheiser HD215 headphones in the next room. A Yamaha MG102c mixing console with a built-in preamplifier was used together with a high-end ground isolator for preventing signal interference (Monacor FGA-40HQ). The speech was recorded at 44.1 kHz in Audacity [@teamaudacity2021]. Each long sound file was split into individual short sound files of one word each. The boundaries of each file were slightly trimmed and the files were labelled with the target word. All sound files from the same talker were concatenated into one long file before further processing.

The complete list of target hVd words is provided in Table \@ref(tab:word-list) in the SI. It consists of four real Swedish words, *hed*, *härd*, *hörd*, *hud* (English translations: *heath*, *hearth*, *heard*, and *skin*, respectively) and 17 phonotactically legal pseudowords. Following Swedish orthographical conventions for quantity, we used orthographic *hVdd* to elicit the short vowel allophone (e.g., *hudd* for [`r linguisticsdown::cond_cmpl("ɵ")`]) and orthographic *hVd* to elicit the long vowel allophone (e.g., *hud* for [`r linguisticsdown::cond_cmpl("ʉː")`]). This orthography reflects systematic phonological process of complementary quantity in Central Swedish [@riad2014]. In order to elicit the contextual allophones to [`r linguisticsdown::cond_cmpl("ɛ")`] and [`r linguisticsdown::cond_cmpl("ø")`], we added the supradental [`r linguisticsdown::cond_cmpl("ɖ")`] to elicit the long allophones (*härd*, *hörd*), and [`r linguisticsdown::cond_cmpl("r")`] to elicit the short allophones (*härr*, *hörr*). In a small-scale pilot preceding recordings, the expected transparency of the orthography for eliciting the long and short vowels was confirmed by three native talkers and one non-native talker of Swedish (these talkers did not participate in the study). However, *hodd* [`r linguisticsdown::cond_cmpl("ʊ")`] and *hod* [`r linguisticsdown::cond_cmpl("uː")`] sometimes elicited [`r linguisticsdown::cond_cmpl("ɔ")`].^[The difficulty for some native talkers to produce [`r linguisticsdown::cond_cmpl("ʊ")`] when reading *hodd* might be due to frequency effects. Forms with stressed [`r linguisticsdown::cond_cmpl("ʊ")`] are few in the Swedish language, and phonotactically similar words are most often pronounced as [`r linguisticsdown::cond_cmpl("ɔ")`] [see e.g., @riad2014].] We therefore decided to add instructions to the participants for these two words. When *hod* or *hodd* appeared on screen, a written guide indicating the target vowel appeared below the word in smaller font size: "hod som i hot", "hodd som i hosta", with *hot* and *hosta* being real Swedish words containing [`r linguisticsdown::cond_cmpl("uː")`] and [`r linguisticsdown::cond_cmpl("ʊ")`], respectively.^[English translations: "hod as in threat"(phonologically [`r linguisticsdown::cond_cmpl("uː")`]), "hodd as in cough"(phonologically [`r linguisticsdown::cond_cmpl("ʊ")`]).] Whenever the experimenter noticed that the pronunciations clearly targeted another vowel, recordings were stopped and participants were reminded to carefully read the guide.

The recordings were divided into five blocks: one practice block and four recording blocks, with breaks in between. The purpose of the practice block was threefold: to familiarize the participants with the recording procedure, to adjust the recording level, and if necessary, to further instruct the participant (e.g., if the participant used inappropriate or inconsistent intonation or stress pattern). Each recording block consisted of either 110 (N=2 blocks) or 120 (N=2 blocks) trials. The length of each block was approximately eight minutes, for a total of roughly 30 minutes recording time per talker. After the recording, participants filled out a language background questionnaire and received their reimbursement.

## Word and vowel segmentation {#sec:segmentation}
SweFA, a Swedish version of the Montreal Forced Aligner developed by @young2021, was used to obtain estimates for word and segment boundaries. The boundaries were manually corrected by the first author (an L1 talker of Central Swedish). Following standard segmentation protocol and guidelines in @engstrand2001, segment boundaries were adjusted using spectrogram, waveforms and pitch and intensity tracks. The boundaries between /h/ and the vowel were adjusted to align with clear appearance of an F1, and the boundaries between the vowel and the coda consonant were aligned to a simultaneous rapid cessation of most or all formants.

## Extraction of phonetic cues {#sec:cue-extraction}
We used the Burg algorithm in Praat [@boersma2022] to extract estimates of the first three formants (F1-F3) at five points of the vowel (20, 35, 50, 65, and 80 percent into the vowel). The following parameterization of the Burg algorithm was used:

 * Time step (s): 0.01
 * Max. number of formants: 5
 * Formant ceiling (Hz): 5500
 * Window length (s): 0.025
 * Pre-emphasis from (Hz): 50

In addition to F1-F3, we automatically extracted vowel duration and the fundamental frequency (F0) across the entire vowel.

```{r set-outlier-cutoff-again, include=F}
# What proportion of the most extreme values should be considered outliers?
# (if set to e.g., .05 that means that points with cumulative densities below
# .025 or above .975 are considered outliers)
outlier_probability_cutoff = .01
```

```{r spectrogram, echo=FALSE, fig.cap="Example of Praat textgrid with annotated segment boundaries and measurement points for the automatic extraction of F1-F3 formant frequencies.", fig.width=base.width*1.5, fig.height=base.height*1.5, out.width='40%', fig.align='center'}
knitr::include_graphics("spectrogram.png")
```

In order to correct for measurement errors in the automatic extraction of cues, we estimated the joint multivariate distribution along all five extracted cues (F0, F1, F2, F3, and vowel duration) for each unique combination of vowel and talker. This approach allowed us to detect outliers relative to the joint distribution of the five cues for that vowel and talker. Points outside of the `r 100 * (outlier_probability_cutoff/2)`th to `r 100 * (1 - outlier_probability_cutoff/2)`th quantile of the multivariate Gaussian distribution of each vowel were identified, checked for measurements errors, and corrected. For measurements of the first three formants, we first checked the segmentation boundaries in the Praat textgrid and then manually measured new formant values using visual approximation of time points and Praat's function *Formant: Formant listing* or manually reading off the spectrogram. Segmentation boundaries were also checked for the identified vowel duration outliers. For measurements of F0, we extracted new estimated F0s across the vowel, after changing the pitch range settings. Given that there were still instances of pitch halving after measurement correction, in order to be conservative, we also checked all F0 values below the point of intersection between the two halves. The database available via OSF reports these corrected values (since the recordings and annotation grids are also available via OSF, other researchers can easily derive alternative measurements).^[We note that outlier detection and correction was based on raw, rather than transformed/normalized, cue values. For the studies we report below, this potentially introduces a bias *against* normalization. If anything, the present study is thus likely to under-estimate the effects of normalization.]

The procedure of adding written guides to *hod* and *hodd* to facilitate vowel identification was mostly successful, however not for all talkers. Some talkers corrected themselves after one trial, others failed to produce the intended vowel altogether. The SwehVd database contains columns for both the targeted vowel category, and the vowel category that the talker actually produced (as annotated by the first author).

For the vast majority of talkers, *hädd* productions elicited the same vowel as *hedd* (see Figure \@ref(fig:hedd)). This confirms the common assumption that the short allophone to /e/ neutralizes with the short allophone to [`r linguisticsdown::cond_cmpl("ɛ")`] in Central Swedish.

(ref:hedd) The *hedd* and *hädd* words in the SwehVd vowel data in unnormalized F1-F2 space. Points show recordings of the *hedd* and *hädd* words ([`r linguisticsdown::cond_cmpl("ɛ")`]) by 16 female native talkers in the database, averaged across the five measurement points within each vowel segment. Word labels indicate word means across talkers. Since *hädd* and *hedd* resulted in the same allophone, we exclude *hädd* from this and all other visualizations below. This facilitates comparison of, for example, densities across vowels (see diagonal of Figure \@ref(fig:swe-vowels-all-cues)).

```{r hedd, fig.width=base.width*1.5, fig.height=base.height*1.5, out.width='30%', fig.align='center', fig.cap="(ref:hedd)"}
d.SwehVd %>%
  filter(Transcribed_vowel == "targeted", Word %in% c("hedd", "hädd")) %>%
  # Get the geometric mean F1-F2 across the five time points
  group_by(Talker, Word, Token) %>%
  summarise(across(c(F1, F2), ~ geometric.mean(.x))) %>%
  ggplot(
    aes(
      x = F2,
      y = F1,
      color = Word)) +
  geom_point(alpha = .4) +
  stat_ellipse() +
  # Add between-talker mean
  geom_label(
    data =
      ~ .x %>%
      group_by(Word) %>%
      summarise(across(c(F1, F2), ~ geometric.mean(.x))),
    mapping = aes(
      colour = Word,
      label = Word),
    alpha = .8,
    size = 4,
    label.size = NA) +
  scale_x_reverse("F2 (in Hz)", position = "top", breaks = scales::breaks_pretty(6)) +
  scale_y_reverse("F1 (in Hz)", position = "right", breaks = scales::breaks_pretty(6)) +
  guides(color = "none") +
  theme(legend.position = "top")
```
```{r echo=FALSE}
# Keep code for reproducibility.
# d.SwehVd %<>%
#   mutate(Location = factor(Location))
# contrasts(d.SwehVd$Location) <- MASS::contr.sdif(5)
# m <- lmerTest::lmer(F2~ Location + (1 + Location | Talker), data = d.SwehVd %>% filter(category == "[iː]"))
# summary(m)
```

## Characterizing vowel productions in SwehVd {#sec:characterizing-swehvd}
Figure \@ref(fig:swe-vowels) visualizes the vowel data from the SwehVd in F1-F2 space. The plot highlights the density of the Central Swedish vowel space, the categories are numerous and closely located. Category overlap is especially large among some of the high vowels (e.g., [`r linguisticsdown::cond_cmpl("iː")`] & [`r linguisticsdown::cond_cmpl("yː")`]; [`r linguisticsdown::cond_cmpl("uː")`], [`r linguisticsdown::cond_cmpl("oː")`]  & [`r linguisticsdown::cond_cmpl("ʊ")`]). The contextually conditioned allophone [`r linguisticsdown::cond_cmpl("æ")`], almost completely overlaps with the long [`r linguisticsdown::cond_cmpl("ɛː")`], whereas the contextual allophones to [`r linguisticsdown::cond_cmpl("ø")`] are more separated. Not all contextual allophones are articulated lower (higher F1) in relation to their phonemes [compare e.g., @riad2014]. They are, however, all articulated further back (lower F2).

In line with Riad [-@riad2014, cf. Table \@ref(tab:swedish-vowels) above], the short vowels are overall more centralized and form a more condensed space, whereas the long vowels are more dispersed. Differences in formant patterns between long and short vowels have been found to be smallest for the allophones to [`r linguisticsdown::cond_cmpl("ɛ")`] and [`r linguisticsdown::cond_cmpl("ø")`], and largest for /u/ ([`r linguisticsdown::cond_cmpl("ʉː")`] and [`r linguisticsdown::cond_cmpl("ɵ")`]), and /a/ ([`r linguisticsdown::cond_cmpl("ɑː")`] and [`r linguisticsdown::cond_cmpl("a")`]) [e.g., @fant2001; @kuronen2000]. This pattern does not entirely replicate here. We do see large differences in F1-F2 for the allophones to /u/ and /a/, but also substantial differences between [`r linguisticsdown::cond_cmpl("ɛ")`] and [`r linguisticsdown::cond_cmpl("ɛː")`]. Formant differences are apparent even for some category distinctions for which quantity has been found to be the primary cue [as shown in perceptual studies, see e.g., @behne1997; @haddingkoch1964], ([`r linguisticsdown::cond_cmpl("ɛː")`] - [`r linguisticsdown::cond_cmpl("ɛ")`], [`r linguisticsdown::cond_cmpl("øː")`] - [`r linguisticsdown::cond_cmpl("ø")`], [`r linguisticsdown::cond_cmpl("iː")`] - [`r linguisticsdown::cond_cmpl("ɪ")`], and [`r linguisticsdown::cond_cmpl("oː")`] - [`r linguisticsdown::cond_cmpl("ɔ")`]).

Figure \@ref(fig:swe-vowels-all-cues) visualizes the vowel data from the SwehVd database for all pairwise combinations of five cues: F0, F1, F2, F3 and vowel duration. As is to be expected, vowels differing in quality are most separated in the F1-F2 plot, indicating the two cues most important for vowel category distinction. However, the F1-F3 and F3-F2 plots both display less overlap between the high vowels [`r linguisticsdown::cond_cmpl("iː")`], [`r linguisticsdown::cond_cmpl("yː")`] and [`r linguisticsdown::cond_cmpl("ʉː")`], comparing to when plotted along F1-F2. The increased separation of these categories along F3 in vowel production data could point to the importance of F3 for some category distinctions, as found in previous studies [see e.g., @fant1969; @fujimura1967; @kuronen2000, for [`r linguisticsdown::cond_cmpl("iː")`] and [`r linguisticsdown::cond_cmpl("yː")`] categorization].

Also as expected, duration is the primary cue that distinguishes vowel quantity: in the last column of Figure \@ref(fig:swe-vowels-all-cues), the short vowels cluster on the left, and the long vowels on the right. They are separable, but overlapping. Overall, the short vowels seem to display less variability in duration than the long vowels, a common pattern for measures with a lower bound. In addition to duration, F1-F3 can also carry information about vowels differing in quantity. This is evident, for example, for [`r linguisticsdown::cond_cmpl("iː")`] vs. [`r linguisticsdown::cond_cmpl("ɪ")`], [`r linguisticsdown::cond_cmpl("yː")`] vs. [`r linguisticsdown::cond_cmpl("ʏ")`], [`r linguisticsdown::cond_cmpl("ʉː")`] vs. [`r linguisticsdown::cond_cmpl("ɵ")`], [`r linguisticsdown::cond_cmpl("ɑː")`] vs. [`r linguisticsdown::cond_cmpl("a")`], [`r linguisticsdown::cond_cmpl("ɛː")`] vs. [`r linguisticsdown::cond_cmpl("ɛ")`] in F1-F2 space, and for [`r linguisticsdown::cond_cmpl("iː")`] vs. [`r linguisticsdown::cond_cmpl("ɪ")`], [`r linguisticsdown::cond_cmpl("yː")`] vs. [`r linguisticsdown::cond_cmpl("ʏ")`], [`r linguisticsdown::cond_cmpl("ʉː")`] vs. [`r linguisticsdown::cond_cmpl("ɵ")`] in F2-F3 space.

Finally, the densities along the diagonal of Figure \@ref(fig:swe-vowels-all-cues) suggest that F0 carries the least information about vowel identity, exhibiting the least between-category separation, followed by F3. This, too, is not surprising: while some accounts use F0 to _normalize_ F1 and F2 [e.g., @miller1989c; @Syrdal1986], F0 is not considered an important cue to vowel identity by itself.

(ref:swe-vowels) The SwehVd vowel data in unnormalized F1-F2 space. Points show recordings of each of the 21 Central Swedish vowels by 16 female native talkers in the database, averaged across the five measurement points within each vowel segment. Vowel labels indicate category means across talkers. Long vowels are boldfaced. Vowels that mismatched intended label are excluded (`r signif((d.SwehVd %>% filter(Transcribed_vowel != "targeted") %>% nrow() / d.SwehVd %>% nrow()) * 100)`% of all recordings). Note that the F1 and F2 axes are reversed. We follow this convention whenever plotting vowels in the F1-F2 space.

(ref:swe-vowels-all-cues) The SwehVd vowel data. Points show recordings of each of the 21 Central Swedish vowels by 16 female native talkers in the database in F0-F3 and vowel duration cue space, averaged across all five measurement points. Vowel labels indicate category means across talkers. Long vowels are boldfaced. Ellipses show bivariate Gaussian 95% confidence interval of category means. Note that, unlike in Figure \@ref(fig:swe-vowels), axis directions are not reversed. Vowels that mismatched the intended label are excluded (`r signif((d.SwehVd %>% filter(Transcribed_vowel != "targeted") %>% nrow() / d.SwehVd %>% nrow()) * 100)`% of all recordings).

```{r swe-vowels, fig.width=base.width*3, fig.height=base.height*3, out.width='70%', fig.align='center', fig.cap="(ref:swe-vowels)"}
d.SwehVd %>%
  filter(Transcribed_vowel == "targeted", Word != "hädd") %>%
  # Get the geometric mean F1-F2 across the five time points
  group_by(Talker, category, Token, Quantity) %>%
  summarise(across(c(F0, F1, F2, F3, Duration), ~ geometric.mean(.x))) %>%
  ungroup() %>%
  ggplot(
    aes(
      x = F2,
      y = F1)) +
  geom_point(
    aes(
      colour = category,
      shape = Quantity),
    alpha = .4) +
  # Add between-talker mean
  geom_label(
    data =
      ~ .x %>%
      group_by(category, Quantity) %>%
      summarise(across(c(F0, F1, F2, F3, Duration), ~ geometric.mean(.x))),
    mapping = aes(
      colour = category,
      label = category,
      fontface = ifelse(category %in% levels.vowel.IPA.swe.long, 2, 1)),
    alpha = .8,
    size = 4,
    label.size = NA,
    label.padding = unit(.06, "cm")) +
  scale_colour_manual(name = "category", values = colors.vowel.swe) +
  scale_x_reverse("F2 (in Hz)", position = "top", breaks = scales::breaks_pretty(6)) +
  scale_y_reverse("F1 (in Hz)", position = "right", breaks = scales::breaks_pretty(6)) +
  guides(color = "none") + 
  myGplot.defaults(base_size+2)  +
  theme(legend.position = "top")
```

```{r swe-vowels-all-cues, fig.width=base.width*4.5, fig.height=base.height*4.5+.5, out.width = '100%', fig.cap="(ref:swe-vowels-all-cues)"}
p.matrix.cues <-
  d.SwehVd %>%
  filter(Transcribed_vowel == "targeted", Word != "hädd") %>%
  # Get the geometric mean across all five time points for the five cues
  group_by(Talker, category, Token, Quantity) %>%
  summarise(across(c(F0, F1, F2, F3, Duration), ~ geometric.mean(.x))) %>%
  ungroup() %>%
  ggplot(
    aes(
      x = .panel_x,
      y = .panel_y)) +
  geom_point(
    aes(
      colour = category,
      shape = Quantity),
    alpha = .1) +
  geom_label(
    data =
      ~ .x %>%
      group_by(category, Quantity) %>%
      summarise(across(c(F0, F1, F2, F3, Duration), ~ mean(.x))),
    mapping = aes(
      colour = category,
      label = category,
      fontface = ifelse(category %in% levels.vowel.IPA.swe.long, 2, 1)),
    alpha = .4, size = 3, label.size = NA) +
  geom_autodensity(
    mapping = aes(fill = category, linetype = Quantity),
    alpha = .3, position = "identity") +
  stat_ellipse(
    mapping = aes(
      colour = category,
      linetype = Quantity),
    alpha = .4) +
  geom_point(
    data =
      ~ .x %>%
      group_by(category, Quantity) %>%
      summarise(across(c(F0, F1, F2, F3, Duration), ~ mean(.x))),
    mapping = aes(
      colour = category,
      shape = Quantity),
    alpha = .8, size = 1) +
  scale_colour_manual(name = "category", values = colors.vowel.swe, aesthetics = c("colour", "fill")) +
  guides(color = "none", fill = "none", shape = guide_legend(override.aes = list(alpha = .4))) +
  facet_matrix(
    vars(F0, F1, F2, F3, Duration),
    layer.lower = c(1,2),
    layer.diag = 3,
    layer.upper = c(4, 5)) +
  myGplot.defaults(base_size+2) + 
  theme(legend.position = "top")

p.matrix.cues
```

# Study 1: Comparing the effects of normalization accounts on between- vs. within-category variability {#sec:studyI}
In Study 1, we follow previous research on the effects of different normalization accounts on category variability, by evaluating how effectively different normalization accounts reduce the within-category variability of Central Swedish vowels. We visualize the vowel space under different normalization accounts, and assess the effects on vowel category variability by calculating a measure of category separability. To anticipate one take-home point of Study 1, the results highlight important shortcomings of separability indices in evaluating normalization accounts, which motivates Study 2.

```{r}
#Write table of previous studies
norm_accounts_eval <- tibble(
      "Language investigated" = c(
                              "US English",
                              "US English",
                              "US English",
                              "US English",
                              "US English, Norwegian, Swedish, German, Danish, Dutch",
                              "UK English",
                              "UK English",
                              "Russian"),

      "Article" = c(
               "Clopper, 2009",
               "Hindle, 1978",
               "Kohn & Farrington, 2012",
               "Labov, 2010",
               "Disner, 1980",
               "Fabricius, Watt & Johnson, 2009",
               "Flynn & Foulkes, 2011",
               "Lobanov, 1971"),

  "Speech materials" = c(
                         "2 female/male talkers from Ohio (1 token * 10 vowels)",
                         "Peterson & Barney's (1952) database; 19 female/male talkers from Philadelphia + 60 telephone informants (minimum 3 tokens per category; analysis focus on /ay/)",
                         "Longitudinal data from 10 female/male African American talkers from North Carolina (approx. 10 tokens * 10 vowels * 5 ages)",
                         "Peterson & Barney's (1952) database; Philadelphia/Linguistic Change and Variation project (120 female/male talkers, stratified for age, sociolinguistic factors)",  
                         "Differing number of tokens, vowels, and phonetic contexts across the six languages",
                         "20 old/young female/male talkers of Received pronunciation (11 vowels); 6 old/young female/male talkers of Aberdeen English (8 vowels in different phonetic contexts)",
                         "20 old/young female/male Nottingham talkers (mean 180 recordings per talker; categories not reported)",
                         "5 female/male talkers (9 vowels in different phonetic contexts)"),

  "Normalization accounts" = c(
                                         "Bladon et al.'s scale factor of 1 Bark (1994), Syrdal & Gopal, Nordström & Lindblom, Nearey1, Nearey2, Watt & Fabricius, Gerstman, Lobanov, Miller",
                                         "Nearey2, Nordström-Lindblom, Sankoff-Shorrock-McKay",
                                         "Lobanov, Gerstman, Nearey1, Nordström & Lindblom, Syrdal & Gopal/Thomas, Watt & Fabricius",
                                         "Nearey2, Nordström-Lindblom, Sankoff-Shorrock-McKay ",
                                         "Gerstman, Lobanov, Nearey2, Harshman's PARAFAC model",
                                         "Watt & Fabricius, Lobanov, Nearey1",
                                         "log-transformation (base 10), log-transformation (natural), Mel, ERB, Bark (*2 gender-specific versions), Syrdal & Gopal, Nordström (*2 gender-specific versions), LCE, Gerstman, Lobanov, Watt & Fabricius (* 4 versions), lettER, Nearey (*4 versions)",
                                         "linear compression or expansion (Fant, 1960), Gerstman, Lobanov"),

  "Approach" = c(
                        "variance reduction (visual inspection)",
                        "distance between means, variance reduction (regression)",
                        "variance reduction (regression)",
                        "distance between means (F-statistics)",
                        "variance reduction (visual inspection)",
                        "variance reduction (SCV in talker-means)",
                        "variance reduction (SCV in talker-means)",
                        "distance between means"),

  "Best two performing" = c("Nearey, Watt & Fabricius, Gerstman, Lobanov (no order)",
                            "Sankoff (1)",
                            "Lobanov (1), Gerstman, Watt & Fabricius (2)",
                            "Sankoff (1), Nearey2 (2)",
                            "Nearey2 (1), Lobanov (2)",
                            "Lobanov (1), Watt & Fabricius (2)",
                            "Gerstman (1), LCE (2)",
                            "Lobanov (1), Gerstman (2)"))
```


```{r norm-evaluation-variability, results='asis'}
norm_accounts_eval %>%
  kable(
    format = "latex",
    booktabs = TRUE,
    caption = "Previous studies comparing the effectiveness of normalization accounts in reducing within-category cue variability") %>%
  kable_styling(font_size = 7) %>%
  column_spec(1:2, width = "2cm") %>%
  column_spec(3:4, width = "5cm") %>%
  column_spec(5:6, width = "2cm") %>%
  landscape() %>%
  collapse_rows()
```

Table \@ref(tab:norm-evaluation-variability) lists previous studies that have compared normalization accounts in terms of their effectiveness in reducing inter-talker variability. These studies varied in the specific metrics they employed to assess the effects of normalization, the languages they studied, and the conclusions they arrived at. Two generalizations emerge from Table \@ref(tab:norm-evaluation-variability). First, transformation to a perceptual scale alone does not seem to be sufficient to reduce inter-talker variability [see also @adank2004; @carpenter1993; @clopper2009; @escudero2007; @Flynn2011; @kohn2012a]. Second, normalization accounts that include centering and/or scaling seem to perform best in reducing inter-talker variability [see e.g. @disner1980; @fabricius2009; @kohn2012a; @labov2010; @lobanov1971]. When Lobanov and Gerstman normalization---both involving scaling---were included in a study, they often rank among the top two performing accounts. Of note, Nearey normalization [@nearey1978] seems to perform well even though it does not involve scaling. This suggests that simple centering of formants relative to the talker's mean *might* be sufficient to achieve significant variance reduction [but see @disner1980 for Swedish, which is revisited in this study].<!-- Commented out for now as it doesn't seem critical. ^[Some studies have further investigated the extent to which different normalization accounts remove socially-relevant variance along with the intended removal of physiologically-caused variance [e.g., @adank2004; @disner1980; @hindle1978; @labov2010]. Removal of socially-relevant variance has been argued to be problematic for two separate reasons. First, for *researchers* who employ normalization as part of their data analysis, it can make it difficult to investigate the effects of social variables on pronunciation. Second, as a theory of how *listeners* overcome the lack of invariance in the speech signal, it has been argued to conflict with the finding that listeners infer social group membership from speech signal [@REFS]. Only this latter concern is of relevant for the present study, and---as others have pointed out---normalization does not necessarily mean that the raw input to normalization is discarded [@sumner2014; @OTHERS]. We thus do not further discuss this aspect.]  -->

## Methods {#sec:methodsI}

```{r}
# Make temp exclusions file for identifying no of talkers to exclude
d.SwehVd.exclusions <-
  d.SwehVd %>%
  select(c(Talker, category, Transcribed_vowel, Token)) %>%
  distinct() %>%
  group_by(Talker, category) %>%
  summarise(
    N_tokens_per_category = n_distinct(Token),
    Transcribed_vowel = Transcribed_vowel) %>%
  filter(Transcribed_vowel != "targeted") %>%
  group_by(Talker, category, N_tokens_per_category) %>%
  summarise(
    N_unidentifiable_vowels = length(Transcribed_vowel)) %>%
  group_by(Talker, category) %>%
  mutate(
    exclude_Talker = case_when(N_tokens_per_category < 6 & N_unidentifiable_vowels >= 1 ~ "TRUE",
                               N_tokens_per_category >= 10 & N_unidentifiable_vowels > 6 ~ "TRUE",
                               TRUE ~ "FALSE")) %>%
  filter(exclude_Talker == TRUE)
```

```{r filter-data-for-study}
set.seed(234215432)
# Exclude talkers that failed to produce *hodd* altogether + the mispronounced words by remaining talkers. This approach results in exclusion of an additional two talkers, given that they only did five recordings for each vowel. Also exclude measurements at 20 and 80% into the vowel, and all /hädd/ words since they are a duplicate of "[ɛ]" - the short allophone to /e/ neutralizes with the short allophone to /ɛ/. Also exclude all NAs in F0s.
d.SwehVd.forStudy <-
  d.SwehVd %>%
  filter(!Talker %in% d.SwehVd.exclusions$Talker, Transcribed_vowel == "targeted", Location %in% c(35, 50, 65), Word != "hädd", !is.na(F0)) %>%
  select(-Transcribed_vowel) %>%
  # Get the geometric mean across the three time points for the five cues
  group_by(Talker, Age, L1, category, Word, Token, Trial, Quantity) %>%
  summarise(across(c(F0, F1, F2, F3, Duration), ~ geometric.mean(.x))) %>%
  ungroup()
```

```{r createCV}
# This creates K = 5 copies of the data, each distinguished by crossvalidation_group
# Each copy consists of K = 5 bins each, K - 1 = 4 of which are of fold_type "training"
# and 1 of which is of fold_type "test".
d.SwehVd.forStudy %<>%
# Split data into five equally sized bins  
  split_data() %>%
  #add groupID, assign bins to training or testing depending on groupID
  crossing(crossvalidation_group = 1:5) %>%
  mutate(
    fold_type = case_when(crossvalidation_group == 1 & fold != 5 ~ "training",
                     crossvalidation_group == 2 & fold != 1 ~ "training",
                     crossvalidation_group == 3 & fold != 2 ~ "training",
                     crossvalidation_group == 4 & fold != 3 ~ "training",
                     crossvalidation_group == 5 & fold != 4 ~ "training"),
    fold_type = replace_na(fold_type, "test")) %>%
  arrange(crossvalidation_group)
```

### Speech materials {#sec:speechMaterialsI}
We use the SwehVd database with some exclusions. Since we are interested in assessing the effects of normalization, we excluded any productions on which the talker did not produce the targeted vowel. We then excluded all talkers (N = `r n_distinct(d.SwehVd.exclusions$Talker)`) with fewer than 5 remaining recordings for at least one of the vowels. Five of these talkers rarely ever produced the targeted [`r linguisticsdown::cond_cmpl("ʊ")`] vowel despite our recording instructions (see Section \@ref(sec:cue-extraction)). Instead, these talkers often mispronounced the vowel (for three of these five talkers, there was overall less data since they only attended the first recording session). Two additional talkers mispronounced the vowel once, but since these talkers only attended the first recording session, they were excluded. This left data from `r n_distinct(d.SwehVd$Talker) - n_distinct(d.SwehVd.exclusions$Talker)` female native talkers, with on average `r d.SwehVd.forStudy %>% group_by(category) %>% tally() %>% summarise(x = mean(n)) %>% pull() %>% round(digits = 0)` (se= `r d.SwehVd.forStudy %>% group_by(category) %>% tally() %>% summarise(x = se(n)) %>% pull() %>% round(digits = 1)`) tokens per vowel (range = `r d.SwehVd.forStudy %>% group_by(category) %>% tally() %>% summarise(x = min(n)) %>% pull() %>% round(digits = 0)` to `r d.SwehVd.forStudy %>% group_by(category) %>% tally() %>% summarise(x = max(n)) %>% pull() %>% round(digits = 0)`), for a total of `r nrow(d.SwehVd.forStudy)` observations.

Since our goal is to obtain a reliable estimate of the formant values during the steady state of the vowel, we use only the three formant measurements extracted from the middle of the vowel (at 35%, 50%, and 65% into the vowel).

We also exclude all *hädd* productions, as they elicited the same vowel as *hedd* (see Section \@ref(sec:cue-extraction)). This way, we have about equally many tokens from all vowels, simplifying the cross-validation procedure presented below and facilitating visual comparisons across vowels in our figures.

### Cues included in the normalization {#sec:cues}
We compare the effect of different normalization accounts on the variability of Swedish vowels under three different assumptions about the relevant cues. The first comparison follows most previous research and focuses on the two primary cues to vowel perception, F1 and F2. The second comparison considers F3 in addition to F1 and F2, following @adank2004, @barreda2018a, @nearey1989 and @syrda1985.^[@adank2004, @nearey1989 and @syrda1985 additionally included F0. However, since F0 is a cue that can display substantial cross-talker variability, without necessarily contributing to vowel categorization (recall Figure \@ref(fig:swe-vowels-all-cues)), its inclusion can reduce the informativeness of the separability index. We therefore decided to add only F3 to F1-F2 in the second evaluation.] Finally, the third comparison includes F0 and duration in addition to F1-F3. Since C-CuRE is the only account that applies to any type of cue, we will consider duration as centered to each talker's mean (for the C-CuRE accounts), or as raw input (in ms; for all other accounts). To our knowledge, duration has not been considered in previous studies on normalization, presumably because the present study is the first to evaluate normalization accounts against a vowel system with a systematic quantity distinction (long vs. short vowels). We evaluate the effect on variability both separately for long and short vowels, and on all 21 vowels together.

### Separability index {#sec:separabilityIndex}
Previous studies have used different measures to assess the relative success of a normalization procedure in reducing inter-talker variability [see Table \@ref(tab:norm-evaluation-variability) and @nearey1989 for an overview on classification accounts]. This includes assessing the reduction in variance or distance between means by visual inspection [e.g., @clopper2009; @disner1980; @hindle1978], or by calculating the reduction in within-category variance across talkers [e.g., @disner1980; @fabricius2009; @Flynn2011; @hindle1978], or comparing the degree of separation between category means for unnormalized and normalized data, i.e., an F-ratio [e.g., @labov2010].

We will assess how distinguishable vowels become under different normalization accounts by calculating a separability index, as described in Equation \@ref(eq:separability-index). Following some previous studies [e.g., @labov2010], this separability index is essentially an F statistics, where the F statistics is the ratio of the within- and between-category variances:

\begin{equation}\label{eq:separability-index}
 separability\ index = \frac{\sum\limits_{c=1,\ldots,K}(N_{c}-1)}{\sum\limits_{c=1,\ldots,K} \sum\limits_{i=1,\ldots,N_{c}}(x_{i,c}-\bar{x}_{c})^{2}}
\end{equation}

where $N_c$ is the number of observations for category $c$, $x_{i,c}$ is the vector of cue values (for all cues considered in the calculation of the separability index) for observation $i$ of category $c$, and $\bar{x}_c$ is the vector of cue means for category $c$. We calculated this separability index separately for each combination of normalization account, cues, and training-test fold, as described next.

### Guarding against over-fitting: cross-validation {#sec:folds}
As shown in Table \@ref(tab:norm-accounts), many of the normalization accounts involve parameters that are set based on the data [e.g., @gerstman1968; @lobanov1971; @mcmurray-jongman2011; @miller1989c; @nearey1978]. This raises the question of how much these parameters can be affected by outliers, or other issues such as over-fitting to the sample. Unlike previous work, we thus use 5-fold cross-validation to obtain 5 separate estimates of the separability index for each combination of normalization procedure and cues. Specifically, we randomly split the data for each unique combination of talker and vowel into 5 even parts (folds). On each of the five folds, we then fit the normalization parameters based on four of the folds (the training data) and evaluated the effects of the normalization on the fifth fold (the test data). This resulted in five separability indices for each combination of normalization procedure and cues.

## Results {#sec:resultsI}

### Visualizing the distribution of vowel productions {#sec:normVowelSpace}
Figures \@ref(fig:swe-vowels-normalized-long) and \@ref(fig:swe-vowels-normalized-short) visualize the Central Swedish vowels in the test data, after applying the 15 different scale-transformations and normalization accounts for a visual inspection. For this purpose, we focus on F1 and F2 only. The SI includes similar pairwise correlation plots of all cues for all different normalization accounts we compare (see Section \@ref(sec:correlation-matrices) in SI).

Visual inspection suggests a few initial observations. The most striking difference is perhaps between intrinsic normalization accounts [@Syrdal1986; @miller1989c] and all other approaches, though it is not immediately visually obvious which type of approach achieves better separability. Second, transforming the vowels to a different perceptual scale does not seem to affect the vowel distributions much, besides a minor decrease in category variance for some of the vowels. Some transformations bring the vowel categories closer together, towards the center of the vowel space, e.g., ERB and semitones. Third, centering formants to each talkers' mean [@mcmurray-jongman2011; @nearey1978] reduces some of the category variance, and as a result, increases the category separability. Transforming the vowel data into different scales prior to centering also seems to further improve separability (compare e.g., C-CuRE (Hz) and C-CuRE (semitones)). Overall, the top two performing accounts across the long and short vowels appear to @lobanov1971 and @nearey1978.

Notably, even for the best performing accounts, there is still considerable category overlap. This involves some of the high long vowels, and some of the mid-center short vowels. This highlights the need to more systematically quantify the effects of normalization, as we do next for category separability and then in more depth in Study 2.

```{r norm-data}
#Remove temp file
rm(d.SwehVd.exclusions)

#DEBUG----------------------------------------------
d.debug.norm <- d.SwehVd.forStudy
# Normalize all data based on the respective training of each cross-validation group
d.SwehVd.forStudy %<>%
  group_by(crossvalidation_group) %>%
  # Get transformations, apply normalizations (both classic formants one and C-CuRE)
  group_map(
    .f = ~ apply_all_transformations_and_normalization(data = .x),
    .keep = T
  ) %>%
  reduce(bind_rows) %>%
  ungroup()
```

(ref:swe-vowels-normalized-long) The Central Swedish long vowels in the unnormalized and normalized test data used in Study 1. Points show all tokens of each of the 11 Central Swedish long vowels included in the test data in F1-F2 space. Unnormalized vowels and vowels transformed to different perceptual scales (**grey**), vowels normalized by intrinsic accounts (**yellow**), vowels in all scale-transformations further normalized to C-CuRE and other centering accounts (**blue**), and finally, vowels normalized by scaling accounts (**purple**).

(ref:swe-vowels-normalized-short) The Central Swedish short vowels in the unnormalized and normalized test data used in Study 1. Points show all tokens of each of the 10 Central Swedish short vowels included in the test data in F1-F2 space. Unnormalized vowels and vowels transformed to different perceptual scales (**grey**), vowels normalized by intrinsic accounts (**yellow**), vowels in all scale-transformations further normalized to C-CuRE and other centering accounts (**blue**), and finally, vowels normalized by scaling accounts (**purple**).

```{r echo=FALSE}
# Pivot data to long format for plotting and calculation of separability index
d.SwehVd.forStudy.long <-
  d.SwehVd.forStudy %>%
  pivot_longer(
    cols = starts_with("F", ignore.case = FALSE),
    names_to = c("Cue", "Normalization.Scale", "Normalization.Type"),
    names_sep = "_",
    values_to = "Cue.Value") %>%
  pivot_wider(
    names_from = "Cue",
    values_from = "Cue.Value") %>%
  # Mutate both
  mutate(
    Normalization.Type = paste(Normalization.Scale, Normalization.Type, sep = "_")) %>%
  mutate(
    Normalization.Type = factor(plyr::mapvalues(Normalization.Type, levels.normalization, labels.normalization), levels = labels.normalization, ordered = T),
    Duration = ifelse(Normalization.Type %in% c("C-CuRE (Hz)", "C-CuRE (Mel)", "C-CuRE (ERB)", "C-CuRE (Bark)", "C-CuRE (semitones)"), Duration_CCuRE, Duration)) %>%
   select(-c(Duration_CCuRE, Normalization.Scale)) %>%
   relocate(Talker, L1, Age, Normalization.Type, crossvalidation_group, fold_type, fold, category, Quantity, Token)

#Attempt with grob.element
element_textbox_highlight <- function(
    ...,
    hi.labels = NULL, hi.fill = NULL,
    hi.col = NULL, hi.box.col = NULL,
    hi.labels2 = NULL, hi.fill2 = NULL,
    hi.col2 = NULL, hi.box.col2 = NULL,
    hi.labels3 = NULL, hi.fill3 = NULL,
    hi.col3 = NULL, hi.box.col3 = NULL
) {
  structure(
    c(ggtext::element_textbox(...),
      list(hi.labels = hi.labels, hi.fill = hi.fill, hi.col = hi.col, hi.box.col = hi.box.col,
           hi.labels2 = hi.labels2, hi.fill2 = hi.fill2, hi.col2 = hi.col2, hi.box.col2 = hi.box.col2,
           hi.labels3 = hi.labels3, hi.fill3 = hi.fill3, hi.col3 = hi.col3, hi.box.col3 = hi.box.col3)),
    class = c("element_textbox_highlight", "element_textbox", "element_text", "element",
              "element_textbox_highlight", "element_textbox", "element_text", "element",
              "element_textbox_highlight", "element_textbox", "element_text", "element"))
}

element_grob.element_textbox_highlight <- function(element, label = "", ...) {
  if (label %in% element$hi.labels) {
    element$fill <- element$hi.fill %||% element$fill
    element$colour <- element$hi.col %||% element$colour
    element$box.colour <- element$hi.box.col %||% element$box.colour
  }
  if (label %in% element$hi.labels2) {
    element$fill <- element$hi.fill2 %||% element$fill
    element$colour <- element$hi.col2 %||% element$colour
    element$box.colour <- element$hi.box.col2 %||% element$box.colour
  }
  if (label %in% element$hi.labels3) {
    element$fill <- element$hi.fill3 %||% element$fill
    element$colour <- element$hi.col3 %||% element$colour
    element$box.colour <- element$hi.box.col3 %||% element$box.colour
  }
  NextMethod()
}

# Plot vowel data in all normalization formats
p.vowels.norm.long <-
  d.SwehVd.forStudy.long %>%
  # filter down to test folds since that's what we later evaluate SI and IOs for
  filter(fold_type == "test", Quantity == "long") %>%
  ggplot(
    aes(
      x = F2,
      y = F1)) +
  geom_point(
    aes(
      colour = category,
      shape = Quantity),
    alpha = 0.4,
    size = .7) +
  scale_colour_manual(name = "category", values = colors.vowel.swe) +
  scale_x_reverse("F2", position = "top", scales::pretty_breaks(n = 3)) +
  scale_y_reverse("F1", position = "right", scales::pretty_breaks(n = 3)) +
  guides(alpha = "none", color = "none", shape = "none") +
  facet_wrap(~ factor(Normalization.Type, levels = labels.normalization), scales = "free", ncol = 5) +
  theme(
    axis.title.y = element_blank()) +
    cowplot::theme_half_open(12) +
    cowplot::background_grid() +
    theme(
      strip.background = element_blank(),
      strip.text = element_textbox_highlight(
        size = 8,
        color = "black", fill = "#C9C0BB", box.color = "#C9C0BB",
        halign = 0.5, linetype = 1, r = unit(3, "pt"),
        #width = unit(1, "npc"),
        padding = margin(2, 3, 2, 3), margin = margin(3, 3, 3, 3),
        #margin = margin(0.6, 0.5, 0.5, 0.3),
        # this is new relative to element_textbox():
        # first named set
        hi.labels = c("SyrdalGopal (Bark)", "Miller (log)"),
        hi.fill = "#E6BE8A", hi.col = "black", hi.box.col = "#E6BE8A",
        # add second set
        hi.labels2 = c("C-CuRE (Hz)", "C-CuRE (Mel)", "C-CuRE (Bark)", "C-CuRE (ERB)", "C-CuRE (semitones)", "Nearey1 (log)", "Nearey2 (log)"),
        hi.fill2 = "#ABCDEF", hi.col2 = "black", hi.box.col2 = "#ABCDEF",
        # add third set
        hi.labels3 = c("Gerstman (Hz)", "Lobanov (Hz)"),
        hi.fill3 = "#DDADAF", hi.col3 = "black", hi.box.col3 = "#DDADAF"),
      axis.text.x = element_text(size=8, vjust=1),
      axis.text.y = element_text(size=8, hjust=1, vjust=.5),
      axis.title.x = element_text(size=8, vjust=0, hjust=0.5, face = "bold"),
      axis.title.y = element_text(size=8, hjust= 0.5, vjust=0.5, face = "bold"),
      legend.title = element_text(size=8, face = "bold", hjust= 0),
      legend.text = element_text(size=8),
      strip.placement = "outside",
      aspect.ratio = 1,
      panel.grid.major = element_blank())
```

\begin{landscape}

```{r swe-vowels-normalized-long, fig.width=base.width * 4, fig.height=base.height * 3, fig.align='center', fig.cap="(ref:swe-vowels-normalized-long)"}
p.vowels.norm.long
```

\end{landscape}

```{r echo=FALSE}
# Plot vowel data in all normalization formats
p.vowels.norm.short <- p.vowels.norm.long %+%
  (d.SwehVd.forStudy.long %>%
     filter(fold_type == "test", Quantity == "short")) +
  geom_point(aes(color = category),
             shape = 17,
             alpha = .4,
             size = .7)
```

\begin{landscape}
```{r swe-vowels-normalized-short, fig.width=base.width * 4, fig.height=base.height * 3, fig.align='center', fig.cap="(ref:swe-vowels-normalized-short)"}
p.vowels.norm.short
```

\end{landscape}

### The effect of normalization accounts on the variability of Central Swedish vowels {#sec:normVariability}
In order to assess the effects of normalization accounts on category separability, we calculate a separability index under different assumptions about the relevant cues and the size of the vowel space (the long and short vowels separately, or the entire space). Before we evaluate how category separability is affected by normalization in F1-F2, F1-F3 and F0-F3 and duration space, we look at how the normalization accounts affect the separability of vowels along each cue separately (Figure \@ref(fig:separability-by-cue)). As we show below, this is helpful in understanding the subsequently presented results for combinations of cues.

```{r}
cues <- c("F0", "F1", "F2", "F3", "Duration")

# Calculate a separability index for all categories and all normalization accounts.
# First get within-category means
d.SwehVd.forStudy.long.within_category_MS <-
  d.SwehVd.forStudy.long %>%
  # Reduce to test fold of each crossvalidation group since that's what we want to know SI for
  filter(fold_type == "test") %>%
  # Get within category MS and pseudo-MS
  group_by(Normalization.Type, category, crossvalidation_group, fold_type, fold) %>%
  summarise(
    # First obtain df and SS for each cues
    across(
      .cols = cues,
      .fns = list(
        "within_df" = ~ if (sum(!is.na(.x)) == 0) { NA } else { sum(!is.na(.x)) - 1}, # Set cases with 0 DFs to NA (happens when cue is not defined for a normalization type)
        "category_mean" = ~ mean(.x, na.rm = T)),
      .names = "{.fn}_{.col}"),
    across(
      .cols = cues,
      .fns = list("within_SS" = ~ if (sum(!is.na(.x)) == 0) { NA } else { sum((.x - get(glue("category_mean_{cur_column()}")))^2, na.rm = T) }),
      .names = "{.fn}_{.col}"),
    # Now get all the measures *across* cues
    within_df_F1F2 = pmin(within_df_F1, within_df_F2),
    within_df_F1F3 = pmin(within_df_F1, within_df_F2, within_df_F3),
    within_df_all = pmin(within_df_F0, within_df_F1, within_df_F2, within_df_F3, within_df_Duration),
    within_SS_F1F2 = within_SS_F1 + within_SS_F2,
    within_SS_F1F3 = within_SS_F1 + within_SS_F2 + within_SS_F3,
    within_SS_all = within_SS_F0 + within_SS_F1 + within_SS_F2 + within_SS_F3 + within_SS_Duration,
    # Get within-category MS
    across(
      .cols = paste0("within_SS_", c(cues, "F1F2", "F1F3", "all")),
      .fns = list("pseudo_within_MS" = ~ .x / get(glue(gsub("within_SS_", "within_df_", cur_column())))),
      .names = "{.fn}_{.col}")) %>%
  rename_with(~ gsub("_within_SS", "", .x))
```

```{r}
get_SI <-
  . %>%
  group_by(Normalization.Type, crossvalidation_group) %>%
  summarise(
    across(
      .cols = paste0("within_SS_", c(cues, "F1F2", "F1F3", "all")),
      .fns = list("within_MS" = ~ sum(.x, na.rm = T) / sum(get(glue(gsub("within_SS_", "within_df_", cur_column()))), na.rm = T)),
      .names = "{.fn}_{.col}")) %>%
  rename_with(~ gsub("_within_SS", "", .x)) %>%
  left_join(
    d.SwehVd.forStudy.long %>%
      # Get overall mean within each normalization approach
      group_by(Normalization.Type, crossvalidation_group) %>%
      mutate(
        across(
          .cols = cues,
          .fns = list("overall_mean" = ~ mean(.x, na.rm = T)),
          .names = "{.fn}_{.col}")) %>%
      group_by(Normalization.Type, category, crossvalidation_group) %>%
      # Get category means and carry through overall mean
      summarise(
        across(
          .cols = paste0("overall_mean_", cues),
          first),
        across(
          .cols = cues,
          .fns = list("category_mean" = ~ mean(.x, na.rm = T)),
          .names = "{.fn}_{.col}")) %>%
      # Get between-category SS and MS
      group_by(Normalization.Type, crossvalidation_group) %>%
      summarise(
        # First obtain df and SS for each cues
        across(
          .cols = paste0("category_mean_", cues),
          .fns = list(
            "between_df" = ~ if (sum(!is.na(.x)) == 0) { NA } else { sum(!is.na(.x)) - 1},  # Set cases with 0 DFs to NA (happens when cue is not defined for a normalization type)
            "between_SS" = ~ if (sum(!is.na(.x)) == 0) { NA } else { sum((.x - get(glue(gsub("category_mean", "overall_mean", cur_column()))))^2, na.rm = T) }),
          .names = "{.fn}_{.col}"),
        # Now get all the measures *across* cues
        between_df_category_mean_F1F2 = pmin(between_df_category_mean_F1, between_df_category_mean_F2),
        between_df_category_mean_F1F3 = pmin(between_df_category_mean_F1, between_df_category_mean_F2, between_df_category_mean_F3),
        between_df_category_mean_all = pmin(between_df_category_mean_F0, between_df_category_mean_F1, between_df_category_mean_F2, between_df_category_mean_F3, between_df_category_mean_Duration),
        between_SS_category_mean_F1F2 = between_SS_category_mean_F1 + between_SS_category_mean_F2,
        between_SS_category_mean_F1F3 = between_SS_category_mean_F1 + between_SS_category_mean_F2 + between_SS_category_mean_F3,
        between_SS_category_mean_all = between_SS_category_mean_F0 + between_SS_category_mean_F1 + between_SS_category_mean_F2 + between_SS_category_mean_F3 + between_SS_category_mean_Duration,
        # Get between-category MS
        across(
          .cols = paste0("between_SS_category_mean_", c(cues, "F1F2", "F1F3", "all")),
          .fns = list("between_MS" = ~ sum(.x / get(glue(gsub("between_SS", "between_df", cur_column()))))),
          .names = "{.fn}_{.col}")) %>%
      rename_with(~ gsub("(_between_SS)?_category_mean", "", .x)),
        by = c("Normalization.Type", "crossvalidation_group")) %>%
  # Now get the separability index
  group_by(Normalization.Type, crossvalidation_group) %>%
  mutate(
    across(
      .cols = paste0("between_MS_", c(cues, "F1F2", "F1F3", "all")),
      .fns = list("SI" = ~ sum(.x / get(glue(gsub("between_", "within_", cur_column()))))),
      .names = "{.fn}_{.col}")) %>%
  rename_with(~ gsub("_between_MS", "", .x)) %>%
  mutate_if(is.numeric, round, digits = 4)

d.SwehVd.forStudy.SI <- rbind(
  d.SwehVd.forStudy.long.within_category_MS %>%
    filter(category %in% levels.vowel.IPA.swe.long) %>%
    get_SI() %>%
    mutate(
      Quantity = "long vowels"),
  d.SwehVd.forStudy.long.within_category_MS %>%
    filter(category %in% levels.vowel.IPA.swe.short) %>%
    get_SI() %>%
    mutate(
      Quantity = "short vowels"),
  d.SwehVd.forStudy.long.within_category_MS %>%
    get_SI() %>%
    mutate(
      Quantity = "all vowels"))

d.SwehVd.forStudy.SI.long <-
  d.SwehVd.forStudy.SI %>%
  # include all separate SIs
  select(c(Normalization.Type, crossvalidation_group, Quantity, SI_F1F2, SI_F1F3, SI_Duration, SI_F0, SI_F1, SI_F2, SI_F3, SI_all)) %>%
  pivot_longer(
    cols = starts_with("SI_", ignore.case = FALSE),
    names_to = c("SI", "Cues"),
    names_sep = "_",
    values_to = "Cue.Value") %>%
  pivot_wider(
    names_from = "SI",
    values_from = "Cue.Value")
```

```{r}
plot_separability <- function(data) {
  data %>%
    ggplot(
    aes(x = Normalization.Type,
        y = SI,
        color = Normalization.Type)) +
  stat_summary(
     fun.data = mean_cl_boot,
     geom = "linerange") +
  stat_summary(
    fun.y = mean,
    geom = "label",
    aes(label = signif(..y..,2),
        x = as.integer(Normalization.Type)),
    size = 2.8, label.size = 0, label.padding = unit(0.05, "lines")) +
  scale_colour_manual(
    labels = labels.normalization,
    values = colors.all.procedures) +
  scale_y_continuous("Separability index (F-value)") +
  myGplot.defaults(base_size + 2) +
  theme(
    axis.text.x = ggtext::element_markdown(angle = 60, vjust = 1, hjust=1, colour = colors.all.procedures),
    axis.title.x = element_blank(),
    aspect.ratio = 3/6) +
  guides(color = "none")
}

p.separability.by_cue <- plot_separability(d.SwehVd.forStudy.SI.long %>%
                                             filter(Cues %in% c("F0", "F1", "F2", "F3", "Duration"))) +
  facet_grid(factor(Cues, levels = c("F1", "F2", "F3", "F0", "Duration"), labels = c("F1", "F2", "F3", "F0", "duration")) ~ factor(Quantity, levels = c("long vowels", "short vowels", "all vowels")), scales = "free_y")
```

(ref:separability-by-cue) Separability indices by normalization accounts for long vowels, short vowels, and long and short vowels together (columns), shown for each of the five cues considered in this study (rows). Labels indicate mean across the five test folds. Intervals show average bootstrapped 95% confidence intervals across the test folds. Note that the ranges of the y-axes varies across plots.

```{r separability-by-cue, fig.width=base.width * 4, fig.height=base.height * 5.5, fig.align='center', fig.cap="(ref:separability-by-cue)"}
p.separability.by_cue
```

For F1 (first row of Figure \@ref(fig:separability-by-cue)), we see a clear advantage for centering (in blue) and scaling (in purple) compared to transformations (in grey) and intrinsic accounts (in yellow). In particular Lobanov normalization seems to maximize category separability along F1, at least for the long vowels and all vowels together. Notably, the accounts pattern differently along F2 (second row of Figure \@ref(fig:separability-by-cue)). Overall, differences between accounts are much smaller along F2, and the clear advantage of centering and scaling accounts along F1 does not extend to F2.

An altogether different picture is observed for F3. Compared to F1 and F2, the intrinsic accounts perform substantially better in separating categories along F3, while all other accounts perform poorly. This result is surprising: one of the downsides of intrinsic approaches that has been noted in previous work is their sensitivity to measurement error [@thomas]. This sensitivity is caused by the fact that intrinsic accounts use a single measurement for normalization, rather than the less noisy estimates resulting from aggregating across segments that are used in extrinsic accounts. Since the third formant is often described as more difficult to reliably estimate than other formants (leading to more measurement error), F3 would be expected to be particularly affected by this weakness of intrinsic accounts. 

Yet, further visualization in Figure \@ref(fig:F3-densities) confirms that F3 indeed separates categories particularly well when intrinsic normalization is applied. Compared to other accounts, @Syrdal1986 seems to be particularly successful in separating vowels that differ in lip rounding [in line with @REF]. For example, @Syrdal1986 separates two clusters among the high and mid-high vowels, one consisting of the back vowels `r linguisticsdown::cond_cmpl("[oː]")` and `r linguisticsdown::cond_cmpl("[uː]")`, and the other one of the front `r linguisticsdown::cond_cmpl("[eː]")` and `r linguisticsdown::cond_cmpl("[iː]")`, and rounded `r linguisticsdown::cond_cmpl("[yː]")` and `r linguisticsdown::cond_cmpl("[ʉː]")`. One possible explanation for this result is that intrinsic normalization is indeed particularly effective for F3, and that our correction of measurement errors---equally applied to all formants---effectively reduced the issue with F3 measurement errors (presumably the human brain, too, can do better than an uncorrected Praat algorithm without error correction). As we show below, this result for F3 carries over to any combination of cues that includes F3. It is, however, an artifact of using category separability to assess the effectiveness of normalization, as we show in Study 2. We elaborate on this issue in the discussion of Study 1.

Returning to Figure \@ref(fig:separability-by-cue), normalization does not increase category separability for F0. This is expected given that F0 is known not to separate vowel categories. Finally, for duration all of the C-CuRE accounts group together against the remaining accounts. This, too, is expected since all other accounts are formant-specific and thus do not normalize duration. <!-- We had the choice to normalize duration by C-CuRE for all other accounts as well, but since the other approaches does not normalize other cues than formants, we believed it to be more informative to show how C-CuRE performs in comparison to other approaches that does not account for duration. --> In summary, the five cues contribute to category separability in different ways, and this is reflected in varying effectiveness of different normalization accounts. 

(ref:F3-densities) Category densities along F3 illustrates the effectiveness of vowel-intrinsic normalization for this cue. Here shown for Syrdal & Gopal, compared to vowel-extrinsic accounts that center and/or scale cues. For reference, densities in the absence of normalization are also shown.

```{r F3-densities, fig.width= base.width * 4, fig.height = base.height * 2.5, fig.align='center', fig.cap="(ref:F3-densities)"}
# Generate list of manual y-scale limits, in order to have category labels fit in at density tops
scales <- list(
  # Specify all the scales, one for each facet
  scale_y_continuous(limits = c(0,.003)),
  scale_y_continuous(limits = c(0, 1.11)),
  scale_y_continuous(limits = c(0, .004)),
  scale_y_continuous(limits = c(0,1)),
  scale_y_continuous(limits = c(0,.003)),
  scale_y_continuous(limits = c(0,1.5)),
  scale_y_continuous(limits = c(0, .003)),
  scale_y_continuous(limits = c(0,.8))
)

d.SwehVd.forStudy.long %>%
  filter(fold_type == "test", Normalization.Type %in% c("no normalization (Hz)", "SyrdalGopal (Bark)", "C-CuRE (Hz)", "Lobanov (Hz)")) %>%
  ggplot(
    aes(F3, fill = factor(category))) +
  geom_density(alpha = .5) +
  geomtextpath::geom_textdensity(aes(label = category),
                                 size = 3,
                                 hjust = "ymax",
                                 vjust = -0.5, text_only = T, straight = T) +
  theme(legend.position = "none") +
  scale_colour_manual(name = "category", values = colors.vowel.swe, aesthetics = c("colour", "fill")) +
  guides(linetype = "none", color = "none", fill = "none") +
  ggh4x::facet_grid2(factor(Quantity, levels = c("long", "short"), labels = c("long vowels", "short vowels")) ~ Normalization.Type, scales = "free", independent = "all") +
  ggh4x::facetted_pos_scales(y = scales)
```

Next, we summarize how normalization affects category separability when combinations of the fives cues are considered. Figure \@ref(fig:separability) shows the separability index for the different normalization accounts for three different combinations of cues. For the first row of Figure \@ref(fig:separability), we followed most previous research in assessing category separability for the combination of F1 and F2 [e.g., @disner1980; @fabricius2009; @Flynn2011; @labov2010]. Accounts that center against the talker's overall formant mean (in blue) are among the best performing normalization accounts. No matter the assumed perceptual scale, centering always improves category separability. Scaling accounts (in purple), primarily @lobanov1971, also perform well at separating categories, more so for the long vowels. However, scale transformations (in grey), and intrinsic accounts (in yellow), do not improve category separability compared to unnormalized Hz, at least not when assessed on the long vowels or the entire vowel space. 

The remaining rows of Figure \@ref(fig:separability) compare normalization accounts when F3 (second row) or F0, F3, and duration are included (third row). Overall, the category separability is now lower, a result of how the accounts affect category separability along the cues added (see Figure \@ref(fig:separability-by-cue)). The most drastic change in performance concerns the intrinsic and the scaling accounts. The intrinsic accounts almost perform as well, in absolute numbers, as when evaluated on the combination of F1 and F2, thereby increasing their performance relative to other accounts. The scaling accounts, however, drop substantially in performance and now perform worse even than unnormalized cues. As surprising as this might appear, it mirrors what was found when assessing the category separability separately for each cue (Figure \@ref(fig:separability-by-cue)). The high performance of Syrdal & Gopal and @miller1989c, and the low performance of @gerstman1968 and @lobanov1971, seems to be driven by their ability, or lack thereof, to increase category separability along F3. For a language like Swedish, where F3 carry information to vowel identity, intrinsic accounts such as SyrdalGopal and @miller1989c, that appear to do very well at successfully distinguish categories along F3, seem to be particularly helpful in increasing category separability.

Finally, looking across all three rows, category separability is consistently higher for short than long vowels. The same pattern is evident for each cue separately in Figure \@ref(fig:separability-by-cue). This result might initially be puzzling, given that previous descriptions of Swedish vowel inventories characterize the inventory of short vowels as being more centralized and more densely clustered [e.g., @kuronen2000; @riad2014]. Indeed, this claim seems to hold for SwehVd---compare Figures \@ref(fig:swe-vowels-normalized-long) and \@ref(fig:swe-vowels-normalized-short). However, the short vowels exhibit less category variability and less category overlap, making them overall more separable. 

```{r}
p.separability <- plot_separability(d.SwehVd.forStudy.SI.long %>%
                                             filter(Cues %in% c("F1F2", "F1F3", "all"))) +
  facet_grid(factor(Cues, levels = c("F1F2", "F1F3", "all"), labels = c("F1-F2", "F1-F3", "F0-F3, duration")) ~ factor(Quantity, levels = c("long vowels", "short vowels", "all vowels")), scales = "free_y")
```

(ref:separability) Separability indices by normalization accounts for long vowels, short vowels, and both long and short vowels together (columns) shown for three different combinations of cues (rows). Labels indicate mean across the five test folds. Intervals show average bootstrapped 95% confidence intervals across the test folds. Note that the ranges of the y-axes varies across plots.

```{r separability, fig.width= base.width * 4, fig.height = base.height * 5.5, fig.align='center', fig.cap="(ref:separability)"}
cowplot::plot_grid(NULL, p.separability, rel_widths = c(.01, 1))
```

## Discussion
When only F1 and F2 are considered, as in most previous work on vowel normalization, we find that extrinsic centering and scaling accounts achieve the best category separability. This revises the results of @disner1980 for Central Swedish, and instead replicates previous findings for the other Germanic languages in Disner's sample as well as the majority of previous studies on other languages [e.g., @fabricius2009; @Flynn2011; @labov2010]. 

However, when F3 is considered along with the other cues, this result does no longer hold. This was confirmed by additional analyses not shown here that combined all cues except for F3. In those analyses, centering and scaling accounts again yield the largest category separability. Key to understanding this result and what it says about the suitability of category separability as a measure of normalization accounts is Figure \@ref(fig:separability-by-cue): while extrinsic normalization performs better than other approaches for F1, F2, and F0, the absolute differences in performance are small compared to the advantage of intrinsic accounts observed for F3. Combined with a seemingly innocuous aspect of the separability index in Equation \@ref(eq:separability-index), this allows separability along F3 to dominate separability along all other cue dimensions. Our separability index takes the *sum* of (squared) distances along each cue dimension, essentially assuming that the effect of all cues is simply a sum of each cue's effect considered separately. This means that the separability index cannot capture the *joint* effect of cues---whether, for example, one cue effectively separates one set of categories and another cue separates another set of categories, rather than both cues separating the same categories. The separability index thus cannot recognize, that F1 and F2 capture largely complementary aspects of the vowel inventory (as evident in, for example, Figures \@ref(fig:swe-vowels-normalized-long) and \@ref(fig:swe-vowels-normalized-short)).

This is not the only deficiency of the separability index or similar measures of category variability. The use of *squared* distances means that even a small number of observations located far away from the category mean can disproportionally affect the index. Consider, for example, the F3 densities in Figure \@ref(fig:F3-densities). For non-intrinsic normalizations, some categories have low but non-zero densities far away from the mode. Because of the use of squared distances, this results in low category separability for these normalization accounts despite the fact that observations with such cue values are rare and thus not expected to have a large effect on the *average* perceptual separability of vowels. For the same reason (the use of squared distances), category separability can be high even if a cue separates only a small subset of categories (as is the case for F3), compared to another cue that more gradiently separates *all* categories (as is the case for F1 and F2; see Figure \@ref(fig:swe-vowels-all-cues)).

In sum, indices of variability and category separability like that in Equation \@ref(eq:separability-index) fail to adequately assess the expected consequences of normalization for perception, which is the primary interest of this study. This motivates Study 2.

# Study 2: Comparing the expected effects of normalization on perception {#sec:studyII}
Study 2 takes a more direct approach to evaluating the expected effects of normalization for the perception of vowels. Specifically, we use a general model of speech perception, Bayesian ideal observers [e.g., @clayards2008; @nearey198X; @norris-mcqueen2008], to predict the vowel identities in the SwehVd database under different normalization account. We then compare normalization accounts based on the recognition accuracy that they achieve when the (un)normalized cues are fed into the otherwise identical categorization model. We evaluate the same normalization accounts as those investigated in Study 1. And, as in Study 1, we repeat this comparisons for different combinations of cues, and while categorizing just long vowels, just short vowels, or both long and short vowels together. 

<!-- TO DO: this table needs work: On the other hand, I think there's work within c-cure on vowels?  and I do think it would be ok to mention works here that actually assessed perception. --> [@mcmurray-jongman2016]

```{r}
norm_accounts_eval_percep <- tibble(
      "Language(s) investigated" = c(
                              "US English",
                              "US English",
                              "US English",
                              "US English",
                              "Brazilian Portuguese & US English",
                              "Dutch"),
      "Article" = c(
               "Barreda & Nearey, 2018",
               "Carpenter & Govindarajan, 1993",
               "Richter, Feldman, Salgado & Jansen, 2017",
               "Syrdal, 1985",
               "Escudero & Hoffman Bion, 2007",
               "Adank, Smits & van Hout, 2004"),

  "Speech materials" = c(
                         "120,000 simulated languages (of 5 or 9 vowels) modeled on Hillenbrand et al.'s (1995) data (138 female/male child/adult talkers * 12 vowels)",
                         "Peterson & Barney's (1952) database, 75 female/male child/adult talkers (2 tokens * 10 vowels)",
                         "Clopper & Pisoni's (2006) NSP vowel corpus, 60 female/male talkers, 6 varieties (5 tokens * 10 vowels)",
                         "Peterson & Barney's (1952) database, 75 female/male child/adult talkers (2 tokens * 10 vowels); Texas Instruments database, 154 female/male child/adult talkers (1 token * 10 vowels)",
                         "models trained on 400,000 F1-F2 combinations generated on recordings of 8 female/male talkers (20 tokens * 7 vowels and 15 tokens * 11 vowels)",
                         "160 female/male talkers, 8 varieties (2 tokens * 9 vowels)"),

  "Normalization accounts" = c(
    "Nearey2, Lobanov, log-mean in linear regression framework",
    "Bark, Mel, ERB, 2 log-transformations, Syrdal & Gopal, Miller, Nearey1, Nearey2, Gerstman, linear transformation (Watrous, 1993)",
    "Vocal Tract Length Normalization, Lobanov",
    "log-transformation, Bark, Syrdal's bark-difference model, Miller (2 accounts), Nearey1, Nearey2, Gerstman",
    "Nearey1, Lobanov, Gerstman",
    "log-transformation, Bark, Mel, ERB, Syrdal & Gopal, Lobanov, Nearey1, Nearey2, Gerstman, Nordström, Miller"),

  "Approach" = c(
                        "regression, F statistics",
                        "fuzzy ARTMAP, K-nearest neighbour",
                        "discrimination model likelihoods",
                        "linear discriminant analysis",
                        "constraint rankings",
                        "linear discriminant analysis"),
  
  "Accuracy assessed" = c(
    "against intended category",
    "against intended category",
    "against perceived category (Feldman et al., 2009)",
    "against intended category",
    "against intended category",
    "against intended category"),

  "Best two performing" = c(
                                     "log-mean in linear regression framework (1), Nearey2 (2)",
                                     "linear transformation (1), Nearey1 (2)",
                                     "Vocal Tract Length Normalization (1), Lobanov (2)",
                                     "Syrdal & Gopal (1), Nearey1/Nearey2 (2)",
                                     "Lobanov (1), Nearey1 (2)",
                                     "Lobanov (1), Nearey1 (2)"))
```

Table \@ref(tab:norm-evaluation-percep) lists previous studies that have compared normalization accounts in terms of their expected consequences for perception. While some previous studies have evaluated normalization accounts against listeners' responses in perception experiments [@richter2017], the majority of previous work has evaluated accounts against the category intended by the talker---i.e., against production data. Here, we follow this majority (though we plan to conduct perception studies on Swedish in the future).

Across languages and approaches, the studies in Table \@ref(tab:norm-evaluation-percep) yield similar results as those summarized in Table \@ref(tab:norm-evaluation-variability) for category separability. Normalization improves recognition accuracy compared to unnormalized cues. Perceptual transformations perform worse than intrinsic or extrinsic normalization at predicting perception from production data. Furthermore, the same normalization accounts that have been found to be most successful at reducing inter-talker variability [e.g., @lobanov1971; @nearey1978] are also often found to achieve higher recognition accuracy [e.g., @adank2004; @barreda2018a; @escudero2007; @syrda1985]. Despite these overall similarities in results, it is important to keep in mind that the two approaches---category separability and models of perception---do not *have* to yield the same results. In the present study, we go beyond previous work by modeling perception of both vowel quality and vowel quantity over a particularly dense vowel space, and by considering additional cues. We expect, in particular, that the approach in Study 2 will remove the deficiency of the separability index related to F3 observed in Study 1.

As also shown in Table \@ref(tab:norm-evaluation-percep), previous work has employed a number of model types to compare the expected effects of normalization on perception, ranging from models based on phonological theory [e.g., optimality theory, @escudero2007], to more general models of categorization [e.g., linear discriminant analysis, @adank2004; @syrda1985; k-nearest neighbors as in exemplar theory or ARTMAP, @carpenter1993; Bayesian inference, @Kleinschmidt2018; @richter2017], to general frameworks for data analysis [e.g., regression, @REF-CuRE-vowel]. We use ideal observers, rather than other approaches, because they remove *all* degrees of freedom from the modeling. For example, k-nearest neighbor categorization requires the choice of a similarity metric, which can introduce one or more degrees of freedom into the modeling, and requires a choice for $k$. Linear discriminant analysis or regression introduce at least one degree of freedom for each cue considered. Bayesian ideal observers encode the assumption that listeners use and integrate cues *optimally*. As a consequence, the predicted posterior probabilities of all categories for a given acoustic input are perfectly determined by the combination of (1) the category-specific distribution of cues in the previous input and (2) the cue values of the input. Next, we describe ideal observers in more detail. After introducing ideal observers, we detail how this approach avoids the pitfalls of the separability index employed in Study 1.

```{r norm-evaluation-percep, results='asis'}
norm_accounts_eval_percep %>%
  kable(format = "latex", booktabs = TRUE, caption = "Previous studies comparing normalization accounts' predictions for perception") %>%
  kable_styling(font_size = 7) %>%
  column_spec(1:2, width = "2cm") %>%
  column_spec(3:4, width = "5cm") %>%
  column_spec(5:7, width = "2cm") %>%
  kableExtra::landscape() %>%
  collapse_rows()
```

## Methods {#sec:methodsII}

### Speech materials {#sec:speechMaterialsII}
Study 2 employs the same speech materials as in Study 1.

### Ideal Observers to predict the consequences of normalization for perception {#sec:IOs}
Ideal observers (IOs) provide an analytical framework for estimating how a rational listener would optimally behave in response to input (here: $n$-way alternative forced-choice categorization). IO models have been found to provide a good qualitative and quantitative fit against human speech perception [e.g., @clayards2008; @feldman2009; @kleinschmidt-jaeger2015; @kronrod2016; @norris-mcqueen2008; @xie2021cognition]. Unlike most other models of speech perception, IOs in their simplest form---as employed here---have zero degrees of freedom in the link from production to perception: once the IO is trained on phonetic data from a database of *productions*, its predictions about *perception* are not mediated by additional parameters (unlike, e.g., exemplar models, connectionist accounts, or neural networks). This removes researchers' degrees of freedom in the evaluation of normalization accounts, which is the reason we chose IOs for Study 2. We emphasize, however, that other researchers can download the R markdown document for this article (which contains the R code for our models) from OSF and substitute any other perceptual model for the ideal observers to assess the extent to which our choice of computational framework affects the findings reported below.

In line with influential theories of speech perception [e.g., exemplar theory, @johnson1997; Bayesian accounts, @luce-pisoni1998; @nearey1990; @norris-mcqueen2008; interactive-activation accounts and their offsprings, @magnuson2020; @mcclelland-elman1986], IOs describe the posterior probability of a category as dependent both on the prior probability of the category in the current context, $p(category)$, and the likelihood of the acoustic input under the hypothesis that it originates from the category, $p(cues|category)$:

\begin{equation}
 p(category|cues) = \frac{p(cues|category) \times p(category)}{\sum_c p(cues|category_c) \times p(category_c)} (\#eq:Bayes-rule)
\end{equation}

The category prior, $p(category)$, describes the how much the surrounding context favors each category. For Study 2, the choice of category prior cannot affect the qualitative results since category priors are independent of the cues and held identical across all normalization accounts.^[Specifically, category priors have a constant additive effect on the posterior log-odds of categories.] We arbitrarily assume uniform category priors. Specifically, for IOs trained and tested on the long and short vowels separately, we model categorization as an 11- and 10-alternatives-forced-choice task, respectively, resulting in $p(category) = .091$ for the former and $p(category) = .1$ for the latter. For IOs trained and tested on the entire vowel space, we model categorization as a 21-alternatives-forced-choice task, resulting in $p(category) = .048$.

The likelihood, $p(cues|category)$, describes the distribution of cues for each category. Here, we follow previous work and assume multivariate Gaussian distributions to describe the cue likelihood [e.g., @clayards2008; @kleinschmidt-jaeger2015; @kronrod2016; @xie2021cognition]. That is, we use the model in equation \@ref(eq:Bayes-rule-normal), where $\mu$ and $\Sigma$ refer to the category mean and variance-covariance matrix of the category's multivariate normal distribution. In terms of representational complexity, the assumption of multivariate Gaussian categories strikes a compromise between exemplar storage [less representationally parsimonious, @johnson1997; @pierrehumbert2001] and cue integration over multiple separate univariate Gaussians [more parsimonious, @toscano-mcmurray2010].^[Human perception is affected by an additional source of uncertainty beyond category variability: perceptual noise [for review, see @feldman2009]. There is now evidence that including such perceptual noise in models provides a better fit against human behavior [e.g., @kronrod2016; @tan2022]. Since Study 2 assesses in the *relative* recognition accuracy of different normalization accounts, it is not immediately obvious how the inclusion of noise could affect our results. To avoid additional researchers degrees of freedom---such as the decision as to which acoustic or perceptual space (Hz, Mel, Bark, etc.) perceptual noise is additive in---we do not model the perceptual consequences of noise. To the best of our knowledge, no previous comparisons of normalization accounts has considered perceptual noise.]

\begin{equation}
 p(category|cues) = \frac{\mathcal{N}(cues| \mu, \Sigma) \times p(category)}{\sum_c \mathcal{N}(cues|\mu_c, \Sigma_c) \times p(category_c)} (\#eq:Bayes-rule-normal)
\end{equation}

Paralleling Study 1, we trained and tested separate ideal observers for each combination of normalization account, cues, and training-test fold. Specifically, we use the exact same cross-validation folds as in Study 1. Each IO was trained on the training portion of the folded unnormalized and normalized data, and subsequently evaluated on the held-out test fold. This means that the parameters of each normalization account (e.g., the cue means in C-CuRE) and the resulting category parameters (the $\mu_c$s and $\Sigma_c$s for all categories) were set on the training data, and not changed for the test data. This reflects the realities of speech perception: although this is often ignored in evaluations of normalization accounts [e.g., @mcmurray-jongman2011], listeners do not *a priori* know the cue means, cue variance, etc. of an unfamiliar talker. Rather, listeners need to incrementally *infer* those statistical properties from the talker's speech input [for discussion and a model, see @xie2022]. An additional advantage of cross-validation is that it gives us an estimate of the uncertainty about the model predictions. The performance of each IO during test is assessed by calculating the IO's predicted posterior probability of the *intended* category for each test token. This is identical to assuming Luce's choice rule for categorization [@luce1959], as in most models of speech perception and spoken word recognition.

### Advantages compared to separability index and similar measures of category variability
By using a categorization model to estimate the consequence of normalization for perception, we avoid the pitfalls of the separability index discussed in Study 1. First, by using the density of an acoustic input under the multivariate distribution of all cues, the ideal observers we employ capture the *joint* effect of all cues. This captures that an input can be an improbable instance of a category based on one of its cue values but a probable instance given the values for the other cues. In particular, since we assume multivariate Gaussian likelihoods, the model can account for category-specific covariances between cues. In the presence of strong correlations between cues, an acoustic input can be an improbable instance of a category based on the marginal distribution of each cue---i.e., if each cue is considered separately---but be a highly probable instance of that category if considered relative to the joint distribution of all cues (and vice versa). <!-- TO DO: it might be good to have a little figure illustrating this? -->

Second, by normalizing the support for a category by the support for all other categories (the denominator in Equations \@ref(eq:Bayes-rule) and \@ref(eq:Bayes-rule-normal)), ideal observers consider the perceptual consequences of an acoustic input *relative to all possible categories*. This means that a token that is relatively far away from its category mean does not necessarily result in low recognition accuracy. Rather, low recognition accuracy is only predicted if the relative position of the acoustic input in the acoustic-phonetic space makes it more probably that the input originated from another (unintended) category. This parallels human perception: e.g., while a /d/ with hyper-articulated voice onset timing is atypical, human listeners are as likely or more likely to recognize it as a /d/ (rather than a /t/), compared to a casually articulated /d/, presumably *because the observed phonetics would be even less likely to occur if the talker intended a /t/*. Measures of between- vs. within-category variability like the separability index in Study 1, however, have no means of directly capturing this.

Finally, when an acoustic input is indeed improbable under its intended category relative to other unintended categories, the ideal observer model will correctly predict low recognition accuracy. Unlike the separability index in Study 1, however, the ideal observer will not disproportionally weight this single observation: it will simply be one of many observations---much like human speech perception does not collapse simply because one word (or one vowel) has been misunderstood. As we show next, these differences between the approaches taken in Studies 1 and 2 can, and sometimes do, cause differences in results.

```{r}
train_io <- function(cues, data, group = NULL, no_noise = T, n.category = length(unique(data$category)), verbose = F) {
  cue_transformation = unique(gsub("^_([A-Za-z]+)_.*$" , "\\1", cues))
  cue_normalization = unique(gsub("^.*_([a-z])$" , "\\1", cues))

  # Add noise_variance depending on the no of cues
  noise_variance <- if(no_noise) {
    rep(0, n_distinct(cues))
  } else {
    rep(878, n_distinct(cues)) }# in Mel

  if (any(stringr::str_ends(cues, "_[cs]"))) {
    # calculate how much variance is changed compared to untransformed cues
    stats <-
      data %>%
      ungroup() %>%
      summarise_at(vars(contains("F")), sd) %>%
      select(cues, gsub("hertz", cues)) %>%
      #select(cues, gsub("_([a-z])", "_r", cues))
      pivot_longer(
        cols = everything(),
        names_pattern = "([A-Za-z]*)_(F[12])_([A-Za-z])",
        names_to = c("cue_transform", "formant", "cue_normalization")) %>%
      pivot_wider(names_from = "cue_normalization") %>%
      mutate(scale_factor = r / !! sym(cue_normalization))

    noise_variance <- noise_variance / stats$scale_factor
  }

  Sigma_noise <- diag(noise_variance)
  dimnames(Sigma_noise) <- list(cues, cues)

  m <- data %>%
    make_MVG_ideal_observer_from_data(
      verbose = verbose,
      category = "category",
      cues = cues,
      group = group,
      prior = rep(1/n.category, n.category),
      lapse_rate = 0,
      lapse_bias = rep(1/n.category, n.category),
      Sigma_noise = Sigma_noise
      )

  return(m)
}
```

```{r}
make_IOs_and_add_test_data <- function(data, cues, separate_by = NULL) {
  separate_by <- c(separate_by, "Normalization.Type", "crossvalidation_group")
  data %>%
  filter(fold_type == "training") %>%
  group_by(!!! syms(separate_by)) %>%
  # train IOs, one for each cross_validation group
  group_map(
    .f = ~ train_io(
      data = .x,
      cues = cues,
      no_noise = T) %>%
      nest(io = everything()) %>%
      bind_cols(.y)) %>%
    reduce(bind_rows) %>%
    # Add test data *that matches the IO*
    left_join(
      data %>%
        filter(fold_type == "test") %>%
        select(Talker, category, Token, !!! syms(cues), !!! syms(separate_by)) %>%
        # Renaming category here to avoid confusion downstream (with IO.Vowel)
        rename(Intended.Vowel = category),
      by = separate_by) %>%
    mutate(x = pmap(.l = list(!!! syms(cues)), ~ c(...))) %>%
    nest(test_data = c(Talker, Intended.Vowel, Token, !!! syms(cues), x)) %>%
    # Rename columns to identify each IO by
    mutate(
      Normalization.Type =
        factor(
          plyr::mapvalues(Normalization.Type, labels.normalization, levels.normalization.plots),
          levels = levels.normalization.plots)) %>%
    rename_with(
      .cols = separate_by,
      .fn = ~ paste0("IO.", .x)) %>%
    separate(IO.Normalization.Type, c("IO.cue_normalization", "IO.cue_transform"), remove = F) %>%
    mutate(
      IO.cue_transform = factor(IO.cue_transform, levels = c("Hz", "Mel", "Bark", "ERB", "log", "semitones")),
      IO.cue_normalization = factor(IO.cue_normalization, levels = c("r", "SyrdalGopal", "CCuRE", "Lobanov", "Nearey1", "Nearey2", "Gerstman", "Miller"))) %>%
    # Categorize test by IO
    mutate(
      # Store all of posterior distribution
      posterior_of_all_vowels = map2(
        test_data, io,
        ~ get_categorization_from_MVG_ideal_observer(
          x = .x$x,
          model = .y,
          decision_rule = "proportional",
          noise_treatment = "sample",
          lapse_treatment = "marginalize") %>%
          rename(Posterior = response, IO.Vowel = category) %>%
          # Join back in all other information about the test data
          left_join(.x) %>%
          relocate(Talker, Token, Intended.Vowel, observationID, x, everything())),
      # Store only the posterior of intended vowel
      posterior_of_intended_vowel = map(posterior_of_all_vowels, ~ .x %>% filter(Intended.Vowel == IO.Vowel)),
      # Format the posterior for all vowels to be wide
      posterior_of_all_vowels = map(posterior_of_all_vowels, ~ .x %>% pivot_wider(names_from = IO.Vowel, values_from = Posterior))) %>%
    relocate(starts_with("IO", ignore.case = F), io, test_data, posterior_of_all_vowels, posterior_of_intended_vowel)
}

# Make talker-independent IOs on long and short vowels *separately*, for different cue combinations
m.io.SwehVd.F1F2_by_quantity <-
  make_IOs_and_add_test_data(
    data = d.SwehVd.forStudy.long,
    cues = c("F1", "F2"),
    separate_by = c("Quantity"))

m.io.SwehVd.F1F3_by_quantity <-
  make_IOs_and_add_test_data(
    data = d.SwehVd.forStudy.long,
    cues = c("F1", "F2", "F3"),
    separate_by = c("Quantity"))

m.io.SwehVd.all_by_quantity <-
  make_IOs_and_add_test_data(
    data = d.SwehVd.forStudy.long,
    cues = c("F0", "F1", "F2", "F3", "Duration"),
    separate_by = c("Quantity"))

# Make talker-independent IOs on long and short vowels *combined*, for different cue combinations
m.io.SwehVd.F1F2 <-
  make_IOs_and_add_test_data(
    data = d.SwehVd.forStudy.long,
    cues = c("F1", "F2")) %>%
  # Add column for plotting
  mutate(
    IO.Quantity = "all")

m.io.SwehVd.F1F3 <-
  make_IOs_and_add_test_data(
    data = d.SwehVd.forStudy.long,
    cues = c("F1", "F2", "F3")) %>%
  # Add column for plotting
  mutate(
    IO.Quantity = "all")

m.io.SwehVd.all <-
  make_IOs_and_add_test_data(
    data = d.SwehVd.forStudy.long,
    cues = c("F0", "F1", "F2", "F3", "Duration")) %>%
  # Add column for plotting
  mutate(
    IO.Quantity = "all")

#Make combined dataframe for plotting
m.io.SwehVd <- rbind(
  m.io.SwehVd.F1F2_by_quantity %>%
    mutate(Cue_space = "F1-F2"),
  m.io.SwehVd.F1F2 %>%
    mutate(Cue_space = "F1-F2"),
  m.io.SwehVd.F1F3_by_quantity %>%
    mutate(Cue_space = "F1-F3"),
  m.io.SwehVd.F1F3  %>%
    mutate(Cue_space = "F1-F3"),
  m.io.SwehVd.all_by_quantity %>%
    mutate(Cue_space = "F0-F3, duration"),
  m.io.SwehVd.all %>%
    mutate(Cue_space = "F0-F3, duration")) %>%
  mutate(Cue_space = factor(Cue_space, levels = c("F1-F2", "F1-F3", "F0-F3, duration")))
```
```{r}
# Accuracies compared to the intended vowel
d.max.acc.toINTEND <- m.io.SwehVd %>%
  unnest(posterior_of_intended_vowel) %>%
  group_by(IO.Normalization.Type, Cue_space, IO.crossvalidation_group, IO.Quantity) %>%
  summarise(mean.acc = mean(Posterior)) %>%
  group_by(IO.Normalization.Type, Cue_space, IO.Quantity) %>%
  summarise(mean = mean(mean.acc))

d.max.acc.toINTEND %>% filter(IO.Normalization.Type %in% c("CCuRE_Hz", "CCuRE_Mel", "CCuRE_Bark", "CCuRE_ERB", "CCuRE_semitones", "Nearey1_log", "Nearey2_log", "Lobanov_Hz")) %>% group_by(Cue_space, IO.Quantity) %>% summarise(max = max(mean)) %>% ungroup() %>% summarise(min(max)) %>% round(digits = 3) * 100
```
## Results {#sec:resultsII}
Figure \@ref(fig:predictions) visualizes the unnormalized and normalized models' predictions for perception of Stockholm Swedish vowels, under different assumptions about the relevant cues. The first observation is that---unlike for the separability index in Study 1---the relative performance of the different normalization accounts within each panel is remarkably constant across all panels (compare to Figure \@ref(fig:separability)). Regardless of the combination of cues or the vowel types considered (long, short, both), transformation into a perceptual space does little to improve recognition accuracy, compared to unnormalized cues. Intrinsic normalization, too, does not improve recognition accuracy. And, unlike in Study 1, this result holds even when F3 is included as a cue. This replicates previous work on Dutch [@adank2004] but conflicts with some evaluations of English [e.g., @syrda1985]. @adank2004 discussed whether the discrepancy in results might be attributed to implementations of the Bark-transformation, or to what @syrda1985 describe as language-specificity of the second dimension of @Syrdal1986 normalization. The present results would seem to confirm this vulnerability of intrinsic normalizations. <!-- TO DO: Starting at @adank2004 discussed, this feels to me more like sth that should go into the discussion. Perhaps we do the same with any replication statements? (but at least these more complicated ones) -->
Extrinsic normalization, however, tends to substantially improve recognition accuracy (with the exception of Gerstman normalization). Depending on the specific combination of cues and the types of vowels considered, the best-performing normalization model increases recognition accuracy by between `r d.max.acc.toINTEND %>% filter(IO.Normalization.Type %in% c("CCuRE_Hz", "CCuRE_Mel", "CCuRE_Bark", "CCuRE_ERB", "CCuRE_semitones", "Nearey1_log", "Nearey2_log", "Lobanov_Hz")) %>% group_by(Cue_space, IO.Quantity) %>% summarise(max = max(mean)) %>% ungroup() %>% summarise(min(max)) %>% round(digits = 3) * 100`% (from `r d.max.acc.toINTEND %>% filter(IO.Normalization.Type == "r_Hz") %>% group_by(Cue_space, IO.Quantity) %>% summarise(max = max(mean)) %>% ungroup() %>% summarise(min(max)) %>% round(digits = 3) * 100`% for unnormalized cues) to `r d.max.acc.toINTEND %>% filter(IO.Normalization.Type %in% c("CCuRE_Hz", "CCuRE_Mel", "CCuRE_Bark", "CCuRE_ERB", "CCuRE_semitones", "Nearey1_log", "Nearey2_log", "Lobanov_Hz")) %>% group_by(Cue_space, IO.Quantity) %>% summarise(max = max(mean)) %>% ungroup() %>% summarise(max(max)) %>% round(digits = 3) * 100`% (from `r d.max.acc.toINTEND %>% filter(IO.Normalization.Type == "r_Hz") %>% group_by(Cue_space, IO.Quantity) %>% summarise(max = max(mean)) %>% ungroup() %>% summarise(max(max)) %>% round(digits = 3) * 100`%). The benefit of extrinsic normalization models, as well as the lower performance of perceptual transformations, replicates previous findings on other languages [e.g., @adank2004; @barreda2018a; @escudero2007].

We also see that all models---even for unnormalized cues---perform substantially above chance. When long and short vowels are considered separately, the best ideal observers achieve recognition accuracies of `r d.max.acc.toINTEND %>% filter(IO.Quantity == "long") %>% group_by(Cue_space, IO.Normalization.Type) %>% summarise(max = max(mean)) %>% ungroup() %>% summarise(max(max)) %>% round(digits = 3) * 100`% for long vowels and `r d.max.acc.toINTEND %>% filter(IO.Quantity == "short") %>% group_by(Cue_space, IO.Normalization.Type) %>% summarise(max = max(mean)) %>% ungroup() %>% summarise(max(max)) %>% round(digits = 3) * 100`% for short vowels. For reference, in a recent perception experiment we conducted on the eight monophthongs of US English, L1-US English listeners achieved 71.1% accuracy in categorizing isolated hVd words [chance = 12.5%, @persson-jaeger2023]. The ideal observers for the Swedish vowel system thus achieve performance that is comparable to that of human listeners, at least when cues are normalized.

Looking across columns of Figure \@ref(fig:predictions), short vowels are always recognized with higher accuracy compared to long vowels. This increase in performance cannot be explained by the small increase in the chance baseline alone (10% for the 10 short vowels, compared to 9.1% for the 11 long vowels). It conceptually replicates a initially surprising result of Study 1: while short vowels are more densely clustered in the center of the vowel space, and thus occupy a smaller perceptual space, they also exhibit less variability. Overall, this makes those vowels *easier* to recognize. 

When long and short vowels are categorized together, performance of the ideal observers is comparatively poor unless vowel duration is included as a cue. This is expected given that vowel duration is the primary cue to vowel quantity. Of interest, however, is that even the inclusion of only F3 (second row) yields a substantial improvement in recognition accuracy, in line with @carpenter1993 and @johnson-sjerps2021. Remarkably, once vowel duration is included, the best-performing ideal observer achieves 75% recognition accuracy across the 21 long and short vowels (compared to chance = 4.8%).

Finally, there are also some more subtle differences across the rows and columns of Figure \@ref(fig:predictions). Of theoretical interest is that, Lobanov normalization performs best for all vowel types if only F1 and F2 are considered. However, this advantages decreases when additional cues are considered.^[Indeed, when all five cues are considered for the categorization of all 21 short and long vowels, simple centering appears to perform numerically better than Lobanov normalization. This is an artifact of our decision to only center vowel duration---the primary cue to vowel quantity---for the C-CuRE model (paralleling Study 1). Separate modeling not shown here confirmed that Lobanov normalizaton achieves the same recognition accuracy as the C-CuRE models when duration is centered and combined with Lobanov-normalized formants.<!--TO DO: test and confirm or change?-->] 

```{r}
#Remove temp file
rm(d.max.acc.toINTEND)

# Plot the overall accuracy of the different normalization accounts
plot_io_results <- function(data) {
  data %>%
    # Rename IO.Normalization.Type for plotting
    mutate(
      IO.Normalization.Type =
        factor(
          plyr::mapvalues(IO.Normalization.Type, levels.normalization.plots, labels.normalization),
          levels = labels.normalization)) %>%
    unnest(posterior_of_intended_vowel) %>%
    # Get the CI over the five folds
    { if ("IO.Quantity" %in% names(data)) group_by(., IO.Normalization.Type, IO.Quantity, IO.crossvalidation_group, Cue_space) else  group_by(., IO.Normalization.Type, IO.crossvalidation_group, Cue_space) } %>%
    summarise(
      chance = 1 / n_distinct(Intended.Vowel, na.rm = TRUE),
      ci = list(enframe(Hmisc::smean.cl.boot(Posterior)))) %>%
    unnest(ci) %>%
    spread(name, value) %>%
    { if ("IO.Quantity" %in% names(data)) group_by(., IO.Normalization.Type, IO.Quantity, Cue_space) else  group_by(., IO.Normalization.Type, Cue_space) } %>%
    summarise(
      chance = first(chance),
      mean_CI_lower = mean(Lower),
      mean_CI_upper = mean(Upper),
      mean = mean(Mean)) %>%
    ggplot() +
    geom_pointrange(
      aes(x = IO.Normalization.Type,
          y = mean,
          ymin = mean_CI_lower,
          ymax = mean_CI_upper,
          color = IO.Normalization.Type),
      position = position_dodge2(width = 0.3),
      fatten = 2.5) +
    geom_hline(aes(yintercept = chance), color = "gray", linetype = 2) +
    scale_y_continuous("Overall accuracy (of predicting *intended* vowel)", limits = c(0,1))+
    scale_colour_manual(
      "Normalization \nprocedure of IO",
      labels = labels.normalization,
      values = colors.all.procedures) +
    guides(color = "none") +
    theme(axis.text.x = ggtext::element_markdown(angle = 60, vjust = 1, hjust = 1, colour = colors.all.procedures),
        axis.title.x = element_blank())
}

p.accuracy.io.overall <- plot_io_results(m.io.SwehVd) + facet_grid(Cue_space ~ factor(IO.Quantity, levels = c("long", "short", "all"), labels = c("long vowels", "short vowels", "all vowels")))
```

(ref:predictions) Predicted recognition accuracy of ideal observer under different normalization accounts for long vowels, short vowels, and long and short vowels together (columns), shown for for three different combinations of cues (rows). Labels indicate mean across the five test folds. Intervals show average bootstrapped 95% confidence intervals across the test folds. The dashed horizontal line indicates chance (different across columns because of the different number of long and short vowels).

```{r predictions, fig.width= base.width * 4.5, fig.height = base.height * 5.5, fig.align='center', fig.cap="(ref:predictions)"}
p.accuracy.io.overall
```

The approach that we have taken here lets us assess vowel-specific effects on the predictions of the IOs. This is however not the main focus of this paper, but might be of interest to other researchers. In SI, we therefore plot both the predicted categorization accuracy per vowel in the different evaluations (see \@ref(sec:accuracy-per-vowel)), as well as confusion matrices of the best and the worst performing IOs (see \@ref(sec:confusion)), to further investigate *how* normalization improves recognition accuracy. Here, we briefly mention some of the main findings that emerge from these additional visualizations. For reference, Figure \@ref(fig:predictions-per-vowel) visualizes the predicted categorization accuracy for five vowels for IO models trained on unnormalized and normalized F1-F2 and all 21 vowels (plots of models trained on F1-F3, and all five cues, and on long and short vowels separately, are available in the SI (\@ref(sec:accuracy-per-vowel)).

Unsurprisingly, some vowels are recognized with much higher accuracy than others---at least when uniform category priors are assumed, as we did here. This is a direct consequence of the position of the vowel in the acoustic-phonetic space, relative to neighboring vowels: the more neighboring vowels overlap with each other, the lower the accuracy with which they are recognized. Which vowels will benefit from normalization will thus naturally vary between languages, reflecting the language-specific properties of the vowel space. For instance, [`r linguisticsdown::cond_cmpl("iː")`] is often described as more easily recognized in previous work on other languages. This contrasts with our findings for Central Swedish: here,  [`r linguisticsdown::cond_cmpl("iː")`] is part of the dense clustering of vowels along the height dimension and so has many close competitors. This highlights that recognition accuracy is due to the position of a vowel *relative* to its competitors [e.g., @Peterson1952; @Kuhl1991; @Polka2003], rather than its *absolute location* in the vowel space (e.g., [`r linguisticsdown::cond_cmpl("iː")`] being a peripheral vowel). 

Also of interest is that not all vowels exhibit the benefit of normalization. In general, across evaluations, it seems to be vowels that are already recognized with relatively high accuracy that particularly benefit from normalization. <!-- AP: add here what others have found --> Finally, while there are minor differences across vowels in the relative goodness of different normalizations, the models that perform overall best also perform best on each vowel. This further demonstrates the plausibility of these normalization accounts for perception.

(ref:predictions-per-vowel) Predicted recognition accuracy of ideal observer under different normalization accounts for five of the 21 vowels. Point ranges indicate the average mean accuracy and average 95% bootstrapped CI across the five folds. Chance level is indicated by grey line.

```{r cache.lazy=FALSE}
#Plot the overall accuracy of the different normalization accounts
plot_io_results_per_vowel <- function(data) {
  data %>%
  # Rename IO.Normalization.Type for plotting
  mutate(
    IO.Normalization.Type =
      factor(
        plyr::mapvalues(IO.Normalization.Type, levels.normalization.plots, labels.normalization),
        levels = labels.normalization)) %>%
    unnest(posterior_of_intended_vowel) %>%
    # Get the CI over the five folds
    { if ("IO.Quantity" %in% names(data)) group_by(., IO.Normalization.Type, IO.Quantity, IO.crossvalidation_group, Intended.Vowel, Cue_space) else group_by(., IO.Normalization.Type, IO.crossvalidation_group, Intended.Vowel, Cue_space) } %>%
    summarise(
      chance = 1 / n_distinct(Intended.Vowel),
      ci = list(enframe(Hmisc::smean.cl.boot(Posterior)))) %>%
    unnest(ci) %>%
    spread(name, value) %>%
    { if ("IO.Quantity" %in% names(data)) group_by(., IO.Normalization.Type, IO.Quantity, Intended.Vowel, Cue_space) else  group_by(., IO.Normalization.Type, Intended.Vowel, Cue_space) } %>%
    summarise(
      chance = first(chance),
      mean_CI_lower = mean(Lower),
      mean_CI_upper = mean(Upper),
      mean = mean(Mean)) %>%
    ggplot() +
    geom_pointrange(
      aes(x = IO.Normalization.Type,
          y = mean,
          ymin = mean_CI_lower,
          ymax = mean_CI_upper,
          color = IO.Normalization.Type),
      position = position_dodge2(width = 0.3),
      fatten = 2.5) +
    geom_hline(aes(yintercept = case_when(IO.Quantity == "long" ~ 1/11,
                                          IO.Quantity == "short" ~ 1/10,
                                          IO.Quantity == "all" ~ 1/21)), color = "gray", linetype = 2) +
    scale_y_continuous("Accuracy (of predicting *intended* vowel)", limits = c(0,1))+
    scale_colour_manual(
      "Normalization \nprocedure of IO",
      labels = labels.normalization,
      values = colors.all.procedures) +
    guides(color = "none") +
    theme(axis.text.x = ggtext::element_markdown(angle = 60, vjust = 1, hjust = 1, colour = colors.all.procedures, size = 7),
        axis.title.x = element_blank())
}

p.accuracy.io.per.vowel <- plot_io_results_per_vowel(
  m.io.SwehVd %>% nplyr::nest_filter(posterior_of_intended_vowel, Intended.Vowel %in% c("[eː]", "[æ]", "[ɑː]", "[yː]", "[iː]")) %>%
    filter(IO.Quantity == "all")) +
  facet_grid(Cue_space ~  factor(Intended.Vowel, levels = levels.vowel.IPA.swe))
```

\begin{landscape}

```{r predictions-per-vowel, fig.width=base.width * 5.5, fig.height=base.height * 4, fig.align='center', fig.cap="(ref:predictions-per-vowel)"}
p.accuracy.io.per.vowel
```
\end{landscape}

# General discussion {#sec:discussion}

## Summary of findings
This paper has compared low-level pre-linguistic normalization accounts against a new phonetically annotated database of Stockholm Swedish vowels. We set out to evaluate how the different accounts affect the category separability (Study 1), and how they differ in predicted consequences for perception (Study 2). The results from Study 1 showed that the same type of accounts proven successful in previous evaluations, were also successful in improving category separability for Swedish vowels. Previous work had found different results for Swedish than for other Germanic languages [@disner1980], but based on the approach taken here---using hVd words for recording, and a separability index as evaluation metric---that does not seem to be the case. In Study 1, centering accounts were among the best performing accounts, similarly to the other languages in @disner1980. It might well be the case that the (somewhat) diverging results for Swedish in @disner1980's study, was not caused by properties inherent to Swedish, but more likely an effect of the nature of the dataset used. We do, however, see some possible effects of language-specific properties in the somewhat surprising results from evaluations including more cues besides F1 and F2. Results that could presumably be attributed to the nature of the separability index itself, but also possibly to language-specific properties, where intrinsic accounts' sensitivity to F3 might work surprisingly well in separating vowel categories in Stockholm Swedish. 

In Study 2, we assessed the predicted consequences for perception by training ideal observer models on the acoustic data transformed into different normalization spaces, under different assumptions about the relevant cues and vowel space sizes. The results indicated that Lobanov and centering approaches were the top-performing accounts, which generally replicated previous studies comparing predictions against production data [e.g., @adank2004; @barreda2018a; @carpenter1993; @escudero2007; @syrda1985]. As more cues were included, presumably making models more human-like, the relative advantage of Lobanov normalization seemed to decrease, which points to the importance of duration, not only for distinguishing between long and short allophones in Stockholm Swedish, but also for category distinctions of the long and short vowels *separately*.

## Innovation
Evaluating normalization accounts against the dense vowel space of Swedish, has allowed us to assess whether the same normalization accounts that work well for vowel systems with fewer categories, work equally well for more complex systems---this was indeed confirmed. Studying Swedish, a language with a systematic quantity distinction, has furthermore allowed for a bridging of the literature on vowel-specific accounts and general normalization accounts [such as C-CuRE, @cole2010; @mcmurray-jongman2011], and for expanding on previous research that primarily has focused on the first two (or three) formants. C-CuRE has so far successfully been applied to a few languages (this study included): Arabic [@kulikov2022], English [e.g., @apfelbaum2014; @crinnion2020; @kleinschmidt2019; @mcmurray-jongman2011; @mcmurray-jongman2016; @toscano2015; @xie2021cognition; @xie2022], and Swedish. If the results from this study gets confirmed by future work on other languages, it would suggest that normalization might be neither category- nor formant-specific, but rather best captured by computing cues relative to the listener's expectations.

## Methodological considerations
In this paper, two methods of evaluations were used. In Study 1, we compared the reduction of within-category variability relative to between-category variability by calculating a separability index (i.e., an F-statistics). This methodology facilitated comparison to previous studies, that has most often assessed the efficacy of normalization accounts by means of increase in between-talker category overlap or category separability, or decrease in category variability [@disner1980; @fabricius2009; @Flynn2011; @hindle1978; @labov2010]. However, given the limitations inherent in this index, in the second study, we used Bayesian ideal observers to investigate how normalization accounts differ in predictions for perception. Previous studies have employed linear discriminant analysis [e.g., @adank2004; @syrda1985], fuzzy ARTMAP or K-nearest neighbour classification [e.g., @carpenter1993], or constraint ranking grammars [e.g., @escudero2007]. While these different approaches will generally return similar results, we see two advantages with ideal observers. First, ideal observers as used here have 0 degrees of freedom in the link from production to perception, thus removing researchers' degrees of freedom in the evaluation of normalization accounts [see @tan2021]. Second, representing the cue likelihood for each category as multivariate Gaussian distributions [e.g., @kronrod2016; @norris-mcqueen2008; @xie2021cognition], strikes a middle ground between less parsimonious models such as exemplar models [e.g., @johnson1997; @pierrehumbert2001], and more parsimonious models, such as models of cue integration over multiple separate univariate Gaussians [e.g., @toscano-mcmurray2010].^[Parsimony here refers both to the number of degrees of freedom these models afford to the researcher *and* to the amount of information that listeners are assumed to store [for discussion, see @xie2022].] However, like any other model of speech perception, the approach adopted here comes with a set of simplifying assumptions. All of the assumptions in the model, e.g., uniform priors, models of linguistic representations, the normalization accounts selected, can, however, be revisited and altered by the reader, as this paper is written in R markdown and all data and code is provided in the SI/OFS.

As a final note on methodology, we find the 5-fold cross-validation approach used for normalization of the acoustic data adopted here, advantageous for several reasons, the two most important being that: (1) it allows us to avoid over-fitting to the sample, while also (2) providing a more realistic reflection of how parameters used for normalization are incrementally inferred from the talker's speech input. Even though many of the commonly adopted normalization accounts involve parameters that are set based on the data, previous studies have rarely, if ever, considered how these parameters might be affected by the specific dataset used for normalization.

## Limitations and future directions
Three limitations of the present study deserve discussion. The present study compared normalization accounts against speech from only female talkers of one regional variety of Swedish (Stockholm Swedish). In contrast, many previous studies included data from talkers of different genders [e.g., @clopper2009], and sometimes from talkers of different ages [e.g., @barreda2018a; @carpenter1993; @Flynn2011; @hindle1978; @kohn2012a; @syrda1985] and/or language backgrounds [e.g., @adank2004; @disner1980; @escudero2007; @fabricius2009; @labov2010; @richter2017].
Given that age, gender, etc. tends to affect formants (and other cues) beyond talker-variability, it is likely that the inclusion of more diverse talkers would increase the lack of invariance problem. For example, we would expect the ideal observers over unnormalized cues (Study 2) to achieve lower recognition performance if vowel productions from male talkers would be included in the data. In short, the models in Study 2 likely over-estimates the recognition accuracy that can be achieved for unnormalized cues if a more diverse range of talkers is considered.

What does that mean for the relative effect of normalization? To the extent that normalization successfully overcomes inter-talker variability that is caused by gender, age, and other social or physiological factors, we expect that the benefit of normalization accounts should show more clearly, relative to unnormalized cues. In this sense, the present study might *under*-estimate the relative benefits of normalization. Whether the relative performance of normalization accounts would differ if a more diverse range of talkers was considered is even less clear. To the extent that vowel-specific accounts were originally developed specifically to eliminate physiological differences that are correlated with gender [e.g., @johnson-sjerps2021], it is theoretically possible that the high performance of general normalization accounts [e.g., C-CuRE, @mcmurray-jongman2011] might not replicate when talkers of different genders are included. <!-- TO DO: I wonder what the ADank study says about this? did they compare how well accounts performed in removing non-gender talker variabiltiy vs. gender variability or did they only compare gender vs. dialect? --> Future releases of the SwehVd database will contain data from male talkers, which will allow us or other researchers to revisit this issue.

Second, the present study aggregated acoustic-phonetic measurements taken at different points of the vowel (at 35%, 50%, and 65% into the vowel) into a single formant measurement. This follows previous comparisons of normalization accounts but is a simplifying assumption that should be revisited in future work. Formant dynamics can carry important for category distinctions [e.g., @Assmann2005; @hillenbrand1999; @nearey1986], and is hypothesized to be of particular importance for some vowel distinctions in other varieties of Central Swedish [e.g., @kuronen2000]. This means that Study 2 likely under-estimates the recognition accuracy that could be achieved from unnormalized cues alone. However, to the extent that we considered additional cues in Study 2, this never changed that normalization improved recognition accuracy, not did it affect the relative performance of the different normalization accounts. Future work could employ SwehVd to compare ideal observers or other classification models while taking into consideration more information about formant trajectories.

Third and last, we note that the present study only considered competing normalization accounts. This, too, follows previous research on normalization but is potentially problematic. As mentioned in the introduction, it is now believed that at least three different mechanisms contribute to adaptive speech perception, including not only normalization but also changes in category representations and decision-making [for review, see @xie2022].This has consequences for research on normalization. For example, @xie2021cognition compared normalization accounts against the production of prosodic phrasing in L1-US English, while also considering alternative hypotheses about listeners' ability to adapt category representations. Xie and colleagues found that the effectiveness of cue normalization is substantially reduced if listeners can learn and maintain talker- or group-specific category representations [as assumed in some influential theories of speech perception, exemplar models, e.g., @johnson1997; @pierrehumbert2001; Bayesian ideal adaptors, @kleinschmidt-jaeger2015]. Xie and colleagues only considered two general types of normalization, and their focus was on the interpretation of prosodic signals. But their results call for caution in interpreting studies like the present that do not consider the possibility of talker-specific representations---an assumption shared with basically all previous work on vowel normalization.

# References{#sec:references}

\begingroup
\setlength{\parindent}{-0.5in}
\setlength{\leftskip}{0.5in}

<div id="refs" custom-style="Bibliography"></div>
\endgroup

\newpage
\setcounter{page}{1}
\renewcommand{\thesection}{\S \arabic{section}}
\renewcommand{\theHsection}{sisection. \arabic{section}}

# Supplementary information {-}

\setcounter{section}{0}

# Additional information about the SwehVd databasee

## Participant recruitment {#sec:recruitment}
Participants were recruited through word-of-mouth, flyers at Stockholm University Campus, and online channels (accindi.se). Figure \@ref(fig:flyer) is an example of flyers distributed at Stockholm University Campus. The flyer gives information on criteria for participation, recording procedure, reimbursement and contact information to experimenter (first author).

(ref:flyer) Example flyer for recruiting Stockholm Swedish talkers for recording of the SwehVd database.

```{r flyer, fig.cap="(ref:flyer)"}
include_graphics("ad_recruitment.png")
```

## Word list
Word list with all target and filler words, recorded by all talkers in the SwehVd database.

\begin{table}
\caption{\label{tab:word-list}Words recorded by the female talkers of Swedish for the SwehVd database}
\centering
\begin{tabular}[t]{c|c}
\hline
Target words&Vowel IPA\\
\hline
hid&`r linguisticsdown::cond_cmpl("[iː]")`\\
\hline
hidd&`r linguisticsdown::cond_cmpl("[ɪ]")`\\
\hline
hyd&`r linguisticsdown::cond_cmpl("[yː]")`\\
\hline
hydd&`r linguisticsdown::cond_cmpl("[ʏ]")`\\
\hline
hed&`r linguisticsdown::cond_cmpl("[eː]")`\\
\hline
hedd&`r linguisticsdown::cond_cmpl("[ɛ]")`\\
\hline
häd&`r linguisticsdown::cond_cmpl("[ɛː]")`\\
\hline
hädd&`r linguisticsdown::cond_cmpl("[ɛ]")`\\
\hline
härd&`r linguisticsdown::cond_cmpl("[æː]")`\\
\hline
härr&`r linguisticsdown::cond_cmpl("[æ]")`\\
\hline
höd&`r linguisticsdown::cond_cmpl("[øː]")`\\
\hline
hödd&`r linguisticsdown::cond_cmpl("[ø]")`\\
\hline
hörd&`r linguisticsdown::cond_cmpl("[œː]")`\\
\hline
hörr&`r linguisticsdown::cond_cmpl("[œ]")`\\
\hline
hud&`r linguisticsdown::cond_cmpl("[ʉː]")`\\
\hline
hudd&`r linguisticsdown::cond_cmpl("[ɵ]")`\\
\hline
hod&`r linguisticsdown::cond_cmpl("[uː]")`\\
\hline
hodd&`r linguisticsdown::cond_cmpl("[ʊ]")`\\
\hline
håd&`r linguisticsdown::cond_cmpl("[oː]")`\\
\hline
hådd&`r linguisticsdown::cond_cmpl("[ɔ]")`\\
\hline
had&`r linguisticsdown::cond_cmpl("[ɑː]")`\\
\hline
hadd&`r linguisticsdown::cond_cmpl("[a]")`\\
\hline
\end{tabular}
\hspace{2em}
\begin{tabular}[t]{c|c}
\hline
\multicolumn{2}{c}{Filler words}\\
\hline
titt&tand\\
\hline
damm&dipp\\
\hline
tå&buss\\
\hline
bål&ding\\
\hline
dill&porr\\
\hline
tugga&mitt\\
\hline
mat&dopp\\
\hline
norr&tal\\
\hline
must&namn\\
\hline
pil&pall\\
\hline
dina&bar\\
\hline
biff&till\\
\hline
Tina&mål\\
\hline
borr&Nina\\
\hline
dal&då\\
\hline
Pål&nick\\
\hline
nunna&ditt\\
\hline
mil&dugga\\
\hline
ting&mall\\
\hline
ball&bil\\
\hline
piff&par\\
\hline
tipp&morr\\
\hline
puss&nav\\
\hline
topp&nå\\
\end{tabular}
\end{table}

# Additional information for Study 1

## Correlation matrices for all normalization accounts {#sec:correlation-matrices}
Here we include correlation matrices for the SwehVd vowel data, transformed into the 15 different normalization spaces.

(ref:correlation-matrix-Mel) The SwehVd vowel data in Mel space. Points show repetitions of each of the 21 Swedish vowels by 16 female native talkers in the database in F0-F3 and vowel duration cue space. Vowel labels indicate category means across talkers. Long vowels are boldfaced. Ellipses show bivariate Gaussian 95% confidence interval of category means.

```{r correlation-matrix-Mel, fig.width=base.width*3.5, fig.height=base.height*3.5+.5, fig.cap="(ref:correlation-matrix-Mel)"}
p.matrix.cues %+%
  (d.SwehVd.forStudy.long %>%
  filter(fold_type == "test" & Normalization.Type == "transformed (Mel)"))
```

(ref:correlation-matrix-Bark) The SwehVd vowel data in Bark space. Points show repetitions of each of the 21 Swedish vowels by 16 female native talkers in the database in F0-F3 and vowel duration cue space. Vowel labels indicate category means across talkers. Long vowels are boldfaced. Ellipses show bivariate Gaussian 95% confidence interval of category means.

```{r correlation-matrix-Bark, fig.width=base.width*3.5, fig.height=base.height*3.5+.5, fig.cap="(ref:correlation-matrix-Bark)"}
p.matrix.cues %+%
  (d.SwehVd.forStudy.long %>%
  filter(fold_type == "test" & Normalization.Type == "transformed (Bark)"))
```

(ref:correlation-matrix-ERB) The SwehVd vowel data in ERB space. Points show repetitions of each of the 21 Swedish vowels by 16 female native talkers in the database in F0-F3 and vowel duration cue space. Vowel labels indicate category means across talkers. Long vowels are boldfaced. Ellipses show bivariate Gaussian 95% confidence interval of category means.

```{r correlation-matrix-ERB, fig.width=base.width*3.5, fig.height=base.height*3.5+.5, fig.cap="(ref:correlation-matrix-ERB)"}
p.matrix.cues %+%
  (d.SwehVd.forStudy.long %>%
  filter(fold_type == "test" & Normalization.Type == "transformed (ERB)"))
```

(ref:correlation-matrix-semitones) The SwehVd vowel data in semitones space. Points show repetitions of each of the 21 Swedish vowels by 16 female native talkers in the database in F0-F3 and vowel duration cue space. Vowel labels indicate category means across talkers. Long vowels are boldfaced. Ellipses show bivariate Gaussian 95% confidence interval of category means.

```{r correlation-matrix-semitones, fig.width=base.width*3.5, fig.height=base.height*3.5+.5, fig.cap="(ref:correlation-matrix-semitones)"}
p.matrix.cues %+%
  (d.SwehVd.forStudy.long %>%
  filter(fold_type == "test" & Normalization.Type == "transformed (semitones)"))
```

(ref:correlation-matrix-syrdalgopal) The SwehVd vowel data in SyrdalGopal (Bark) space. Points show repetitions of each of the 21 Swedish vowels by 16 female native talkers in the database in F0-F3 and vowel duration cue space. Vowel labels indicate category means across talkers. Long vowels are boldfaced. Ellipses show bivariate Gaussian 95% confidence interval of category means.

```{r correlation-matrix-syrdalgopal, fig.width=base.width*3.5, fig.height=base.height*3.5+.5, fig.cap="(ref:correlation-matrix-syrdalgopal)"}
p.matrix.cues %+%
  (d.SwehVd.forStudy.long %>%
  filter(fold_type == "test" & Normalization.Type == "SyrdalGopal (Bark)"))
```

(ref:correlation-matrix-miller) The SwehVd vowel data in Miller (log) space. Points show repetitions of each of the 21 Swedish vowels by 16 female native talkers in the database in F0-F3 and vowel duration cue space. Vowel labels indicate category means across talkers. Long vowels are boldfaced. Ellipses show bivariate Gaussian 95% confidence interval of category means.

```{r correlation-matrix-miller, fig.width=base.width*3.5, fig.height=base.height*3.5+.5, fig.cap="(ref:correlation-matrix-miller)"}
p.matrix.cues %+%
  (d.SwehVd.forStudy.long %>%
  filter(fold_type == "test" & Normalization.Type == "Miller (log)"))
```
(ref:correlation-matrix-ccure-hz) The SwehVd vowel data in C-CuRE Hz space. Points show repetitions of each of the 21 Swedish vowels by 16 female native talkers in the database in F0-F3 and vowel duration cue space. Vowel labels indicate category means across talkers. Long vowels are boldfaced. Ellipses show bivariate Gaussian 95% confidence interval of category means.

```{r correlation-matrix-ccure-hz, fig.width=base.width*3.5, fig.height=base.height*3.5+.5, fig.cap="(ref:correlation-matrix-ccure-hz)"}
p.matrix.cues %+%
  (d.SwehVd.forStudy.long %>%
  filter(fold_type == "test" & Normalization.Type == "C-CuRE (Hz)"))
```

(ref:correlation-matrix-ccure-mel) The SwehVd vowel data in C-CuRE Mel space. Points show repetitions of each of the 21 Swedish vowels by 16 female native talkers in the database in F0-F3 and vowel duration cue space. Vowel labels indicate category means across talkers. Long vowels are boldfaced. Ellipses show bivariate Gaussian 95% confidence interval of category means.

```{r correlation-matrix-ccure-mel, fig.width=base.width*3.5, fig.height=base.height*3.5+.5, fig.cap="(ref:correlation-matrix-ccure-mel)"}
p.matrix.cues %+%
  (d.SwehVd.forStudy.long %>%
  filter(fold_type == "test" & Normalization.Type == "C-CuRE (Mel)"))
```

(ref:correlation-matrix-ccure-bark) The SwehVd vowel data in C-CuRE Bark space. Points show repetitions of each of the 21 Swedish vowels by 16 female native talkers in the database in F0-F3 and vowel duration cue space. Vowel labels indicate category means across talkers. Long vowels are boldfaced. Ellipses show bivariate Gaussian 95% confidence interval of category means.

```{r correlation-matrix-ccure-bark, fig.width=base.width*3.5, fig.height=base.height*3.5+.5, fig.cap="(ref:correlation-matrix-ccure-bark)"}
p.matrix.cues %+%
  (d.SwehVd.forStudy.long %>%
  filter(fold_type == "test" & Normalization.Type == "C-CuRE (Bark)"))
```

(ref:correlation-matrix-ccure-erb) The SwehVd vowel data in C-CuRE ERB space. Points show repetitions of each of the 21 Swedish vowels by 16 female native talkers in the database in F0-F3 and vowel duration cue space. Vowel labels indicate category means across talkers. Long vowels are boldfaced. Ellipses show bivariate Gaussian 95% confidence interval of category means.

```{r correlation-matrix-ccure-erb, fig.width=base.width*3.5, fig.height=base.height*3.5+.5, fig.cap="(ref:correlation-matrix-ccure-erb)"}
p.matrix.cues %+%
  (d.SwehVd.forStudy.long %>%
  filter(fold_type == "test" & Normalization.Type == "C-CuRE (ERB)"))
```

(ref:correlation-matrix-ccure-semitones) The SwehVd vowel data in C-CuRE semitones space. Points show repetitions of each of the 21 Swedish vowels by 16 female native talkers in the database in F0-F3 and vowel duration cue space. Vowel labels indicate category means across talkers. Long vowels are boldfaced. Ellipses show bivariate Gaussian 95% confidence interval of category means.

```{r correlation-matrix-ccure-semitones, fig.width=base.width*3.5, fig.height=base.height*3.5+.5, fig.cap="(ref:correlation-matrix-ccure-semitones)"}
p.matrix.cues %+%
  (d.SwehVd.forStudy.long %>%
  filter(fold_type == "test" & Normalization.Type == "C-CuRE (semitones)"))
```

(ref:correlation-matrix-nearey1) The SwehVd vowel data in Nearey1 (log) space. Points show repetitions of each of the 21 Swedish vowels by 16 female native talkers in the database in F0-F3 and vowel duration cue space. Vowel labels indicate category means across talkers. Long vowels are boldfaced. Ellipses show bivariate Gaussian 95% confidence interval of category means.

```{r correlation-matrix-nearey1, fig.width=base.width*3.5, fig.height=base.height*3.5+.5, fig.cap="(ref:correlation-matrix-nearey1)"}
p.matrix.cues %+%
  (d.SwehVd.forStudy.long %>%
  filter(fold_type == "test" & Normalization.Type == "Nearey1 (log)"))
```

(ref:correlation-matrix-nearey2) The SwehVd vowel data in Nearey2 (log) space. Points show repetitions of each of the 21 Swedish vowels by 16 female native talkers in the database in F0-F3 and vowel duration cue space. Vowel labels indicate category means across talkers. Long vowels are boldfaced. Ellipses show bivariate Gaussian 95% confidence interval of category means.

```{r correlation-matrix-nearey2, fig.width=base.width*3.5, fig.height=base.height*3.5+.5, fig.cap="(ref:correlation-matrix-nearey2)"}
p.matrix.cues %+%
  (d.SwehVd.forStudy.long %>%
  filter(fold_type == "test" & Normalization.Type == "Nearey2 (log)"))
```

(ref:correlation-matrix-gerstman) The SwehVd vowel data in Gerstman (Hz) space. Points show repetitions of each of the 21 Swedish vowels by 16 female native talkers in the database in F0-F3 and vowel duration cue space. Vowel labels indicate category means across talkers. Long vowels are boldfaced. Ellipses show bivariate Gaussian 95% confidence interval of category means.

```{r correlation-matrix-gerstman, fig.width=base.width*3.5, fig.height=base.height*3.5+.5, fig.cap="(ref:correlation-matrix-gerstman)"}
p.matrix.cues %+%
  (d.SwehVd.forStudy.long %>%
  filter(fold_type == "test" & Normalization.Type == "Gerstman (Hz)"))
```

(ref:correlation-matrix-lobanov) The SwehVd vowel data in Lobanov (Hz) space. Points show repetitions of each of the 21 Swedish vowels by 16 female native talkers in the database in F0-F3 and vowel duration cue space. Vowel labels indicate category means across talkers. Long vowels are boldfaced. Ellipses show bivariate Gaussian 95% confidence interval of category means.

```{r correlation-matrix-lobanov,fig.width=base.width*3.5, fig.height=base.height*3.5+.5, fig.cap="(ref:correlation-matrix-lobanov)"}
p.matrix.cues %+%
  (d.SwehVd.forStudy.long %>%
  filter(fold_type == "test" & Normalization.Type == "Lobanov (Hz)"))
```

# Additional information for Study 2

## Per-vowel categorization accuracy of models trained on long and short vowels separately {#sec:accuracy-per-vowel}

(ref:predictions-per-vowel-long) Per-vowel predicted categorization accuracy of the ideal observers trained on the long vowels, under different assumptions about the relevant cues. Point ranges indicate the average mean accuracy and average 95% bootstrapped CI across the five folds. Chance level is indicated by grey line.

```{r}
#Do multiple plots because of plot size
p.accuracy.io.per.vowel.long.1 <- plot_io_results_per_vowel(
  m.io.SwehVd %>%
    filter(IO.Quantity == "long") %>%
    nplyr::nest_filter(posterior_of_intended_vowel, Intended.Vowel %in% c("[iː]", "[yː]", "[ʉː]", "[eː]", "[ɛː]"))) +
  facet_grid(Cue_space ~  factor(Intended.Vowel, levels = levels.vowel.IPA.swe)) + theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), axis.title.y = element_blank())
p.accuracy.io.per.vowel.long.2 <- plot_io_results_per_vowel(
  m.io.SwehVd %>%
    filter(IO.Quantity == "long") %>%
    nplyr::nest_filter(posterior_of_intended_vowel, Intended.Vowel %in% c("[æː]", "[øː]", "[œː]", "[ɑː]", "[oː]", "[uː]"))) +
  facet_grid(Cue_space ~  factor(Intended.Vowel, levels = levels.vowel.IPA.swe))

axis.title.accuracy <- grid::textGrob("Accuracy (of predicting *intended* vowel)", gp=grid::gpar(fontface="bold", fontsize=8), rot=90)

p.accuracy.io.per.vowel.short.1 <- plot_io_results_per_vowel(
  m.io.SwehVd %>%
    filter(IO.Quantity == "short") %>%
    nplyr::nest_filter(posterior_of_intended_vowel, Intended.Vowel %in% c("[ɪ]", "[ʏ]", "[ɵ]", "[ɛ]", "[æ]"))) +
  facet_grid(Cue_space ~  factor(Intended.Vowel, levels = levels.vowel.IPA.swe)) + theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), axis.title.y = element_blank())
p.accuracy.io.per.vowel.short.2 <- plot_io_results_per_vowel(
  m.io.SwehVd %>%
    filter(IO.Quantity == "short") %>%
    nplyr::nest_filter(posterior_of_intended_vowel, Intended.Vowel %in% c("[ø]", "[œ]", "[a]", "[ɔ]", "[ʊ]"))) +
  facet_grid(Cue_space ~  factor(Intended.Vowel, levels = levels.vowel.IPA.swe))

p.accuracy.io.per.vowel.all.1 <- plot_io_results_per_vowel(
  m.io.SwehVd %>%
    filter(IO.Quantity == "all") %>%
    nplyr::nest_filter(posterior_of_intended_vowel, Intended.Vowel %in% c("[iː]", "[ɪ]", "[yː]", "[ʏ]", "[ʉː]", "[ɵ]", "[eː]", "[ɛ]", "[ɛː]", "[æː]"))) +
  facet_grid(Cue_space ~  factor(Intended.Vowel, levels = levels.vowel.IPA.swe)) + theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), axis.title.y = element_blank())
p.accuracy.io.per.vowel.all.2 <- plot_io_results_per_vowel(
  m.io.SwehVd %>%
    filter(IO.Quantity == "all") %>%
    nplyr::nest_filter(posterior_of_intended_vowel, Intended.Vowel %in% c("[æ]", "[øː]", "[ø]", "[œː]", "[œ]", "[ɑː]", "[a]", "[oː]", "[ɔ]", "[uː]", "[ʊ]"))) +
  facet_grid(Cue_space ~  factor(Intended.Vowel, levels = levels.vowel.IPA.swe))
```

```{r predictions-per-vowel-long, fig.width=base.width * 4, fig.height=base.height * 4, fig.align='center', fig.cap="(ref:predictions-per-vowel-long)"}
#p.accuracy.io.per.vowel.long <- cowplot::plot_grid(
#   cowplot::plot_grid(p.accuracy.io.per.vowel.long.1, NULL, ncol = 2, rel_widths = c(5/6,1/6)), 
#   p.accuracy.io.per.vowel.long.2 + theme(axis.title.y = element_blank()), ncol = 1, align = "hv", axis = "l")
# gridExtra::grid.arrange(gridExtra::arrangeGrob(p.accuracy.io.per.vowel.long, left = axis.title.accuracy))
# 
# gridExtra::grid.arrange(p.accuracy.io.per.vowel.long.1, p.accuracy.io.per.vowel.long.2+ theme(axis.title.y = element_blank()), left = axis.title.accuracy, nrow =2, heights = 2:3)
```

(ref:predictions-per-vowel-short) Per-vowel predicted categorization accuracy of the ideal observers trained on the short vowels, under different assumptions about the relevant cues. Point ranges indicate the average mean accuracy and average 95% bootstrapped CI across the five folds. Chance level is indicated by grey line.

```{r predictions-per-vowel-short, fig.width=base.width * 4, fig.height=base.height * 4, fig.align='center', fig.cap="(ref:predictions-per-vowel-short)"}
p.accuracy.io.per.vowel.short <- cowplot::plot_grid(p.accuracy.io.per.vowel.short.1, p.accuracy.io.per.vowel.short.2 + theme(axis.title.y = element_blank()), ncol = 1, align = "hv", axis = "l")
gridExtra::grid.arrange(gridExtra::arrangeGrob(p.accuracy.io.per.vowel.short, left = axis.title.accuracy))
```

(ref:predictions-per-vowel-all) Per-vowel predicted categorization accuracy of the ideal observers trained on all vowels, under different assumptions about the relevant cues. Point ranges indicate the average mean accuracy and average 95% bootstrapped CI across the five folds. Chance level is indicated by grey line.

\begin{landscape}

```{r predictions-per-vowel-all, fig.width=base.width * 4, fig.height=base.height * 4, fig.align='center', fig.cap="(ref:predictions-per-vowel-all)"}
p.accuracy.io.per.vowel.all <- cowplot::plot_grid(
  cowplot::plot_grid(p.accuracy.io.per.vowel.all.1, NULL, ncol = 2, rel_widths = c(5/6,1/6)), 
  p.accuracy.io.per.vowel.all.2 + theme(axis.title.y = element_blank()), ncol = 1, align = "hv", axis = "l")
gridExtra::grid.arrange(gridExtra::arrangeGrob(p.accuracy.io.per.vowel.all, left = axis.title.accuracy))
```
\end{landscape}

## Confusion matrices of ideal observers {#sec:confusion}
To further explore effects of neighbouring categories, and which categories are more easily confused by the IOs and with what, we plot confusion matrices of the worst and best performing IOs trained on the long, short or all Swedish vowels, under the different assumptions about the relevant cues. As expected, the worse performing models have more competitors for each intended vowel, that is, the models are more confused about the underlying category. When there is high competition from many close neighbours, as in areas with substantial category overlap, models are more inclined to confuse categories with one of their neighbours. This is especially evident for the high vowels, but also for the allophones to [`r linguisticsdown::cond_cmpl("ɛ")`] and [`r linguisticsdown::cond_cmpl("ø")`]. Some of the worst performing models select a neighbouring category as often as the actual intended category (see e.g., model performance for [`r linguisticsdown::cond_cmpl("iː")`] and [`r linguisticsdown::cond_cmpl("yː")`] in Figures \@ref(fig:confusion-matrix-long) and \@ref(fig:confusion-matrix-allVowels). These vowels, however, become less confusable as F3 is included as cue, which might support previous perceptual evidence, suggesting the importance of F3 for distinguishing the Central Swedish high vowels [e.g., @fujimura1967].

Given that the closest neighbour is not necessarily the category's short/long counterpart, it is not primarily the case that quantity distinctions are the cause of models' confusion (Figure \@ref(fig:confusion-matrix-allVowels)). In fact, some vowels are never confused with their long or short counterpart, e.g., [`r linguisticsdown::cond_cmpl("ʉː")`], [`r linguisticsdown::cond_cmpl("aː")`], and [`r linguisticsdown::cond_cmpl("yː")`]. As more information is given the models, confusability declines substantially. When F3 and duration are included, confusability among the high vowels is reduced, and no long-short quantity confusions remain (Figure \@ref(fig:confusion-matrix-allVowels), right panel, final row).

Of note is also that some categories are rarely confused with other categories, across evaluations. This is the case for [`r linguisticsdown::cond_cmpl("aː")`] and [`r linguisticsdown::cond_cmpl("eː")`]. What might be driving this is not entirely evident. [`r linguisticsdown::cond_cmpl("aː")`] is fairly isolated in the mid-right part of the space(see Figure \@ref(fig:swe-vowels)), and not particularly overlapping other categories. [`r linguisticsdown::cond_cmpl("eː")`], however, is located in the bottom part of the dense high front part of the space, and quite overlapping with other categories. Given the crowdedness of this location, the [`r linguisticsdown::cond_cmpl("eː")`] might be considered relatively isolated in comparison to the other neighbouring, and substantially overlapping, categories. The relatively low confusability of that category might thus be an effect of the density of the space and the number of competing categories affecting each other. 
In sum, these results suggest that confusability seems to primarily be driven by the number of close, or overlapping, neighbouring categories. As models presumably become more human-like, confusability decreases. The vowel-specific effects presented here, follow the general pattern found in the overall results.

```{r, echo=FALSE}
# Keep code for reproducibility
# run a model assessing the difference in performance between models as a function of the normalization scheme.
# data.io <- m.io.SwehVd.F1F2 %>%
#   unnest(posterior_of_intended_vowel) %>%
#   mutate(IO.Normalization.Type = factor(IO.Normalization.Type, levels = levels.normalization.plots, labels = labels.normalization))

#Add treatment coding for IO.Normalization.Type
#contrasts(data.io$IO.Normalization.Type) = contr.treatment(16)
# # contrasts(data.io$IO.cue_normalization) = cbind(
# #   "C-CuRE Hz" = c(0, 1, 0, 0, 0, 0, 0),
# #   "Lobanov Hz" = c(0, 0, 1, 0, 0, 0, 0),
# #   "Gerstman Hz" = c(0, 0, 0, 1, 0, 0, 0),
# #   "Nearey1 log" = c(0, 0, 0, 0, 1, 0, 0),
# #   "Nearey2 log" = c(0, 0, 0, 0, 0, 1, 0),
# #   "Miller log" = c(0, 0, 0, 0, 0, 0, 1))
# 
# model <- glm(Posterior ~ IO.Normalization.Type, family=gaussian, data = data.io)
# summary(model)
```
```{r}
plot_io_confusion <- function(
  data,
  cols = cols) {
  data %>%
    unnest(posterior_of_all_vowels) %>%
    pivot_longer(
    cols = cols,
    values_to = "Posterior",
    names_to = "IO.Vowel") %>%
    { if ("IO.Quantity" %in% names(data)) group_by(., IO.Vowel, Intended.Vowel, IO.Normalization.Type, IO.Quantity, Cue_space) else group_by(., IO.Vowel, Intended.Vowel, IO.Normalization.Type, Cue_space) } %>%
    summarise(across(.cols = Posterior, mean, na.rm = T)) %>%
    ggplot(
      aes(
        x = factor(Intended.Vowel, levels = levels.vowel.IPA.swe),
        y = factor(IO.Vowel, levels = levels.vowel.IPA.swe),
        fill = Posterior)) +
    geom_raster() +
    scale_x_discrete("Intended vowel", expand = c(0,0)) +
    scale_y_discrete("IO response vowel", expand = c(0,0)) +
    scale_fill_viridis_b("Posterior probability under ideal observer", limits = c(0,1), breaks = seq(0, 1, .1)) +
    facet_grid(Cue_space ~ IO.Normalization.Type) +
    theme(axis.title.x = element_blank(), 
          axis.title.y = element_blank())
}
```

```{r }
# Make confusion matrices of best and worst for all cue evaluations under the assumption of long, short or all vowels
p.confusion.long.F1F2 <- plot_io_confusion(
  m.io.SwehVd %>% filter(IO.Normalization.Type %in% c("Miller_log", "Lobanov_Hz"), Cue_space == "F1-F2", IO.Quantity == "long"),
                         cols = levels.vowel.IPA.swe.long) +
    facet_grid(Cue_space ~ factor(IO.Normalization.Type, levels = c("Miller_log", "Lobanov_Hz"), labels = c("Miller (log)", "Lobanov (Hz)"))) + theme(legend.position="none")
p.confusion.long.F1F3 <- plot_io_confusion(
  m.io.SwehVd %>% filter(IO.Normalization.Type %in% c("Miller_log", "Lobanov_Hz"), Cue_space == "F1-F3", IO.Quantity == "long"),
                         cols = levels.vowel.IPA.swe.long) +
    facet_grid(Cue_space ~ factor(IO.Normalization.Type, levels = c("Miller_log", "Lobanov_Hz"), labels = c("Miller (log)", "Lobanov (Hz)"))) + theme(legend.position="none")
p.confusion.long.all <- plot_io_confusion(
  m.io.SwehVd %>% filter(IO.Normalization.Type %in% c("Gerstman_Hz", "Lobanov_Hz"), Cue_space == "F0-F3, duration", IO.Quantity == "long"),
                         cols = levels.vowel.IPA.swe.long) +
    facet_grid(Cue_space ~ factor(IO.Normalization.Type, levels = c("Gerstman_Hz", "Lobanov_Hz"), labels = c("Gerstman (Hz)", "Lobanov (Hz)"))) + theme(legend.position="none")

p.confusion.short.F1F2 <- plot_io_confusion(
  m.io.SwehVd %>% filter(IO.Normalization.Type %in% c("Miller_log", "CCuRE_Mel"), Cue_space == "F1-F2", IO.Quantity == "short"),
                         cols = levels.vowel.IPA.swe.short) +
    facet_grid(Cue_space ~ factor(IO.Normalization.Type, levels = c("Miller_log", "CCuRE_Mel"), labels = c("Miller (log)", "C-CuRE (Mel)"))) + theme(legend.position="none")
p.confusion.short.F1F3 <- plot_io_confusion(
  m.io.SwehVd %>% filter(IO.Normalization.Type %in% c("Miller_log", "CCuRE_Mel"), Cue_space == "F1-F3", IO.Quantity == "short"),
                         cols = levels.vowel.IPA.swe.short) +
    facet_grid(Cue_space ~ factor(IO.Normalization.Type, levels = c("Miller_log", "CCuRE_Mel"), labels = c("Miller (log)", "C-CuRE (Mel)"))) + theme(legend.position="none")
p.confusion.short.all <- plot_io_confusion(
  m.io.SwehVd %>% filter(IO.Normalization.Type %in% c("Gerstman_Hz", "Lobanov_Hz"), Cue_space == "F0-F3, duration", IO.Quantity == "short"),
                         cols = levels.vowel.IPA.swe.short) +
    facet_grid(Cue_space ~ factor(IO.Normalization.Type,  levels = c("Gerstman_Hz", "Lobanov_Hz"), labels = c("Gerstman (Hz)", "Lobanov (Hz)"))) + theme(legend.position="none")

p.confusion.all.F1F2 <- plot_io_confusion(
  m.io.SwehVd %>% filter(IO.Normalization.Type %in% c("SyrdalGopal_Bark", "Lobanov_Hz"), Cue_space == "F1-F2", IO.Quantity == "all"),
                         cols = levels.vowel.IPA.swe) +
    facet_grid(Cue_space ~ factor(IO.Normalization.Type, levels = c("SyrdalGopal_Bark", "Lobanov_Hz"), labels = c("SyrdalGopal (bark)", "Lobanov (Hz)"))) + theme(legend.position="none")
p.confusion.all.F1F3 <- plot_io_confusion(
    m.io.SwehVd %>% filter(IO.Normalization.Type %in% c("Miller_log", "Lobanov_Hz"), Cue_space == "F1-F3", IO.Quantity == "all"), 
    cols = levels.vowel.IPA.swe) + 
  facet_grid(Cue_space ~ factor(IO.Normalization.Type, levels = c("Miller_log", "Lobanov_Hz"), labels = c("Miller (log)", "Lobanov (Hz)"))) + theme(legend.position="none")
p.confusion.all.all <- plot_io_confusion(
  m.io.SwehVd %>% filter(IO.Normalization.Type %in% c("Gerstman_Hz", "CCuRE_Hz"), Cue_space == "F0-F3, duration", IO.Quantity == "all"),
                         cols = levels.vowel.IPA.swe) +
    facet_grid(Cue_space ~ factor(IO.Normalization.Type, levels = c("Gerstman_Hz", "CCuRE_Hz"), labels = c("Gerstman (Hz)", "C-CuRE (Hz)")))

legend.confusion <- cowplot::get_legend(p.confusion.all.all +
  guides(fill = guide_legend(nrow = 1, byrow = TRUE)))
```

(ref:confusion-matrix-long) Confusion matrices for the worst (**left**) and best (**right**) performing ideal observers in predicting the **long** Swedish vowels, under different assumptions about the relevant cues. Vowel intended by talker (x-axis) is plotted against vowel selected by IO model (y-axis). Color fill indicates the posterior probability of the models predicting the intended vowel.

```{r confusion-matrix-long, fig.width=base.width*3, fig.height=base.height*4.5, fig.align='center', fig.cap="(ref:confusion-matrix-long)"}
cowplot::plot_grid(legend.confusion,
  cowplot::plot_grid(p.confusion.long.F1F2, p.confusion.long.F1F3, p.confusion.long.all + theme(legend.position = "none"), align = "hv", axis = "btlr", ncol = 1),
    nrow = 2, rel_heights = c(.08,1))
```

(ref:confusion-matrix-short) Confusion matrices for the worst (**left**) and best (**right**) performing ideal observers in predicting the **short** Swedish vowels, under different assumptions about the relevant cues. Vowel intended by talker (x-axis) is plotted against vowel selected by IO model (y-axis). Color fill indicates the posterior probability of the models predicting the intended vowel.

```{r confusion-matrix-short, fig.width=base.width*3, fig.height=base.height*4.5, fig.align='center', fig.cap="(ref:confusion-matrix-short)"}
cowplot::plot_grid(legend.confusion,
  cowplot::plot_grid(p.confusion.short.F1F2, p.confusion.short.F1F3, p.confusion.short.all + theme(legend.position = "none"), align = "hv", axis = "btlr", ncol = 1),
    nrow = 2, rel_heights = c(.08,1))
```

(ref:confusion-matrix-allVowels) Confusion matrices for the worst (**left**) and best (**right**) performing ideal observers in predicting **all 21** Swedish vowels, under different assumptions about the relevant cues. Vowel intended by talker (x-axis) is plotted against vowel selected by IO model (y-axis). Color fill indicates the posterior probability of the models predicting the intended vowel.

```{r confusion-matrix-allVowels, fig.width=base.width*3.75, fig.height=base.height*5.5, out.width='80%', fig.align='center', fig.cap="(ref:confusion-matrix-allVowels)"}
cowplot::plot_grid(legend.confusion,
  cowplot::plot_grid(p.confusion.all.F1F2, p.confusion.all.F1F3, p.confusion.all.all + theme(legend.position = "none"), align = "hv", axis = "btlr", ncol = 1),
    nrow = 2, rel_heights = c(.08,1)) 
```
